//
// spl.spl - simple programming language
//
// self hosted implementation of spl in spl
//

struct Options (
  compile         : u64,
  run             : u64,
  debug           : u64,
  filename        : cstr,
  enable_warnings : u64,
  disable_dce     : u64,
  dce_all         : u64,
  verbose         : u64,
  verbose_asm     : u64
);

let options : Options = 0;

include "lib/common.spl"
include "src/common.spl"
include "src/config.spl"
include "src/misc.spl"
include "src/type.spl"
include "src/value.spl"
include "src/lexer.spl"
include "src/ast.spl"
include "src/parser.spl"
include "src/ir.spl"
include "src/codegen_nasm_x86_64.spl"
include "src/compile.spl"
include "src/typecheck.spl"
include "src/info.spl"

fn usage(prog : cstr) -> none {
  dprintf(STDOUT_FILENO,
"Usage; %s [OPTIONS]\n

OPTIONS:
   <filename>      - path to file
   run             - run program directly
   no-com          - do not compile target executable
   no-debug        - do not write debug information
   enable-warnings - enable basic warnings
   disable-dce     - disable dead code elimination
   dce-all         - eliminate all dead code, including all symbols
   verbose         - enable verbose output
   verbose-asm     - enable verbose assembly code
   version         - print spl version id
   help            - show help menu\n"
  , @prog);
}

fn spl_options_init -> none {
  store64 + @options Options.compile 1;
  store64 + @options Options.run 0;
  store64 + @options Options.debug 1;
  store64 + @options Options.filename NULL;
  store64 + @options Options.enable_warnings 0;
  store64 + @options Options.disable_dce 0;
  store64 + @options Options.dce_all 0;
  store64 + @options Options.verbose 0;
  store64 + @options Options.verbose_asm 0;
}

fn spl_start(filename : cstr) -> u64 {
  let result = NoError;

  let time_start : timespec = 0;
  let time_end : timespec = 0;
  { let _ = clock_gettime(CLOCK_MONOTONIC, @time_start); }

  let fd = open(filename, 0, O_RDONLY);
  if neq fd ERROR {
    let source = tmp_it;
    let size = read_file_into_buffer_and_null_terminate(fd, source);
    store64 @tmp_it + size tmp_it;
    if eq parser_init(filename, source) NoError {
      ast_push(
        cast ptr load64 + @p Parser.ast,
        parse()
      );
      if and eq load64 + @p Parser.status NoError eq l.status NoError {
        // ast_print(load64 + @p Parser.ast, 0, STDOUT_FILENO);
        if eq compile_state_init() NoError {
          // {
          //   let contract : any = (
          //     type_create(TypePtr, 0),
          //     type_create(TypePtr, 0),
          //     type_create(TypeStruct, 0)
          //   );
          //   let count : u64 = / sizeof contract sizeof any;
          //   let type : Type = 0;
          //   if eq type_from_contract(@contract, count, TYPE_CONTRACT_CREATE, @type) NoError {
          //     type_printline(STDOUT_FILENO, type);
          //   }
          // }
          if eq typecheck_program(cast ptr load64 + @p Parser.ast) NoError {
            if eq ir_start_compile(cast ptr load64 + @p Parser.ast) NoError {
              // typecheck_print_types(STDOUT_FILENO);

              if load64 + @options Options.compile {
                let target = TARGET_LINUX_NASM_X86_64;

                let output_file_path : u8 : MAX_PATH_SIZE = cast u8 0;
                let filename = cast cstr load64 + @options Options.filename;
                let diff : u64 = - cast u64 first_dot(filename) filename;
                sprintf(@output_file_path, "%s", @filename);
                store8 + @output_file_path diff 0; // null terminate

                if eq compile(target, cast cstr @output_file_path) NoError {
                  { let _ = clock_gettime(CLOCK_MONOTONIC, @time_end); }
                  print_time_elapsed("total compilation time was", @time_start, @time_end);
                  compile_print_final();

                  if load64 + @options Options.run {
                    let command : cstr = (
                      cast cstr @output_file_path,
                      cast cstr NULL
                    );
                    exec_command_echoed(STDOUT_FILENO, @command);
                  }
                }
              }
              if load64 + @options Options.debug {
                let path : u8 : MAX_PATH_SIZE = cast u8 0;
                sprintf(@path, "%s.debug", + @options Options.filename);
                let mode : u64 = 434; // 0662
                let flags : u64 = or or O_CREAT O_TRUNC O_WRONLY;
                let debug_fd : u64 = open(cast cstr @path, flags, mode);
                if neq debug_fd ERROR {
                  // ast_print(load64 + @p Parser.ast, 0, debug_fd);
                  ir_print(debug_fd);
                  print_symbol_info(debug_fd);
                  close(debug_fd);
                }
                else {
                  let args : any = @path;
                  error("failed to open file `%s`\n", @args);
                }
              }
            }
          }
          compile_state_free();
        }
      }
      parser_free();
    }
    close(fd);
  }
  else {
    let message = cast cstr tmp_it;
    sprintf(cast ptr tmp_it, "failed to open file `%s`\n", @filename);
    err(message);
  }
  result;
}

fn main(argc : u64, argv : any) -> none {
  common_init();
  config_init();
  ast_init();
  spl_options_init();

  let arg = argv;
  let i = 0;
  let should_exit : u64 = 0;
  if < argc 2 {
    usage(cast cstr load64 arg);
  }
  else {
    // TODO(lucas): implement a proper argument parser
    store64 @arg + sizeof ptr arg;
    while neq load64 arg NULL {
      let argument = cast cstr load64 arg;
      if eq 0 strcmp(argument, "run") {
        store64 + @options Options.run 1;
      }
      else if eq 0 strcmp(argument, "no-com") {
        store64 + @options Options.compile 0;
      }
      else if eq 0 strcmp(argument, "no-debug") {
        store64 + @options Options.debug 0;
      }
      else if eq 0 strcmp(argument, "enable-warnings") {
        store64 + @options Options.enable_warnings 1;
      }
      else if eq 0 strcmp(argument, "disable-dce") {
        store64 + @options Options.disable_dce 1;
      }
      else if eq 0 strcmp(argument, "dce-all") {
        store64 + @options Options.dce_all 1;
      }
      else if eq 0 strcmp(argument, "verbose") {
        store64 + @options Options.verbose 1;
      }
      else if eq 0 strcmp(argument, "verbose-asm") {
        store64 + @options Options.verbose_asm 1;
      }
      else if eq 0 strcmp(argument, "version") {
        dprintf(STDOUT_FILENO, "spl version id: %d\n", @VERSION_ID);
        store64 @should_exit 1;
      }
      else if eq 0 strcmp(argument, "help") {
        usage(cast cstr load64 argv);
        store64 @should_exit 1;
      }
      else {
        store64 + @options Options.filename argument;
      }
      if neq load64 arg NULL {
        store64 @arg + sizeof ptr arg;
      }
    }
    if eq should_exit 0 {
      if neq load64 + @options Options.filename 0 {
        let result = spl_start(cast cstr load64 + @options Options.filename);
      }
      else {
        err("no input file was specified\n");
      }
    }
  }
}
