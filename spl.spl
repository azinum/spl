//
// spl.spl - simple programming language
//
// self hosted implementation of spl in spl
//

struct Options (
  compile         : u64,
  run             : u64,
  debug           : u64,
  filename        : cstr,
  enable_warnings : u64,
  disable_dce     : u64,
  dce_all         : u64,
  verbose         : u64,
  verbose_asm     : u64
);

let options : Options 0;

include "lib/common.spl"
include "src/common.spl"
include "src/misc.spl"
include "src/lexer.spl"
include "src/ast.spl"
include "src/parser.spl"
include "src/ir.spl"
include "src/compile.spl"
include "src/typecheck.spl"

fn usage(prog : cstr) -> none {
  dprintf(STDOUT_FILENO,
"Usage; %s [OPTIONS]\n

OPTIONS:
   <filename>      - path to file
   run             - run program directly
   no-com          - do not compile target executable
   no-debug        - do not write debug information
   enable-warnings - enable basic warnings
   disable-dce     - disable dead code elimination
   dce-all         - eliminate all dead code, including all symbols
   verbose         - enable verbose output
   verbose-asm     - enable verbose assembly code
   help            - show help menu\n"
  , @prog);
}

fn spl_options_init -> none {
  store64 + @options Options.compile 1;
  store64 + @options Options.run 0;
  store64 + @options Options.debug 1;
  store64 + @options Options.filename NULL;
  store64 + @options Options.enable_warnings 0;
  store64 + @options Options.disable_dce 0;
  store64 + @options Options.dce_all 0;
  store64 + @options Options.verbose 0;
  store64 + @options Options.verbose_asm 0;
}

fn exec_command_echoed(fd : u64, command_list : ptr) -> none {
  if load64 + @options Options.verbose {
    let it command_list;
    let done : u64 0;
    printf("[cmd]: ", NULL);
    while eq done 0 {
      if eq load64 it NULL {
        store64 @done 1;
      }
      else {
        printf("%s ", it);
        store64 @it + sizeof cstr it;
      }
    }
    printf("\n", NULL);
  }
  exec_command(command_list);
}

fn spl_start(filename : cstr) -> u64 {
  let result NoError;

  let time_start : timespec 0;
  let time_end : timespec 0;
  { let _ clock_gettime(CLOCK_MONOTONIC, @time_start); }

  let fd open(filename, 0, O_RDONLY);
  if neq fd ERROR {
    let source tmp_it;
    let size read_file_into_buffer_and_null_terminate(fd, source);
    store64 @tmp_it + size tmp_it;
    if eq parser_init(filename, source) NoError {
      ast_push(
        cast ptr load64 + @p Parser.ast,
        parse()
      );
      if and eq load64 + @p Parser.status NoError eq l.status NoError {
        if eq compile_state_init() NoError {
          if eq typecheck_program(cast ptr load64 + @p Parser.ast) NoError {
            if eq ir_start_compile(cast ptr load64 + @p Parser.ast) NoError {
              if load64 + @options Options.compile {
                let path : u8 : MAX_PATH_SIZE cast u8 0;
                memset(@path, 0, sizeof path);
                sprintf(@path, "%s.asm", + @options Options.filename);
                let mode : u64 434; // 0662
                let flags : u64 or or O_CREAT O_TRUNC O_WRONLY;
                let fd : u64 open(cast cstr @path, flags, mode);
                if neq fd ERROR {
                  if eq compile(TARGET_LINUX_NASM_X86_64, fd) NoError {
                    close(fd);
                    { let _ clock_gettime(CLOCK_MONOTONIC, @time_end); }

                    let message cast cstr tmp_it;
                    let args : any (- load64 + @time_end timespec.tv_sec load64 + @time_start timespec.tv_sec, / - load64 + @time_end timespec.tv_nsec load64 + @time_start timespec.tv_nsec TIME_NANOSECONDS_DENOM, load64 + @p Parser.line_count, load64 + @p Parser.source_count);
                    sprintf(cast ptr message, "total compilation time was %d.%d seconds (%d loc, %d file(s))\n", @args);
                    print_info(message);
                  }

                  let exec_path : u8 : MAX_PATH_SIZE cast u8 0;
                  let o_path : u8 : MAX_PATH_SIZE cast u8 0;
                  let filename cast cstr load64 + @options Options.filename;
                  let diff : u64 - cast u64 first_dot(filename) filename;
                  sprintf(@exec_path, "%s", @filename);
                  store8 + @exec_path diff 0; // null terminate
                  let args : any @exec_path;
                  sprintf(@o_path, "%s.o", @args);
                  {
                    let command : cstr (
                      "/usr/bin/nasm",
                      "-f elf64",
                      cast cstr @path,
                      "-o",
                      cast cstr @o_path,
                      cast cstr NULL
                    );
                    exec_command_echoed(STDOUT_FILENO, @command);
                  }
                  {
                    let command : cstr (
                      "/usr/bin/ld",
                      "-arch",
                      "x86_64",
                      cast cstr @o_path,
                      "-o",
                      cast cstr @exec_path,
                      cast cstr NULL
                    );
                    exec_command_echoed(STDOUT_FILENO, @command);
                  }
                  if load64 + @options Options.run {
                    let command : cstr (
                      cast cstr @exec_path,
                      cast cstr NULL
                    );
                    exec_command_echoed(STDOUT_FILENO, @command);
                  }
                }
              }
              if load64 + @options Options.debug {
                let path : u8 : MAX_PATH_SIZE cast u8 0;
                sprintf(@path, "%s.debug", + @options Options.filename);
                let mode : u64 434; // 0662
                let flags : u64 or or O_CREAT O_TRUNC O_WRONLY;
                let debug_fd : u64 open(cast cstr @path, flags, mode);
                if neq debug_fd ERROR {
                  // ast_print(load64 + @p Parser.ast, 0, debug_fd);
                  ir_print(debug_fd);
                  compile_print_symbol_info(debug_fd);
                  close(debug_fd);
                }
                else {
                  // TODO: handle
                }
              }
            }
          }
          compile_state_free();
        }
      }
      else {
        // TODO: handle
      }
      parser_free();
    }
    else {
      // TODO: handle
    }
    close(fd);
  }
  else {
    let message cast cstr tmp_it;
    sprintf(cast ptr tmp_it, "failed to open file `%s`\n", @filename);
    err(message);
  }
  result;
}

fn main(argc : u64, argv : any) -> none {
  common_init();
  ast_init();
  spl_options_init();

  let arg argv;
  let i 0;
  let view_help : u64 0;
  if < argc 2 {
    usage(cast cstr load64 arg);
  }
  else {
    store64 @arg + sizeof ptr arg;
    while neq load64 arg NULL {
      let argument cast cstr load64 arg;
      if eq 0 strcmp(argument, "run") {
        store64 + @options Options.run 1;
      }
      else if eq 0 strcmp(argument, "no-com") {
        store64 + @options Options.compile 0;
      }
      else if eq 0 strcmp(argument, "no-debug") {
        store64 + @options Options.debug 0;
      }
      else if eq 0 strcmp(argument, "enable-warnings") {
        store64 + @options Options.enable_warnings 1;
      }
      else if eq 0 strcmp(argument, "disable-dce") {
        store64 + @options Options.disable_dce 1;
      }
      else if eq 0 strcmp(argument, "dce-all") {
        store64 + @options Options.dce_all 1;
      }
      else if eq 0 strcmp(argument, "verbose") {
        store64 + @options Options.verbose 1;
      }
      else if eq 0 strcmp(argument, "verbose-asm") {
        store64 + @options Options.verbose_asm 1;
      }
      else if eq 0 strcmp(argument, "help") {
        store64 @view_help 1;
      }
      else {
        store64 + @options Options.filename argument;
      }
      store64 @arg + sizeof any arg;
    }
    if view_help {
      usage(cast cstr load64 argv);
    }
    else if neq load64 + @options Options.filename 0 {
      let result spl_start(cast cstr load64 + @options Options.filename);
    }
    else {
      err("no input file was specified\n");
    }
  }
}
