//
// spl.spl - simple programming language
//
// self hosted implementation of spl in spl
//

struct Options (
  compile         : u64,
  run             : u64,
  debug           : u64,
  filename        : cstr,
  enable_warnings : u64,
  disable_dce     : u64,
  dce_all         : u64,
  no_verbose      : u64
);

let options : Options 0;

include "lib/common.spl"
include "common.spl"
include "lexer.spl"
include "ast.spl"
include "parser.spl"
include "ir.spl"
include "compile.spl"
include "typecheck.spl"

fn usage(prog : any) -> none {
  let tmp tmp_it;
  let p tmp_push_cstr;
  p("Usage; ");
  p(prog);
  p(" [OPTIONS]\n\nOPTIONS:\n");
  p("  <filename>      - path to file\n");
  p("  run             - run program directly\n");
  p("  no-com          - do not compile target executable\n");
  p("  no-debug        - do not write debug information\n");
  p("  enable-warnings - enable basic warnings\n");
  p("  disable-dce     - disable dead code elimination\n");
  p("  dce-all         - eliminate all dead code, including all symbols\n");
  p("  no-verbose      - disable verbose output\n");
  putsn(STDOUT_FILENO, tmp, - tmp_it tmp);
  store64 @tmp_it tmp;
}

fn spl_options_init -> none {
  store64 + @options Options.compile 1;
  store64 + @options Options.run 0;
  store64 + @options Options.debug 1;
  store64 + @options Options.filename NULL;
  store64 + @options Options.enable_warnings 0;
  store64 + @options Options.disable_dce 0;
  store64 + @options Options.dce_all 0;
  store64 + @options Options.no_verbose 0;
}

fn spl_start(filename : any) -> u64 {
  let result NoError;

  let time_start : timespec 0;
  let time_end : timespec 0;
  { let _ clock_gettime(CLOCK_MONOTONIC, @time_start); }

  let fd open(filename, 0, O_RDONLY);
  if neq fd ERROR {
    let source tmp_it;
    let size read_file_into_buffer_and_null_terminate(fd, source);
    store64 @tmp_it + size tmp_it;
    if eq parser_init(filename, source) NoError {
      ast_push(
        cast ptr load64 + @p Parser.ast,
        parse()
      );
      if and eq load64 + @p Parser.status NoError eq l.status NoError {
        // ast_print(load64 + @p Parser.ast, 0, STDOUT_FILENO);
        if eq compile_state_init() NoError {
          if eq typecheck_program(cast ptr load64 + @p Parser.ast) NoError {
            if eq ir_start_compile(cast ptr load64 + @p Parser.ast) NoError {
              if load64 + @options Options.compile {
                if eq compile(TARGET_LINUX_NASM_X86_64, STDOUT_FILENO) NoError {
                  { let _ clock_gettime(CLOCK_MONOTONIC, @time_end); }

                  let message cast cstr tmp_it;
                  tmp_push_cstr("total compilation time was ");
                  tmp_push_u64(- load64 + @time_end timespec.tv_sec load64 + @time_start timespec.tv_sec);
                  tmp_push_cstr(".");
                  tmp_push_u64(/ - load64 + @time_end timespec.tv_nsec load64 + @time_start timespec.tv_nsec TIME_NANOSECONDS_DENOM);
                  tmp_push_cstr(" seconds (");
                  tmp_push_u64(load64 + @p Parser.line_count);
                  tmp_push_cstr(" loc, ");
                  tmp_push_u64(load64 + @p Parser.source_count);
                  tmp_push_cstr(" file(s))\n");
                  tmp_push_byte(0);
                  print_info(message);
                  store64 @tmp_it message;

                  // compile_print_symbol_info(STDOUT_FILENO);
                }
              }
              if load64 + @options Options.debug {
                // TODO: implement
                ir_print(STDOUT_FILENO);
              }
            }
          }
          compile_state_free();
        }
      }
      else {
        // TODO: handle
      }
      parser_free();
    }
    else {
      // TODO: handle
    }
    close(fd);
  }
  else {
    let message tmp_it;
    tmp_push_cstr("failed to open file `");
    tmp_push_cstr(filename);
    tmp_push_cstr("`\n");
    tmp_push_byte(0);
    err(message);
    store64 @tmp_it message;
  }
  result;
}

fn main(argc : u64, argv : any) -> none {
  common_init();
  ast_init();
  spl_options_init();

  let arg argv;
  let i 0;
  if < argc 2 {
    usage(#arg);
  }
  else {
    store64 @arg + sizeof any arg;
    while neq load64 arg NULL {
      let argument cast cstr load64 arg;
      if eq 0 strcmp(argument, "run") {
        store64 + @options Options.run 1;
      }
      else if eq 0 strcmp(argument, "no-com") {
        store64 + @options Options.compile 0;
      }
      else if eq 0 strcmp(argument, "no-debug") {
        store64 + @options Options.debug 0;
      }
      else if eq 0 strcmp(argument, "enable-warnings") {
        store64 + @options Options.enable_warnings 1;
      }
      else if eq 0 strcmp(argument, "disable-dce") {
        store64 + @options Options.disable_dce 1;
      }
      else if eq 0 strcmp(argument, "dce-all") {
        store64 + @options Options.dce_all 1;
      }
      else if eq 0 strcmp(argument, "no-verbose") {
        store64 + @options Options.no_verbose 1;
      }
      else {
        store64 + @options Options.filename argument;
      }
      store64 @arg + sizeof any arg;
    }
    if neq load64 + @options Options.filename 0 {
      let result spl_start(load64 + @options Options.filename);
    }
    else {
      err("no input file was specified\n");
    }
  }
}
