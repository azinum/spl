// typecheck.spl

fn typecheck_function(block : ptr, fs : ptr, ast : ptr) -> u64 0;
let typecheck.typecheck typecheck_function;

fn typecheck_print_unused -> none {
  if not load64 + @options Options.disable_dce {
    let i MAX_SYSCALL_FUNCTION;
    let count load64 + @c Compile.symbol_count;
    while < i count {
      let symbol : Symbol 0;
      memcpy(@symbol, + + @c Compile.symbols * sizeof Symbol i, sizeof Symbol);
      let ref_count load64 + @symbol Symbol.ref_count;
      let sym_type load64 + @symbol Symbol.sym_type;
      if and eq ref_count 0 or eq sym_type SYM_FUNC load64 + @options Options.dce_all {
        ir_compile_warning_at(+ @symbol Symbol.token, "`?` defined but not used\n");
      }
      store64 @i + 1 i;
    }
  }
}

fn typecheck_error(message : cstr) -> none {
  if eq load64 + @c Compile.status NoError {
    let tmp cast cstr tmp_it;
    tmp_push_cstr("[typecheck-error]: ");
    tmp_push_cstr(message);
    putsn(STDERR_FILENO, tmp, - tmp_it tmp);
    store64 @tmp_it tmp;
    store64 + @c Compile.status Error;
  }
}

// token : Token*
fn typecheck_error_at(token : ptr, message : cstr) -> none {
  if eq load64 + @c Compile.status NoError {
    let tmp cast cstr tmp_it;
    tmp_push_cstr("[typecheck-error]: ");
    tmp_push_cstr(cast cstr load64 + token Token.filename);
    tmp_push_cstr(":");
    tmp_push_u64(load64 + token Token.line);
    tmp_push_cstr(":");
    tmp_push_u64(load64 + token Token.column);
    tmp_push_cstr(": ");
    tmp_push_cstr(message);
    putsn(STDERR_FILENO, tmp, - tmp_it tmp);
    store64 @tmp_it tmp;
    store64 + @c Compile.status Error;
  }
}

fn typecheck_print_stack(fd : u64) -> none {
  let i 0;
  let count load64 + @c Compile.ts_count;
  while < i count {
    let type : u64 load64 + + @c Compile.ts * sizeof u64 i;
    let value : Value 0;
    memcpy(@value, + + @c Compile.vs * sizeof Value i, sizeof Value);
    let message cast cstr tmp_it;
    tmp_push_u64(i);
    tmp_push_cstr(": `");
    tmp_push_cstr(cast cstr load64 + @compile_type_str * sizeof cstr type);
    tmp_push_cstr("`, ");
    tmp_push_u64(load64 + @value Value.num);
    tmp_push_cstr("\n");
    tmp_push_byte(cast u8 0);
    puts(fd, message);
    store64 @tmp_it message;
    store64 @i + 1 i;
  }
}

fn ts_push(type : u64) -> u64 {
  let result : u64 TypeNone;
  if < load64 + @c Compile.ts_count MAX_TYPE_STACK {
    store64 + + @c Compile.ts * sizeof result load64 + @c Compile.ts_count type;
    store64 + @c Compile.ts_count + 1 load64 + @c Compile.ts_count;
    store64 @result type;
  }
  else {
    assert(0, "type stack overflow\n");
  }
  result;
}

fn ts_pop -> u64 {
  let result TypeNone;
  if < load64 + @c Compile.ts_count MAX_TYPE_STACK {
    store64 + @c Compile.ts_count - load64 + @c Compile.ts_count 1;
    store64 @result load64 + + @c Compile.ts * sizeof u64 load64 + @c Compile.ts_count;
  }
  else {
    assert(0, "type stack underflow\n");
  }
  result;
}

fn ts_top -> u64 {
  let result TypeNone;
  if < load64 + @c Compile.ts_count MAX_TYPE_STACK {
    store64 @result load64 + + @c Compile.ts * sizeof u64 - load64 + @c Compile.ts_count 1;
  }
  result;
}

// value : Value*
fn vs_push(value : ptr) -> u64 {
  let result NoError;
  if < load64 + @c Compile.vs_count MAX_TYPE_STACK {
    memcpy(+ + @c Compile.vs * sizeof Value load64 + @c Compile.vs_count, value, sizeof Value);
    store64 + @c Compile.vs_count + 1 load64 + @c Compile.vs_count;
  }
  else {
    assert(0, "value stack overflow\n");
    store64 @result Error;
  }
  result;
}

fn vs_top(value_out : ptr) -> none {
  if < load64 + @c Compile.vs_count MAX_TYPE_STACK {
    if cast u64 value_out {
      memcpy(value_out, + + @c Compile.vs * sizeof Value - load64 + @c Compile.vs_count 1, sizeof Value);
    }
  }
  else {
    if cast u64 value_out {
      store64 @value_out NULL;
    }
  }
}

fn vs_pop(value_out : ptr) -> u64 {
  let result NoError;
  if < load64 + @c Compile.vs_count MAX_TYPE_STACK {
    if cast u64 value_out {
      vs_top(value_out);
    }
    store64 + @c Compile.vs_count - load64 + @c Compile.vs_count 1;
  }
  else {
    assert(0, "value stack underflow\n");
    store64 @result Error;
  }
  result;
}

fn check_func_signatures(a : ptr, b : ptr) -> u64 {
  let result 1;
  if and
    eq load64 + a Function.argc load64 + b Function.argc
    eq load64 + a Function.rtype load64 + b Function.rtype {

    let i 0;
    let argc load64 + a Function.argc;
    while < i argc {
      // TODO(lucas): not sure if this works, testing needs to be done. indexing like this is tough man...
      let arg_a : u64 load64 + + a Function.argc * sizeof u64 i;
      let arg_b : u64 load64 + + b Function.argc * sizeof u64 i;
      let type_a : u64 load64 + + + @c Compile.symbols * sizeof Symbol arg_a Symbol.type;
      let type_b : u64 load64 + + + @c Compile.symbols * sizeof Symbol arg_b Symbol.type;
      if neq type_a type_b {
        store64 @result 0;
        store64 @i argc; // break out of the loop
      }
      store64 @i + 1 i;
    }
  }
  else {
    store64 @result 0;
  }

  result;
}

// ast : Ast*
fn is_branch_konst_eval(ast : ptr) -> u64 {
  let konst 1;
  let i 0;
  let count load64 + ast Ast.count;
  while < i count {
    let node cast ptr load64 + + ast Ast.node * sizeof ptr i;
    if eq load64 + node Ast.konst 0 {
      store64 @konst 0;
      store64 @i count;
    }
    store64 @i + 1 i;
  }
  konst;
}

fn is_numerical(type : u64) -> u64 {
  or or or
    eq type TypeUnsigned64
    eq type TypeUnsigned32
    eq type TypeUnsigned16
    eq type TypeUnsigned8;
}

// block : Block*, fs : Function*, token : Token*, symbol_out : Symbol**
fn token_to_compile_type(block : ptr, fs : ptr, token : ptr, symbol_out : ptr) -> u64 {
  let result TypeNone;
  let type load64 + token Token.type;
  if eq type T_ANY {
    store64 @result TypeAny;
  }
  else if eq type T_PTR {
    store64 @result TypePtr;
  }
  else if eq type T_UNSIGNED64 {
    store64 @result TypeUnsigned64;
  }
  else if eq type T_UNSIGNED32 {
    store64 @result TypeUnsigned32;
  }
  else if eq type T_UNSIGNED16 {
    store64 @result TypeUnsigned16;
  }
  else if eq type T_UNSIGNED8 {
    store64 @result TypeUnsigned8;
  }
  else if or eq type T_CSTRING eq type T_CSTR {
    store64 @result TypeCString;
  }
  else if eq type T_IDENTIFIER {
    let symbol NULL;
    let buffer : Buffer 0;
    buffer_init(@buffer, cast ptr load64 + token Token.buffer, load64 + token Token.length);
    if eq compile_lookup_value(block, fs, @buffer, @symbol, NULL, NULL) NoError {
      if neq cast u64 symbol_out NULL {
        store64 symbol_out symbol;
      }
      store64 @result load64 + symbol Symbol.type;
    }
  }
  result;
}

fn typecheck_node_list(block : ptr, fs : ptr, ast : ptr) -> u64 {
  let i 0;
  let count load64 + ast Ast.count;
  while < i count {
    let _ typecheck.typecheck(block, fs, cast ptr load64 + + ast Ast.node * sizeof ptr i);
    store64 @i + 1 i;
  }
  NoError;
}

fn typecheck_let_statement(block : ptr, fs : ptr, ast : ptr) -> u64 {
  let result NoError;
  let konst eq load64 + ast Ast.type AstConstStatement;
  let ts_count load64 + @c Compile.ts_count;
  let num_elements 1;
  let rhs cast ptr load64 + + ast Ast.node * sizeof ptr 0;
  let ast_type NULL;
  if eq load64 + ast Ast.count 2 {
    store64 @ast_type cast ptr load64 + + ast Ast.node * sizeof ptr 1;
  }

  // typecheck the rhs of the statement
  { let _ typecheck_node_list(block, fs, rhs); }
  store64 + rhs Ast.konst is_branch_konst_eval(rhs);
  store64 + ast Ast.konst is_branch_konst_eval(rhs);

  // make sure that rhs actually produced any values
  let ts_delta - load64 + @c Compile.ts_count ts_count;
  if eq ts_delta 0 {
    typecheck_error_at(+ ast Ast.token, "no value was produced in the rhs of the let statement\n");
  }
  else {
    let expl_type_symbol NULL;

    // typecheck explicit type, if there is one
    let explicit_type TypeNone;
    if neq cast u64 ast_type NULL {
      store64 @explicit_type token_to_compile_type(block, fs, + ast_type Ast.token, @expl_type_symbol);
      let token : Token 0;
      memcpy(@token, + ast_type Ast.token, sizeof Token);
      if eq explicit_type TypeNone {
        let message tmp_it;
        tmp_push_cstr("type `");
        tmp_push_str(load64 + @token Token.buffer, load64 + @token Token.length);
        tmp_push_cstr("` not defined\n");
        tmp_push_byte(cast u8 0);
        typecheck_error_at(@token, cast cstr message);
        store64 @tmp_it message;
      }
      else {
        // array size specifier
        if > load64 + ast_type Ast.count 0 {
          { let _ typecheck.typecheck(block, fs, ast_type); }
          let value : Value 0;
          { let _ vs_pop(@value); }
          let array_specifier_type ts_pop();
          if eq is_numerical(array_specifier_type) 0 {
            typecheck_error_at(cast ptr + load64 + ast_type Ast.node Ast.token, "only numeric values are allowed in array size specifier\n");
          }
          else {
            store64 @num_elements load64 + @value Value.num;
            if > ts_delta num_elements {
              typecheck_error_at(cast ptr + load64 + ast_type Ast.node Ast.token, "number of elements in rhs exceeded the array size specifier\n");
            }
          }
        }
      }
    }

    let imm UINT64_MAX; // index to immediate value, in case this is a constant

    let value : Value 0;
    let prev_value : Value 0;
    vs_top(@value);
    vs_top(@prev_value);

    let type ts_top();
    let prev_type ts_top();

    if neq explicit_type TypeNone {
      store64 @prev_type explicit_type;
    }

    if and eq konst 1 eq is_numerical(type) 0 {
      typecheck_error_at(+ ast Ast.token, "only numeric values are allowed in constants\n");
    }
    else {
      let i 0;
      let done 0;
      while and not done < i ts_delta {
        store64 @type ts_pop();
        if and and neq type prev_type neq explicit_type TypeAny neq explicit_type TypeStruct {
          typecheck_error_at(+ ast Ast.token, "incompatable type in expression list\n");
          store64 @done 1;
        }
        else {
          store64 @prev_type type;
          { let _ vs_pop(@value); }
          if and eq type TypeFunc neq type TypeAny {
            if eq check_func_signatures(+ @value Value.func, + @prev_value Value.func) 0 {
              typecheck_error_at(+ ast Ast.token, "incompatible type in expression list\n");
              store64 @done 1;
            }
          }
        }
        memcpy(@prev_value, @value, sizeof Value);
        if eq konst 1 {
          store64 @imm ir_push_value(+ @value Value.num, sizeof u64);
        }
        store64 @i + 1 i;
      }
    }

    // no array specifier was used, therefore num_elements is set to however many elements there was in the rhs
    if eq num_elements 1 {
      store64 @num_elements ts_delta;
    }

    if neq explicit_type TypeNone {
      store64 @type explicit_type;
    }

    // if this is a constant, make sure to update the immediate value index
    if eq konst 1 {
      let decrement * - ts_delta 1 load64 + @compile_type_size * sizeof u64 TypeUnsigned64;
      store64 @imm - imm decrement;
    }

    let type_size : u64 load64 + @compile_type_size * sizeof u64 type;
    if and eq type TypeStruct neq expl_type_symbol NULL {
      store64 @type_size load64 + expl_type_symbol Symbol.size;
    }

    let symbol : ptr NULL;
    let symbol_index UINT64_MAX;
    if eq compile_declare_value(block, fs, + ast Ast.token, @symbol, @symbol_index) NoError {
      store64 + symbol Symbol.imm imm;
      store64 + symbol Symbol.size * num_elements type_size;
      store64 + symbol Symbol.num_elements_init ts_delta;
      store64 + symbol Symbol.konst konst;
      if eq cast u64 block + @c Compile.global {
        store64 + symbol Symbol.sym_type SYM_GLOBAL_VAR;
      }
      else {
        store64 + symbol Symbol.sym_type SYM_LOCAL_VAR;
      }
      store64 + symbol Symbol.type type;
      memcpy(+ symbol Symbol.value, @value, sizeof Value);
      store64 + + symbol Symbol.token Token.v symbol_index;
      store64 + + ast Ast.token Token.v symbol_index;
      store64 @result type;
    }
  }
  result;
}

fn typecheck(block : ptr, fs : ptr, ast : ptr) -> u64 {
  if eq load64 + @c Compile.status NoError {
    let type load64 + ast Ast.type;
    if eq type AstValue {
      let token_type load64 + + ast Ast.token Token.type;
      if eq token_type T_NUMBER {
        let value : Value 0;
        store64 + @value Value.num load64 + + ast Ast.token Token.v;
        store64 + @value Value.konst 1;
        store64 + ast Ast.konst 1;
        { let _ vs_push(@value); }
        { let _ ts_push(TypeUnsigned64); }
      }
      else if eq token_type T_CSTRING {
        let value : Value 0;
        memset(@value, 0, sizeof Value);
        { let _ vs_push(@value); }
        { let _ ts_push(TypeCString); }
      }
      else if eq token_type T_IDENTIFIER {
        let symbol : ptr NULL;
        let symbol_index UINT64_MAX;
        let token_buffer : Buffer 0;
        buffer_init(cast ptr @token_buffer, cast ptr load64 + + ast Ast.token Token.buffer, load64 + + ast Ast.token Token.length);

        if eq compile_lookup_value(block, fs, @token_buffer, @symbol, @symbol_index, NULL) NoError {
          store64 + symbol Symbol.ref_count + 1 load64 + symbol Symbol.ref_count;
          store64 + + ast Ast.token Token.v symbol_index;
          { let _ vs_push(+ symbol Symbol.value); }
          store64 + ast Ast.konst load64 + + symbol Symbol.value Value.konst;
          { let _ ts_push(load64 + symbol Symbol.type); }
        }
        else {
          let message tmp_it;
          tmp_push_cstr("symbol `");
          tmp_push_str(load64 + + ast Ast.token Token.buffer, load64 + + ast Ast.token Token.length);
          tmp_push_cstr("` not defined\n");
          tmp_push_byte(cast u8 0);
          compile_error_at(+ ast Ast.token, cast cstr message);
          store64 @tmp_it message;
        }
      }
      else if eq token_type T_AT {
        let symbol : ptr NULL;
        let symbol_index UINT64_MAX;
        let token_buffer : Buffer 0;
        buffer_init(cast ptr @token_buffer, cast ptr load64 + + ast Ast.token Token.buffer, load64 + + ast Ast.token Token.length);
        if eq compile_lookup_value(block, fs, @token_buffer, @symbol, @symbol_index, NULL) NoError {
          store64 + symbol Symbol.ref_count + 1 load64 + symbol Symbol.ref_count;
          store64 + + ast Ast.token Token.v symbol_index;
          let symbol_type load64 + symbol Symbol.type;
          if eq symbol_type TypeNone {
            let message cast cstr tmp_it;
            tmp_push_cstr("can not take the address of the type `");
            tmp_push_cstr(cast cstr load64 + @compile_type_str * sizeof cstr symbol_type);
            tmp_push_cstr("`\n");
            tmp_push_byte(cast u8 0);
            typecheck_error_at(+ ast Ast.token, cast cstr message);
            store64 @tmp_it message;
          }
          else {
            { let _ vs_push(+ symbol Symbol.value); }
            { let _ ts_push(TypePtr); }
          }
        }
        else {
          let message tmp_it;
          tmp_push_cstr("symbol `");
          tmp_push_str(load64 + + ast Ast.token Token.buffer, load64 + + ast Ast.token Token.length);
          tmp_push_cstr("` not defined\n");
          tmp_push_byte(cast u8 0);
          compile_error_at(+ ast Ast.token, cast cstr message);
          store64 @tmp_it message;
        }
      }
      else {
        assert(0, "invalid token type\n");
      }
    }
    else if eq type AstExpression {
      { let _ typecheck(block, fs, cast ptr load64 + + ast Ast.node * sizeof ptr 0); }
      let konst is_branch_konst_eval(ast);
      store64 + ast Ast.konst konst;
    }
    else if or or eq type AstExprList eq type AstStatement eq type AstStatementList {
      let _ typecheck_node_list(block, fs, ast);
      let konst is_branch_konst_eval(ast);
      store64 + ast Ast.konst konst;
    }
    else if eq type AstBinopExpression {
      { let _ typecheck_node_list(block, fs, ast); }
      let b ts_pop();
      let a ts_pop();
      if and
        or or or is_numerical(a) eq a TypeAny eq a TypePtr eq a TypeCString
        or or or is_numerical(b) eq b TypeAny eq b TypePtr eq b TypeCString {
        let va : Value 0;
        let vb : Value 0;
        { let _ vs_pop(@vb); }
        { let _ vs_pop(@va); }
        store64 + ast Ast.konst and load64 + @va Value.konst load64 + @vb Value.konst;

        let num : u64 0;
        let token_type load64 + + ast Ast.token Token.type;
        if eq token_type T_ADD {
          store64 @num + load64 + @va Value.num load64 + @vb Value.num;
        }
        else if eq token_type T_SUB {
          store64 @num - load64 + @va Value.num load64 + @vb Value.num;
        }
        else if eq token_type T_MUL {
          store64 @num * load64 + @va Value.num load64 + @vb Value.num;
        }
        else if eq token_type T_DIV {
          if eq load64 + @vb Value.konst 1 {
            if eq load64 + @vb Value.num 0 {
              typecheck_error("divide by zero arithmetic error\n");
            }
            else {
              store64 @num / load64 + @va Value.num load64 + @vb Value.num;
            }
          }
        }
        else if eq token_type T_DIVMOD {
          if eq load64 + @vb Value.konst 1 {
            if eq load64 + @vb Value.num 0 {
              typecheck_error("modulo by zero arithmetic error\n");
            }
            else {
              store64 @num % load64 + @va Value.num load64 + @vb Value.num;
            }
          }
        }
        else if eq token_type T_LSHIFT {
          assert(0, "T_LSHIFT: not implemented yet\n");
        }
        else if eq token_type T_RSHIFT {
          assert(0, "T_RSHIFT: not implemented yet\n");
        }
        else if eq token_type T_LT {
          store64 @num < load64 + @va Value.num load64 + @vb Value.num;
        }
        else if eq token_type T_GT {
          store64 @num > load64 + @va Value.num load64 + @vb Value.num;
        }
        else if eq token_type T_AND {
          store64 @num and load64 + @va Value.num load64 + @vb Value.num;
        }
        else if eq token_type T_OR {
          store64 @num or load64 + @va Value.num load64 + @vb Value.num;
        }
        else if eq token_type T_EQ {
          store64 @num eq load64 + @va Value.num load64 + @vb Value.num;
        }
        else if eq token_type T_NEQ {
          store64 @num neq load64 + @va Value.num load64 + @vb Value.num;
        }
        else {
          assert(0, "unhandled operator\n");
        }
        let value : Value 0;
        store64 + @value Value.num num;
        store64 + @value Value.konst load64 + ast Ast.konst;
        { let _ vs_push(@value); }
        { let _ ts_push(a); }
      }
      else {
        typecheck_error("type mismatch in binary operator expression\n");
      }
    }
    else if eq type AstUopExpression {
      let ts_count : u64 load64 + @c Compile.ts_count;
      { let _ typecheck_node_list(block, fs, ast); }
      store64 + ast Ast.konst is_branch_konst_eval(ast);
      let ts_delta : u64 - load64 + @c Compile.ts_count ts_count;
      if neq ts_delta 0 {
        let token_type load64 + + ast Ast.token Token.type;
        if eq token_type T_PRINT {
          { let _ vs_pop(NULL); }
          { let _ ts_pop(); }
        }
        else if or or or or
          eq token_type T_DEREF
          eq token_type T_LOAD64
          eq token_type T_LOAD32
          eq token_type T_LOAD16
          eq token_type T_LOAD8 {
          { let _ ts_pop(); }
          { let _ ts_push(TypeUnsigned64); }
        }
        else if eq token_type T_LOGICAL_NOT {
          let value : Value 0;
          { let _ vs_pop(@value); }
          store64 + @value Value.num not load64 + @value Value.num;
          { let _ vs_push(@value); }
        }
      }
      else {
        typecheck_error("no value was produced in the rhs of the unary expression\n");
      }
    }
    else if or eq type AstLetStatement eq type AstConstStatement {
      { let _ typecheck_let_statement(block, fs, ast); }
    }
    else if eq type AstBlockStatement {
      let local_block : Block 0;
      block_init(@local_block, block);
      { let _ typecheck_node_list(@local_block, fs, ast); }
      store64 + ast Ast.konst is_branch_konst_eval(ast);
    }
    else if eq type AstFuncDefinition {
      let params cast ptr load64 + + ast Ast.node * sizeof ptr 0;
      let body   cast ptr load64 + + ast Ast.node * sizeof ptr 1;
      let rtype_node : ptr NULL;
      if eq load64 + ast Ast.count 3 {
        store64 @rtype_node load64 + + ast Ast.node * sizeof ptr 2;
      }

      let argc : u64 load64 + params Ast.count;
      if or eq argc MAX_FUNC_ARGC < argc MAX_FUNC_ARGC { // argc <= MAX_FUNC_ARGC
        let symbol : ptr NULL;
        let symbol_index : u64 UINT64_MAX;
        if eq compile_declare_value(block, fs, + ast Ast.token, @symbol, @symbol_index) NoError {
          let local_block : Block 0;
          block_init(@local_block, block);

          store64 + symbol Symbol.imm UINT64_MAX;
          store64 + symbol Symbol.size load64 + @compile_type_size * sizeof u64 TypeFunc;
          store64 + symbol Symbol.konst 0;
          store64 + symbol Symbol.sym_type SYM_FUNC;
          store64 + symbol Symbol.type TypeFunc;
          store64 + + ast Ast.token Token.v symbol_index;
          memcpy(+ symbol Symbol.token, + ast Ast.token, sizeof Token);
          let func cast ptr + + symbol Symbol.value Value.func;
          store64 + func Function.ir_address UINT64_MAX;
          store64 + func Function.label symbol_index;
          store64 + func Function.argc load64 + params Ast.count;
          store64 + func Function.locals_offset_counter 0;
          store64 + func Function.rtype TypeNone;

          if neq cast u64 rtype_node NULL {
            store64 + func Function.rtype token_to_compile_type(block, fs, + rtype_node Ast.token, NULL);
          }

          let i : u64 0;
          let fail : u64 0;
          while and eq fail 0 < i argc {
            let arg_node cast ptr load64 + + params Ast.node * sizeof ptr i;
            let arg : Token 0;
            let arg_type : Token 0;
            memcpy(@arg, + arg_node Ast.token, sizeof Token);
            memcpy(@arg_type, + load64 + + arg_node Ast.node * sizeof ptr 0 Ast.token, sizeof Token);

            let arg_symbol : ptr NULL;
            let arg_symbol_index : u64 UINT64_MAX;
            if eq compile_declare_value(@local_block, func, @arg, @arg_symbol, @arg_symbol_index) NoError {
              store64 + + func Function.args * sizeof u64 i arg_symbol_index;
              let arg_compile_type : u64 token_to_compile_type(block, fs, @arg_type, NULL);
              if and
                  neq arg_compile_type TypeNone
                  neq arg_compile_type TypeStruct {

                store64 + arg_symbol Symbol.imm UINT64_MAX;
                store64 + arg_symbol Symbol.size load64 + @compile_type_size * sizeof u64 arg_compile_type;
                store64 + arg_symbol Symbol.konst 0;
                store64 + arg_symbol Symbol.sym_type SYM_FUNC_ARG;
                store64 + arg_symbol Symbol.type arg_compile_type;
                memcpy(+ arg_symbol Symbol.token, @arg, sizeof Token);
                store64 + + arg_symbol Symbol.token Token.v i; // TODO(lucas): store argument index in symbol value field instead
              }
              else {
                compile_error_at(@arg_type, "invalid type in function parameter list\n");
                store64 @fail 1;
              }
            }
            else {
              compile_error_at(@arg, "duplicate argument name\n");
              store64 @fail 1;
            }

            store64 @i + 1 i;
          }

          let ts_count : u64 load64 + @c Compile.ts_count;
          let func_body_block : Block 0;
          block_init(@func_body_block, @local_block); // to allow for shadowing of function arguments

          { let _ typecheck_node_list(@func_body_block, fs, body); }
          let konst_body : u64 is_branch_konst_eval(body);
          store64 + body Ast.konst konst_body;
          store64 + ast Ast.konst konst_body;
          store64 + + symbol Symbol.value Value.konst konst_body;

          let rtype : u64 TypeNone;
          let ts_delta : u64 - load64 + @c Compile.ts_count ts_count;
          if > ts_delta 1 {
            typecheck_error_at(+ ast Ast.token, "too many values produced by function\n");
          }
          else {
            if neq ts_delta 0 {
              { let _ vs_pop(NULL); }
              store64 @rtype ts_pop();
            }

            if neq cast u64 rtype_node NULL {
              let explicit_rtype : u64 token_to_compile_type(block, fs, + rtype_node Ast.token, NULL);
              if and neq explicit_rtype rtype neq explicit_rtype TypeAny {
                compile_error_at(+ rtype_node Ast.token, "function returns a value that does not match the return type\n");
              }
            }
            else {
              store64 + func Function.rtype rtype;
            }

            if eq strncmp(cast cstr + symbol Symbol.name, "main", MAX_NAME_SIZE) 0 {
              store64 + symbol Symbol.ref_count + load64 + symbol Symbol.ref_count 1;
              store64 + @c Compile.entry_point + load64 + @c Compile.entry_point 1;
            }
          }
        }
        else {
          compile_error_at(+ ast Ast.token, "symbol already exists\n");
        }
      }
      else {
        let message cast cstr tmp_it;
        tmp_push_cstr("reached function parameter count limit of ");
        tmp_push_u64(MAX_FUNC_ARGC);
        tmp_push_cstr("\n");
        tmp_push_byte(cast u8 0);
        compile_error_at(+ ast Ast.token, message);
        store64 @tmp_it message;
      }
    }
    else if eq type AstFuncCall {
      let symbol : ptr NULL;
      let symbol_index : u64 UINT64_MAX;
      let token_buffer : Buffer 0;
      buffer_init(cast ptr @token_buffer, cast ptr load64 + + ast Ast.token Token.buffer, load64 + + ast Ast.token Token.length);
      if eq compile_lookup_value(block, fs, @token_buffer, @symbol, @symbol_index, NULL) NoError {
        store64 + symbol Symbol.ref_count + 1 load64 + symbol Symbol.ref_count;
        store64 + + ast Ast.token Token.v symbol_index;
        let arg_list cast ptr load64 + + ast Ast.node * sizeof ptr 0;
        let func : ptr + + symbol Symbol.value Value.func;
        if neq load64 + symbol Symbol.type TypeAny {
          if eq load64 + func Function.argc load64 + arg_list Ast.count {
            store64 + + symbol Symbol.token Token.v symbol_index; // TODO(lucas): store this in the symbol value field
            let done : u64 0;
            let argc : u64 load64 + func Function.argc;
            let i : u64 - argc 1;
            if > argc 0 {
              while eq done 0 {
                let node cast ptr load64 + + arg_list Ast.node * sizeof ptr i;
                { let _ typecheck(block, fs, node); }
                let arg_type : u64 ts_top();

                if eq load64 + symbol Symbol.type TypeSyscallFunc {
                  // any type is allowed here
                  // we still want to type check the arguments of the call
                  // which is why this is here instead of outside the loop
                }
                else {
                  // Symbol* arg = &c->symbols[func->args[i]];
                  let arg_symbol_index : u64 load64 + + func Function.args * sizeof u64 i;
                  let arg cast ptr + + @c Compile.symbols * sizeof Symbol arg_symbol_index;
                  if and
                      neq load64 + arg Symbol.type arg_type
                      neq load64 + arg Symbol.type TypeAny {
                    let message cast cstr tmp_it;
                    tmp_push_cstr("type mismatch in function call, got `");
                    tmp_push_cstr(cast cstr load64 + @compile_type_str * sizeof cstr arg_type);
                    tmp_push_cstr("`, but `");
                    tmp_push_cstr(cast cstr load64 + @compile_type_str * sizeof cstr load64 + arg Symbol.type);
                    tmp_push_cstr("` was expected\n");
                    tmp_push_byte(cast u8 0);
                    typecheck_error_at(+ ast Ast.token, message);
                    store64 + @c Compile.status NoError; // to print additional error message
                    store64 @tmp_it message;

                    tmp_push_cstr("from function `");
                    tmp_push_cstr(cast cstr + symbol Symbol.name);
                    tmp_push_cstr("`\n");
                    tmp_push_byte(cast u8 0);
                    typecheck_error_at(+ ast Ast.token, message);
                    store64 @tmp_it message;
                    store64 @done 1;
                  }
                }
                { let _ vs_pop(NULL); }
                { let _ ts_pop(); }
                if eq i 0 {
                  store64 @done 1;
                }
                else {
                  store64 @i - i 1;
                }
              }
            }

            if neq load64 + func Function.rtype TypeNone {
              store64 + + symbol Symbol.value Value.konst 0;  // NOTE(lucas): temporary (why?)
              store64 + ast Ast.konst load64 + + symbol Symbol.value Value.konst;
              { let _ ts_push(load64 + func Function.rtype); }
              { let _ vs_push(+ symbol Symbol.value); }
            }
          }
          else {
            let message cast cstr tmp_it;
            tmp_push_cstr("function `");
            tmp_push_cstr(cast cstr + symbol Symbol.name);
            tmp_push_cstr("` takes ");
            tmp_push_u64(load64 + func Function.argc);
            tmp_push_cstr(" argument(s), but ");
            tmp_push_u64(load64 + arg_list Ast.count);
            tmp_push_cstr(" was given\n");
            compile_error_at(+ ast Ast.token, message);
            store64 @tmp_it message;
          }
        }
        else {
          let message cast cstr tmp_it;
          tmp_push_cstr("function calls of type `");
          tmp_push_cstr(cast cstr load64 + @compile_type_str * sizeof cstr load64 + symbol Symbol.type);
          tmp_push_cstr("` is not permitted\n");
          typecheck_error_at(+ ast Ast.token, message);
          store64 @tmp_it message;
        }
      }
      else {
        let message tmp_it;
        tmp_push_cstr("symbol `");
        tmp_push_str(cast cstr load64 + @token_buffer Buffer.data, load64 + @token_buffer Buffer.length);
        tmp_push_cstr("` not defined\n");
        tmp_push_byte(cast u8 0);
        compile_error_at(+ ast Ast.token, cast cstr message);
        store64 @tmp_it message;
      }
    }
    else if eq type AstWhileStatement {
      let cond cast ptr load64 + + ast Ast.node * sizeof ptr 0;
      let body cast ptr load64 + + ast Ast.node * sizeof ptr 1;
      { let _ typecheck(block, fs, cond); }
      let type ts_pop(); // pop condition result
      { let _ vs_pop(NULL); } // pop condition result
      if is_numerical(type) {
        let local_block : Block 0;
        block_init(@local_block, block);
        { let _ typecheck(@local_block, fs, body); }
        store64 + ast Ast.konst is_branch_konst_eval(ast);
      }
      else {
        typecheck_error("invalid type in while statement condition\n");
      }
    }
    else if eq type AstIfStatement {
      let cond cast ptr load64 + + ast Ast.node * sizeof ptr 0;
      let body cast ptr load64 + + ast Ast.node * sizeof ptr 1;
      { let _ typecheck(block, fs, cond); }
      let type ts_pop(); // pop condition result type
      { let _ vs_pop(NULL); } // pop condition result value
      if is_numerical(type) {
        let local_block : Block 0;
        block_init(@local_block, block);
        { let _ typecheck(@local_block, fs, body); }
        if eq load64 + ast Ast.count 3 {
          let else_body cast ptr load64 + + ast Ast.node * sizeof ptr 2;
          let local_block : Block 0;
          block_init(@local_block, block);
        { let _ typecheck(@local_block, fs, else_body); }
        }
        store64 + ast Ast.konst is_branch_konst_eval(ast);
      }
      else {
        typecheck_error("invalid type in if statement condition\n");
      }
    }
    else if eq type AstMemoryStatement {
      let symbol : ptr NULL;
      let symbol_index : u64 UINT64_MAX;
      let node cast ptr load64 + + ast Ast.node * sizeof ptr 0;
      let type : u64 typecheck(block, fs, node);
      if is_numerical(type) {
        { let _ ts_pop(); }
        let value : Value 0;
        { let _ vs_pop(@value); }

        if eq compile_declare_value(block, fs, + ast Ast.token, @symbol, @symbol_index) NoError {
          store64 + symbol Symbol.imm UINT64_MAX;
          store64 + symbol Symbol.size load64 + @value Value.num;
          store64 + symbol Symbol.konst 0;
          store64 + symbol Symbol.sym_type SYM_GLOBAL_VAR;
          store64 + symbol Symbol.type TypeUnsigned8;
          memcpy(+ symbol Symbol.value, @value, sizeof Value);
          store64 + + symbol Symbol.token Token.v symbol_index;
          store64 + ast Ast.konst is_branch_konst_eval(ast);
        }
        else {
          compile_error_at(+ ast Ast.token, "symbol already exists\n");
        }
      }
      else {
        typecheck_error_at(+ ast Ast.token, "invalid type in memory statement, rhs must be a numerical value\n");
      }
    }
    else if eq type AstAssignment {
      let first cast ptr load64 + + ast Ast.node * sizeof ptr 0;
      let second cast ptr load64 + + ast Ast.node * sizeof ptr 1;
      { let _ typecheck(block, fs, first); }
      let a ts_pop();
      { let _ typecheck(block, fs, second); }
      if or eq a TypePtr eq a TypeAny {
        { let _ ts_pop(); }
        { let _ vs_pop(NULL); }
        { let _ vs_pop(NULL); }
      }
      else {
        typecheck_error_at(+ first Ast.token, "type mismatch in assignment statement\n");
      }
    }
    else if eq type AstSizeof {
      let t cast ptr + ast Ast.token;
      let size : u64 0;
      let token_type load64 + t Token.type;
      if or eq token_type T_UNSIGNED64 eq token_type T_NUMBER {
        store64 @size sizeof u64;
      }
      else if eq token_type T_UNSIGNED32 {
        store64 @size sizeof u32;
      }
      else if eq token_type T_UNSIGNED16 {
        store64 @size sizeof u16;
      }
      else if eq token_type T_UNSIGNED8 {
        store64 @size sizeof u8;
      }
      else if or or or
        eq token_type T_PTR
        eq token_type T_CSTRING
        eq token_type T_CSTR
        eq token_type T_ANY {
        store64 @size sizeof ptr;
      }
      else if eq token_type T_IDENTIFIER {
        let symbol NULL;
        let buffer : Buffer 0;
        buffer_init(@buffer, cast ptr load64 + t Token.buffer, load64 + t Token.length);
        if eq compile_lookup_value(block, fs, @buffer, @symbol, NULL, NULL) NoError {
          store64 @size load64 + symbol Symbol.size;
        }
        else {
          typecheck_error_at(cast ptr t, "symbol not defined\n");
        }
      }
      else {
        assert(0, "type not implemented yet\n");
      }
      let value : Value 0;
      store64 + @value Value.num size;
      store64 + @value Value.konst 1;
      { let _ vs_push(@value); }
      store64 + t Token.v size;
      store64 + ast Ast.konst 1;
      { let _ ts_push(TypeUnsigned64); }
    }
    else if eq type AstEnum {
      let type_node cast ptr load64 + + ast Ast.node * sizeof ptr 0;
      let enum_node cast ptr load64 + + ast Ast.node * sizeof ptr 1;
      let value : Value 0;
      store64 + @value Value.num 0;
      store64 + @value Value.konst 1;
      let i : u64 0;
      let count : u64 load64 + enum_node Ast.count;
      let type : u64 token_to_compile_type(block, fs, + type_node Ast.token, NULL);
      if is_numerical(type) {
        while < i count {
          let node cast ptr load64 + + enum_node Ast.node * sizeof ptr i;
          let symbol : ptr NULL;
          let symbol_index : u64 UINT64_MAX;
          let imm : u64 ir_push_value(+ @value Value.num, sizeof u64);

          if eq compile_declare_value(block, fs, + node Ast.token, @symbol, @symbol_index) NoError {
            store64 + symbol Symbol.imm imm;
            store64 + symbol Symbol.size load64 + @compile_type_size * sizeof u64 type;
            store64 + symbol Symbol.konst 1;
            if eq cast u64 block + @c Compile.global {
              store64 + symbol Symbol.sym_type SYM_GLOBAL_VAR;
            }
            else {
              store64 + symbol Symbol.sym_type SYM_LOCAL_VAR;
            }
            store64 + symbol Symbol.type type;
            memcpy(+ symbol Symbol.value, @value, sizeof Value);
          }
          else {
            compile_error_at(+ node Ast.token, "symbol already exists\n");
          }

          store64 + @value Value.num + 1 load64 + @value Value.num;
          store64 @i + 1 i;
        }
      }
      else {
        typecheck_error_at(+ type_node Ast.token, "expected numerical type in enum expression\n");
      }
    }
    else if eq type AstStruct {
      let fields cast ptr load64 + + ast Ast.node * sizeof ptr 0;
      let field_offset : u64 0;
      let i : u64 0;
      let count : u64 load64 + fields Ast.count;
      let fail : u64 0;
      while and eq fail 0 < i count {
        let field cast ptr load64 + + fields Ast.node * sizeof ptr i;
        let field_type cast ptr load64 + + field Ast.node * sizeof ptr 0; // type + array specifier

        let it tmp_it;
        tmp_push_str(load64 + + ast Ast.token Token.buffer, load64 + + ast Ast.token Token.length);
        tmp_push_cstr(".");
        tmp_push_str(load64 + + field Ast.token Token.buffer, load64 + + field Ast.token Token.length);

        store64 + + field Ast.token Token.buffer it;
        store64 + + field Ast.token Token.length - tmp_it it;

        let symbol : ptr NULL;
        let symbol_index : u64 UINT64_MAX;
        let imm : u64 ir_push_value(@field_offset, sizeof field_offset);
        let value : Value 0;
        store64 + @value Value.num field_offset;
        store64 + @value Value.konst 1;

        if eq compile_declare_value(block, fs, + field Ast.token, @symbol, @symbol_index) NoError {
          store64 + symbol Symbol.imm imm;
          store64 + symbol Symbol.size sizeof u64;
          store64 + symbol Symbol.konst 1;
          if eq cast u64 block + @c Compile.global {
            store64 + symbol Symbol.sym_type SYM_GLOBAL_VAR;
          }
          else {
            store64 + symbol Symbol.sym_type SYM_LOCAL_VAR;
          }
          store64 + symbol Symbol.type TypeUnsigned64;
          memcpy(+ symbol Symbol.value, @value, sizeof Value);

          let field_symbol : ptr NULL;
          let type : u64 token_to_compile_type(block, fs, + field_type Ast.token, @field_symbol);
          let field_size : u64 0;
          if and eq type TypeStruct neq field_symbol NULL {
            store64 @field_size load64 + field_symbol Symbol.size;
          }
          else if eq type TypeNone {
            compile_error_at(+ field_type Ast.token, "type does not exist\n");
            store64 @fail 1;
          }
          else {
            store64 @field_size load64 + @compile_type_size * sizeof u64 type;
          }

          if neq load64 + field_type Ast.count 0 {
            { let _ typecheck_node_list(block, fs, field_type); }
            let array_specifier_type ts_pop();
            let array_specifier_value : Value 0;
            { let _ vs_pop(@array_specifier_value); }
            if neq load64 + @array_specifier_value Value.konst 1 {
              compile_error_at(+ field_type Ast.token, "field array specifier must be a compile time constant\n");
              store64 @fail 1;
            }
            else if eq is_numerical(array_specifier_type) 0 {
              compile_error_at(+ field_type Ast.token, "field array specifier must be a numerical\n");
              store64 @fail 1;
            }
            else {
              if eq load64 + @array_specifier_value Value.num 0 {
                compile_error_at(+ field_type Ast.token, "field array specifier must be a numerical with a greater value than 0\n");
                store64 @fail 1;
              }
              else {
                store64 @field_size * field_size load64 + @array_specifier_value Value.num;
              }
            }
          }

          // update field offset
          store64 @field_offset + field_offset field_size;
        }
        else {
          compile_error_at(+ field Ast.token, "symbol already exists\n");
          store64 @fail 1;
        }
        store64 @i + 1 i;
      }
      // struct symbol definition
      let symbol : ptr NULL;
      let symbol_index : u64 UINT64_MAX;
      let value : Value 0;
      memset(@value, 0, sizeof Value);

      if eq compile_declare_value(block, fs, + ast Ast.token, @symbol, @symbol_index) NoError {
        store64 + symbol Symbol.imm UINT64_MAX;
        store64 + symbol Symbol.size field_offset;
        store64 + symbol Symbol.konst 0;
        if eq cast u64 block + @c Compile.global {
          store64 + symbol Symbol.sym_type SYM_GLOBAL_VAR;
        }
        else {
          store64 + symbol Symbol.sym_type SYM_LOCAL_VAR;
        }
        store64 + symbol Symbol.type TypeStruct;
        memcpy(+ symbol Symbol.value, @value, sizeof Value);
      }
      else {
        compile_error_at(+ ast Ast.token, "symbol already exists\n");
      }
    }
    else if eq type AstType {
      if > load64 + ast Ast.count 0 {
        { let _ typecheck_node_list(block, fs, ast); }
      }
    }
    else if eq type AstCastExpression {
      let type_expr cast ptr load64 + + ast Ast.node * sizeof ptr 0;
      let expr      cast ptr load64 + + ast Ast.node * sizeof ptr 1;
      { let _ typecheck(block, fs, expr); }
      let expr_type : u64 ts_pop();
      let cast_type : u64 token_to_compile_type(block, fs, + type_expr Ast.token, NULL);
      if neq cast_type TypeNone {
        { let _ ts_push(cast_type); }
      }
      else {
        typecheck_error_at(+ type_expr Ast.token, "can not cast to type none\n");
      }
    }
    else if eq type AstStaticAssert {
      let expr cast ptr load64 + + ast Ast.node * sizeof ptr 0;
      let node cast ptr load64 + + ast Ast.node * sizeof ptr 1;
      { let _ typecheck(block, fs, expr); }
      { let _ ts_pop(); }
      let value : Value 0;
      { let _ vs_pop(@value); }
      if eq load64 + @value Value.konst 0 {
        typecheck_error("can not do static on an expression that is evaluated at runtime\n");
      }
      else if eq load64 + @value Value.num 0 {
        let node_token cast ptr + node Ast.token;
        let message cast cstr tmp_it;
        tmp_push_cstr("assertion failed: ");
        tmp_push_str(load64 + node_token Token.buffer, load64 + node_token Token.length);
        tmp_push_cstr("\n");
        tmp_push_byte(cast u8 0);
        compile_error_at(+ expr Ast.token, message);
        store64 @tmp_it message;
      }
    }
    else {
      assert(0, "unreachable\n");
    }
  }
  ts_top();
}

fn typecheck_program(ast : ptr) -> u64 {
  assert(cast u64 ast, "something went very wrong\n");

  let time_start : timespec 0;
  let time_end : timespec 0;
  { let _ clock_gettime(CLOCK_MONOTONIC, @time_start); }

  store64 @typecheck.typecheck typecheck;

  let i 0;
  let count load64 + ast Ast.count;
  while < i count {
    let _ typecheck(+ @c Compile.global, NULL, cast ptr load64 + + ast Ast.node * sizeof ptr i);
    store64 @i + 1 i;
  }
  { let _ clock_gettime(CLOCK_MONOTONIC, @time_end); }

  if neq load64 + @c Compile.vs_count 0 {
    typecheck_error("unhandled data on the value stack\n");
  }

  if and neq load64 + @c Compile.ts_count 0 eq load64 + @c Compile.status NoError {
    typecheck_error("unhandled data on the type stack\n");
  }

  if eq load64 + @c Compile.status NoError {
    let message cast cstr tmp_it;
    let args : any (
      - load64 + @time_end timespec.tv_sec load64 + @time_start timespec.tv_sec,
      / - load64 + @time_end timespec.tv_nsec load64 + @time_start timespec.tv_nsec TIME_NANOSECONDS_DENOM
    );
    sprintf(cast ptr message, "type checking took %d.%d seconds\n", @args);
    print_info(message);

    typecheck_print_unused();
  }

  typecheck_print_stack(STDOUT_FILENO);

  load64 + @c Compile.status;
}
