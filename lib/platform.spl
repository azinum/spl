// platform.spl
// basic platform layer

include "lib/linux.spl"

fn read(fd : u64, buf : any, count : u64) -> u64 {
  linux_read(fd, buf, count);
}

fn write(fd : u64, buf : any, count : u64) -> none {
  linux_write(fd, buf, count);
}

fn open(path : any, flags : u64, mode : u64) -> u64 {
  linux_open(path, flags, mode);
}

fn close(fd : u64) -> none {
  linux_close(fd);
}

fn exit(error_code : u64) -> none {
  linux_exit(error_code);
}

fn time -> u64 {
  linux_time();
}

fn clock_gettime(clock_id : u64, spec : ptr) -> u64 {
  linux_clock_gettime(clock_id, spec);
}

fn puts(fd : u64, str : cstr) -> none {
  let n : u64 strlen(str);
  write(fd, str, n);
}

fn assert(cond : u64, message : cstr) -> none {
  if eq 0 cond {
    puts(STDERR_FILENO, "[assertion failed]: ");
    puts(STDERR_FILENO, message);
    exit(1);
  }
}

fn putu(fd : u64, n : u64) -> none {
  const MAX_BUFF_SIZE 512;
  let buff : u8 : MAX_BUFF_SIZE cast u8 0;
  u64_to_str(n, @buff, MAX_BUFF_SIZE);
  puts(fd, cast cstr @buff);
}

fn read_file_into_buffer(fd : u64, buf : any) -> u64 {
  let n : u64 0;
  while neq 0 read(fd, buf, 1) {
    = @buf + 1 buf;
    = @n   + 1 n;
  }
  n;
}

fn read_file_into_buffer_and_null_terminate(fd : u64, buf : any) -> u64 {
  let n : u64 0;
  while neq 0 read(fd, buf, 1) {
    = @buf + 1 buf;
    = @n   + 1 n;
  }
  store8 buf 0;
  = @n + 1 n;
  n;
}

fn putc(fd : u64, ch : u8) -> none {
  write(fd, @ch, sizeof ch);
}

fn putsn(fd : u64, str : any, n : u64) -> none {
  write(fd, str, n);
}

// TODO(lucas): boundary checks
fn _sprintf(str : ptr, format : cstr, args : any) -> u64 {
  let it str; // string iterator
  let fit format; // format iterator
  let arg : ptr cast ptr args;
  let done : u64 0;
  while eq done 0 {
    let ch cast u64 load8 fit;
    if eq ch 0 {
      store64 @it + it write_u8(it, cast u8 ch);
      store64 @done 1;
    }
    else if eq ch 92 {
      store64 @fit + 1 fit;
      store8 @ch load8 fit;
      if eq ch 't' {
        store64 @it + it write_u8(it, cast u8 ASCII_TAB);
      }
      else if eq ch 'b' {
        store64 @it + it write_u8(it, cast u8 ASCII_BS);
      }
      else if eq ch 'n' {
        store64 @it + it write_u8(it, cast u8 ASCII_LF);
      }
      else if eq ch 'r' {
        store64 @it + it write_u8(it, cast u8 ASCII_CR);
      }
      else if eq ch 'f' {
        store64 @it + it write_u8(it, cast u8 ASCII_FF);
      }
      else if eq ch 39 {
        store64 @it + it write_u8(it, cast u8 39);
      }
    }
    else if neq ch '%' {
      store64 @it + it write_u8(it, cast u8 ch);
    }
    else {
      store64 @fit + 1 fit;
      store8 @ch load8 fit;
      if eq ch 's' {
        store64 @it + it write_cstr(it, cast cstr load64 arg);
        store64 @arg + sizeof ptr arg;
      }
      else if eq ch 'd' {
        store64 @it + it write_u64(it, cast u64 load64 arg);
        store64 @arg + sizeof ptr arg;
      }
      else if eq ch 'i' {
        store64 @it + it write_u64(it, cast u64 load64 arg);
        store64 @arg + sizeof ptr arg;
      }
      else {
        store64 @it + it write_u8(it, cast u8 ch);
      }
    }
    store64 @fit + 1 fit;
  }

  - cast u64 it str; // return bytes written
}

fn sprintf(str : ptr, format : cstr, args : any) -> none {
  { let _ _sprintf(str, format, args); }
}

fn dprintf(fd : u64, format : cstr, args : any) -> none {
  let message cast cstr tmp_it;
  { let _ _sprintf(cast ptr message, format, args); }
  puts(fd, message);
}

fn printf(format : cstr, args : any) -> none {
  dprintf(STDOUT_FILENO, format, args);
}
