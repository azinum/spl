// platform.spl
// basic platform layer

include "lib/linux.spl"

fn read(fd : u64, buf : any, count : u64) -> u64 {
  linux_read(fd, buf, count);
}

fn write(fd : u64, buf : any, count : u64) -> none {
  linux_write(fd, buf, count);
}

fn open(path : any, flags : u64, mode : u64) -> u64 {
  linux_open(path, flags, mode);
}

fn close(fd : u64) -> none {
  linux_close(fd);
}

fn exit(error_code : u64) -> none {
  linux_exit(error_code);
}

fn time -> u64 {
  linux_time();
}

fn clock_gettime(clock_id : u64, spec : ptr) -> u64 {
  linux_clock_gettime(clock_id, spec);
}

fn puts(fd : u64, str : any) -> none {
  let n : u64 strlen(cast cstr str);
  write(fd, str, n);
}

fn putu(fd : u64, n : u64) -> none {
  const MAX_BUFF_SIZE 512;
  let buff : u8 : MAX_BUFF_SIZE cast u8 0;
  u64_to_str(n, @buff, MAX_BUFF_SIZE);
  puts(fd, @buff);
}

fn read_file_into_buffer(fd : u64, buf : any) -> u64 {
  let n : u64 0;
  while neq 0 read(fd, buf, 1) {
    = @buf + 1 buf;
    = @n   + 1 n;
  }
  n;
}

fn read_file_into_buffer_and_null_terminate(fd : u64, buf : any) -> u64 {
  let n : u64 0;
  while neq 0 read(fd, buf, 1) {
    = @buf + 1 buf;
    = @n   + 1 n;
  }
  store8 buf 0;
  = @n + 1 n;
  n;
}

fn putc(fd : u64, ch : u64) -> none {
  write(fd, @ch, 1);
}

fn putsn(fd : u64, str : any, n : u64) -> none {
  write(fd, str, n);
}

fn dprintf(fd : u64, format : cstr, args : any) -> none {
  const MAX_BUFF_SIZE 512;
  let buff : u8 : MAX_BUFF_SIZE cast u8 0;
  // TODO(lucas): implement
}
