// platform.spl
// basic platform layer

include "lib/linux.spl"

const MAX_BUFFER_SIZE = 1024;

fn read(fd : u64, buf : any, count : u64) -> u64 {
  linux_read(fd, buf, count);
}

fn write(fd : u64, buf : any, count : u64) -> none {
  linux_write(fd, buf, count);
}

fn open(path : any, flags : u64, mode : u64) -> u64 {
  linux_open(path, flags, mode);
}

fn close(fd : u64) -> none {
  linux_close(fd);
}

fn exit(error_code : u64) -> none {
  linux_exit(error_code);
}

fn time -> u64 {
  linux_time();
}

fn fsync(fd : u64) -> none {
  linux_fsync(fd);
}

fn clock_gettime(clock_id : u64, spec : ptr) -> u64 {
  linux_clock_gettime(clock_id, cast ptr<timespec> spec);
}

fn nanosleep(req : ptr, remaining : ptr) -> none {
  linux_nanosleep(cast ptr<timespec> req, cast ptr<timespec> remaining);
}

fn memory_map(start : ptr, length : u64, prot : u64, flags : u64, fd : u64, offset : u64) -> ptr {
  linux_mmap(start, length, prot, flags, fd, offset);
}

fn memory_remap(mem : ptr, old_size : u64, new_size : u64, flags : u64, start : ptr) -> ptr {
  linux_mremap(mem, old_size, new_size, flags, start);
}

fn memory_unmap(start : ptr, length : u64) -> none {
  linux_munmap(start, length);
}

fn execve(command : cstr, argv : ptr) -> none {
  linux_execve(command, argv, NULL);
}

fn fork() -> u64 {
  linux_fork();
}

fn wait4(pid : u64, stat_addr : ptr, options : u64, ru : ptr) -> u64 {
  linux_wait4(pid, stat_addr, options, ru);
}

fn puts(fd : u64, str : cstr) -> none {
  write(fd, str, strlen(str));
}

fn put(str : cstr) -> none {
  write(STDOUT_FILENO, str, strlen(str));
}

fn putu(fd : u64, n : u64) -> none {
  const MAX_BUFF_SIZE = 512;
  let buff : u8[MAX_BUFF_SIZE] = 0;
  u64_to_str(n, @buff, MAX_BUFF_SIZE);
  puts(fd, cast cstr @buff);
}

fn read_file_into_buffer(fd : u64, buf : any) -> u64 {
  let n = 0;
  while neq 0 read(fd, buf, 1) {
    store64 @buf + 1 buf;
    store64 @n   + 1 n;
  }
  n;
}

fn read_file_into_buffer_and_null_terminate(fd : u64, buf : any) -> u64 {
  let n = 0;
  while neq 0 read(fd, buf, 1) {
    = @buf + 1 buf;
    = @n   + 1 n;
  }
  store8 buf 0;
  store64 @n + 1 n;
  n;
}

fn putc(fd : u64, ch : u8) -> none {
  write(fd, @ch, sizeof ch);
}

fn putsn(fd : u64, str : any, n : u64) -> none {
  write(fd, str, n);
}

// TODO(lucas): writing n characters of string
fn snprintf(str : ptr, size : u64, format : cstr, args : any) -> u64 {
  let result = 0;
  let it = str; // string iterator
  let end = NULL;
  if neq size UINT64_MAX {
    store64 @end + + it size 1; // + 1 for null terminator
  }
  let fit = format; // format iterator
  let arg : ptr = cast ptr args;
  let done : u64 = 0;
  while eq done 0 {
    let it_diff = it;
    let ch = cast u64 load8 fit;
    if eq ch 0 {
      store64 @it + it bwrite_u8(it, end, cast u8 ch);
      store64 @done 1;
    }
    else if eq ch 92 { // `\`
      store64 @fit + 1 fit;
      store8 @ch load8 fit;
      if eq ch 't' {
        store64 @it + it bwrite_u8(it, end, cast u8 ASCII_TAB);
      }
      else if eq ch 'b' {
        store64 @it + it bwrite_u8(it, end, cast u8 ASCII_BS);
      }
      else if eq ch 'n' {
        store64 @it + it bwrite_u8(it, end, cast u8 ASCII_LF);
      }
      else if eq ch 'r' {
        store64 @it + it bwrite_u8(it, end, cast u8 ASCII_CR);
      }
      else if eq ch 'f' {
        store64 @it + it bwrite_u8(it, end, cast u8 ASCII_FF);
      }
      else if eq ch 39 {
        store64 @it + it bwrite_u8(it, end, cast u8 39);
      }
    }
    else if eq ch '%' {
      store64 @fit + 1 fit;
      store8 @ch load8 fit;
      if eq ch 's' {
        store64 @it + it bwrite_cstr(it, end, cast cstr load64 arg);
        store64 @arg + sizeof ptr arg;
      }
      else if eq ch 'd' {
        store64 @it + it bwrite_u64(it, end, cast u64 load64 arg);
        store64 @arg + sizeof ptr arg;
      }
      else if eq ch 'i' {
        store64 @it + it bwrite_u64(it, end, cast u64 load64 arg);
        store64 @arg + sizeof ptr arg;
      }
      else {
        store64 @it + it bwrite_u8(it, end, cast u8 ch);
      }
    }
    else {
      store64 @it + it bwrite_u8(it, end, cast u8 ch);
    }
    store64 @fit + 1 fit;
    store64 @it_diff - cast u64 it it_diff;
    if and neq cast u64 end NULL eq cast u64 it_diff 0 {
      let _ = write_u8(it, cast u8 0);
      store64 @done 1;
    }
  }
  store64 @result - cast u64 it str;
  if > result 0 {
    store64 @result - result 1;
  }
  result; // return number of characters written, excluding null terminator
}

fn _sprintf(str : ptr, format : cstr, args : any) -> u64 {
  snprintf(str, UINT64_MAX, format, args);
}

fn sprintf(str : ptr, format : cstr, args : any) -> none {
  { let _ = _sprintf(str, format, args); }
}

fn sprintf2(str : ptr, format : cstr, args : any) -> u64 {
  _sprintf(str, format, args);
}

fn dprintf(fd : u64, format : cstr, args : any) -> none {
  let buffer : u8[MAX_BUFFER_SIZE] = 0;
  let n = _sprintf(cast ptr @buffer, format, args);
  write(fd, cast ptr @buffer, n);
}

fn dnprintf(fd : u64, size : u64, format : cstr, args : any) -> none {
  let buffer : u8[MAX_BUFFER_SIZE] = 0;
  let n = snprintf(cast ptr @buffer, size, format, args);
  write(fd, cast ptr @buffer, n);
}

fn printf(format : cstr, args : any) -> none {
  dprintf(STDOUT_FILENO, format, args);
}

fn assert(cond : u64, message : cstr) -> none {
  if eq 0 cond {
    dprintf(STDERR_FILENO, "[assertion failed]: %s", @message);
    exit(1);
  }
}

fn exec_command(command_list : ptr) -> none {
  linux_exec_command(command_list);
}

fn socket(family : u64, type : u64, protocol : u64) -> u64 {
  linux_socket(family, type, protocol);
}
