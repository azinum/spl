- array indexing
- improve struct field access
- struct field access with array indexing
- optimize ir code generator so that it does not emit redundant instructions e.g. from constant expressions
- dependency trace (i.e. trace which things depend on which other things)
- improve memory allocator
- differentiate between signed and unsigned comparison operators for where it is necessary (e.g. cmovl vs. cmovb for signed and unsigned values respectively)
- add ability to use escaped and unescaped `raw` strings
- struct padding and alignment (end user should be able to opt-out of struct padding/alignment, as well as being able to specify padding and alignment sizes)
- do more work on type casting
- signed integers
- function inlining
- compile time evaluation of `trival` functions
- fix parsing bug where `;` is not detected after binary operation
- fix parsing bug where single `}` are not detected
- basic introspection
- library linking
- improve error printing of invalid type constructions
	- improve error printing in general
- self referencing in structs (i.e. struct T (t : ptr<T>))
    refer to a struct in a struct of the same type ---^
	- however, it should not be permitted to store a struct in a struct of the same type directly
- user access to file, line, column information in code
- array assignments in let/const statements:
	- const a = 1, 2, 3, 4;
	- const b = a; // yields bad results
- implement tests that fail and show correct errors
- support printing of arbitrarily long strings in printf functions
- convert the list of function signatures to a set, so that there will be no duplicates in the list of function signatures
	- this makes for simpler comparisons of types because then simply calling types_are_equal will be sufficient
- properly typecheck `any` type inside of container types
- fix bug where a const array is not properly initialized
	- const a: u8[512] = 0; // tries to read constant/immediate data that is not written
