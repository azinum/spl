// typecheck.spl

// TODO(lucas): temporary, allow passing and pushing structs of any size
const MAX_STRUCT_SIZE = sizeof u64;

enum u64 (
  TYPE_CONTRACT_LOOKUP,
  TYPE_CONTRACT_CREATE
);

enum u64 (
  TYPE_CONSTRAINT_VALID, // valid constraint, we're good to continue
  TYPE_CONSTRAINT_INVALID,  // not a valid constraint, stop
  TYPE_CONSTRAINT_UNDECIDABLE // unwrapping of type is needed, thus we can not decide if the constraint is valid or not at this moment
);

fn typecheck_function(block : ptr<Block>, fs : ptr<Function>, ast : ptr) -> u64 0;
let _typecheck = typecheck_function;
fn type_print_func_sig(fd : u64, type : ptr<Type>) -> none {}
let _type_print = type_print_func_sig;
let _type_printline = type_print_func_sig;

fn typecheck_print_unused -> none {
  if not load64 + @options Options.disable_dce {
    let i = MAX_SYSCALL_FUNCTION;
    let count = load64 + c Compile.symbol_count;
    while < i count {
      let symbol : Symbol = 0;
      memcpy(@symbol, + + c Compile.symbols * sizeof Symbol i, sizeof Symbol);
      let ref_count = load64 + @symbol Symbol.ref_count;
      let sym_type = load64 + @symbol Symbol.sym_type;
      if and eq ref_count 0 eq sym_type SYM_FUNC {
        let args : any = (
          + @symbol Symbol.name
        );
        warning_at(+ @symbol Symbol.token, "`%s` defined but not used\n", @args);
      }
      store64 @i + 1 i;
    }
  }
}

fn typecheck_error(message : cstr) -> none {
  if eq load64 + c Compile.status NoError {
    color_set(COLOR_ERROR);
    dprintf(STDERR_FILENO, "[typecheck-error]: ", NULL);
    color_reset();
    dprintf(STDERR_FILENO, "%s", @message);
    store64 + c Compile.status Error;
  }
  store64 + c Compile.error_count + 1 load64 + c Compile.error_count;
}

// token : Token*
fn typecheck_error_at(token : ptr, format : cstr, args : any) -> none {
  const fd : u64 = STDERR_FILENO;
  if eq load64 + c Compile.status NoError {
    {
      let args : any = (
        load64 + token Token.filename,
        load64 + token Token.line,
        load64 + token Token.column
      );
      color_set(COLOR_ERROR);
      dprintf(fd, "[typecheck-error]: ", NULL);
      color_set(COLOR_EXTRA);
      dprintf(fd, "%s:%d:%d: ", @args);
      color_reset();
    }
    dprintf(fd, format, args);
    printline(fd, cast cstr load64 + token Token.source, cast cstr load64 + token Token.buffer, load64 + token Token.length, 1, NUM_LINES_TO_PRINT);
    store64 + c Compile.status Error;
  }
  store64 + c Compile.error_count + 1 load64 + c Compile.error_count;
}

fn type_context_init(context : ptr<Type_context>) -> none {
  type_init(cast ptr<Type> + context Type_context.type, TypeNone, 0, 0, 1);
  store64 + context Type_context.offset 0;
  store64 + context Type_context.symbol_id UINT64_MAX;
}

fn type_context_push(context : ptr<Type_context>) -> u64 {
  let id = cast ptr<u64> + c Compile.type_context_count;
  let result = UINT64_MAX;
  if < deref id MAX_TYPE_CONTEXT {
    store64 @result deref id;
    memcpy(+ + c Compile.type_contexts * sizeof Type_context deref id, context, sizeof Type_context);
    store64 id + 1 deref id;
  }
  else {
    assert(0, "type context capacity reached\n");
  }
  result;
}

fn type_context_from_id(id : u64) -> ptr<Type_context> {
  let result = cast ptr<Type_context> NULL;
  if < id load64 + c Compile.type_context_count {
    store64 @result + + c Compile.type_contexts * sizeof Type_context id;
  }
  result;
}

fn struct_field_init(field : ptr<Struct_field>, name : ptr<u8[MAX_NAME_SIZE]>, length : u64, type : ptr<Type>, offset : u64) -> u64 {
  let result = Error;
  if < length MAX_NAME_SIZE {
    strncpy(cast cstr + field Struct_field.name, cast cstr name, length);
    memcpy(+ field Struct_field.type, type, sizeof Type);
    store64 + field Struct_field.offset offset;
    store64 @result NoError;
  }
  result;
}

fn struct_type_info_init(info : ptr<Struct_type_info>) -> none {
  store64 + info Struct_type_info.count 0;
}

fn struct_lookup_field(info : ptr<Struct_type_info>, name : ptr<u8[MAX_NAME_SIZE]>) -> ptr<Struct_field> {
  let result = cast ptr<Struct_field> NULL;

  let i = 0;
  let count = load64 + info Struct_type_info.count;
  while < i count {
    let lookup = cast ptr<Struct_field> + + info Struct_type_info.fields * sizeof Struct_field i;
    if eq strncmp(cast cstr + lookup Struct_field.name, cast cstr name, MAX_NAME_SIZE) 0 {
      store64 @result lookup;
    }
    store64 @i + 1 i;
  }

  result;
}

fn struct_create_field(info : ptr<Struct_type_info>, field : ptr<Struct_field>) -> u64 {
  let result = Error;
  if eq struct_lookup_field(info, cast ptr<u8[MAX_NAME_SIZE]> + field Struct_field.name) NULL {
    let index = cast ptr<u64> + info Struct_type_info.count;
    let new_field = cast ptr<Struct_field> + + info Struct_type_info.fields * sizeof Struct_field deref index;
    store64 index + 1 deref index;
    memcpy(new_field, field, sizeof Struct_field);
    store64 @result NoError;
  }
  result;
}

fn struct_fetch_field(info : ptr<Struct_type_info>, field_index : u64) -> ptr<Struct_field> {
  let result = cast ptr<Struct_field> NULL;
  let count = load64 + info Struct_type_info.count;
  if < field_index count {
    store64 @result + + info Struct_type_info.fields * sizeof Struct_field field_index;
  }
  result;
}

fn struct_fetch_type_info(id : u64) -> ptr<Struct_type_info> {
  let result = cast ptr<Struct_type_info> NULL;
  let struct_id = load64 + c Compile.struct_id;
  if < id struct_id {
    store64 @result + + c Compile.struct_type_info * sizeof Struct_type_info id;
  }
  result;
}

fn struct_type_push(info : ptr<Struct_type_info>) -> u64 {
  let result = NoError;
  let struct_id = cast ptr<u64> + c Compile.struct_id;
  memcpy(cast any + + c Compile.struct_type_info * sizeof Struct_type_info deref struct_id, info, sizeof Struct_type_info);
  store64 struct_id + 1 deref struct_id;
  result;
}

fn struct_type_info_print(fd : u64, info : ptr<Struct_type_info>, flat : u64) -> none {
  let i = 0;
  let count = load64 + info Struct_type_info.count;
  dprintf(fd, "(", NULL);
  if eq flat 0 {
    dprintf(fd, "\n", NULL);
  }
  while < i count {
    let field = struct_fetch_field(info, i);
    let field_type : Type = 0;
    memcpy(at field_type, + field Struct_field.type, sizeof Type);

    let args : any = + field Struct_field.name;
    if eq flat 0 {
      dprintf(fd, "  ", NULL);
    }
    dprintf(fd, "%s : ", @args);
    _type_print(fd, at field_type);

    store64 @i + 1 i;
    if < i count {
      dprintf(fd, ",", NULL);
      if flat {
        dprintf(fd, " ", NULL);
      }
    }
    if eq flat 0 {
      dprintf(fd, "\n", NULL);
    }
  }
  dprintf(fd, ")", NULL);
}

fn struct_type_info_printline(fd : u64, info : ptr<Struct_type_info>, flat : u64) -> none {
  struct_type_info_print(fd, info, flat);
  dprintf(fd, "\n", NULL);
}

// for now `ptr` is the only type that is a container i.e. a type that can contain other types
fn type_is_container(type : ptr<Type>) -> u64 {
  eq type_base(type) TypePtr;
}

fn type_print(fd : u64, type : ptr<Type>) -> none {
  // check if this is a container type
  if type_is_container(type) {
    let args : any = (
      load64 + @compile_type_str * sizeof cstr type_base(type)
    );
    dprintf(fd, "%s<", @args);
    let next_type : Type = 0;
    memcpy(at next_type, + + c Compile.types * sizeof Type type_sub_id(type), sizeof Type);
    type_print(fd, at next_type);
    dprintf(fd, ">", NULL);
  }
  else if eq type_base(type) TypeStruct {
    let id = type_sub_id(type);
    let args : any = (
      load64 + @compile_type_str * sizeof cstr type_base(type),
      id
    );
    dprintf(fd, "%s<%d>", @args);
    let type_info = struct_fetch_type_info(id);
    struct_type_info_print(fd, type_info, 1);
  }
  else if eq type_base(type) TypeFunc {
    let args : any = (
      load64 + @compile_type_str * sizeof cstr type_base(type),
      type_sub_id(type)
    );
    dprintf(fd, "%s<%d>", @args);
  }
  // primitive type
  else {
    let args : any = (
      load64 + @compile_type_str * sizeof cstr type_base(type)
    );
    dprintf(fd, "%s", @args);
  }
  let count = load64 + type Type.count;
  if > count 1 {
    dprintf(fd, "[%d]", @count);
  }
}

fn type_printline(fd : u64, type : ptr<Type>) -> none {
  type_print(fd, type);
  dprintf(fd, "\n", NULL);
}

fn types_are_equal(a : ptr<Type>, b : ptr<Type>) -> u64 {
  and and
    eq load64 + a Type.base     load64 + b Type.base
    eq load64 + a Type.sub_id   load64 + b Type.sub_id
    eq load64 + a Type.count    load64 + b Type.count;
}

fn typecheck_print_stack(fd : u64) -> none {
  let i = 0;
  let count = load64 + c Compile.ts_count;
  while < i count {
    let type : Type = 0;
    memcpy(at type, + + c Compile.ts * sizeof Type i, sizeof Type);
    let value : Value = 0;
    memcpy(at value, + + c Compile.vs * sizeof Value i, sizeof Value);
    dprintf(fd, "%d: ", @i);
    type_print(fd, at type);
    let args : any = load64 + @value Value.num;
    dprintf(fd, " = %d\n", @args);
    store64 @i + 1 i;
  }
}

fn type_from_id(id : u64, type_out : ptr<Type>) -> none {
  let type_count : u64 = load64 + c Compile.type_count;
  if < id type_count {
    memcpy(type_out, + + c Compile.types * sizeof Type id, sizeof Type);
  }
  else {
    assert(0, "type_from_id: bad type id\n");
  }
}

fn compile_type_size(type_id : u64) -> u64 {
  let result = 0;
  if < type_id load64 + c Compile.type_count {
    let type : Type = 0;
    type_from_id(type_id, at type);
    store64 @result load64 + at type Type.size;
  }
  result;
}

fn type_lookup(type : ptr<Type>) -> u64 {
  let result : u64 = UINT64_MAX;
  let done : u64 = 0;
  let i : u64 = 0;
  let type_count : u64 = load64 + c Compile.type_count;
  while and eq done 0 < i type_count {
    let t : Type = 0;
    memcpy(at t, + + c Compile.types * sizeof Type i, sizeof Type);
    if types_are_equal(type, at t) {
      store64 @result i;
      store64 @done 1;
    }
    store64 @i + 1 i;
  }
  result;
}

fn type_push_new(type : ptr<Type>) -> u64 {
  let type_count = cast ptr<u64> + c Compile.type_count;
  let id = deref type_count;
  if < deref type_count MAX_COMPILE_TYPE {
    memcpy(+ + c Compile.types * sizeof Type deref type_count, type, sizeof Type);
    store64 type_count + 1 deref type_count;
  }
  else {
    assert(0, "compile type capacity reached, increase capacity\n");
  }
  id; // return id of the newly created type
}

// same as type_push_new but hash the type as well
// simply hashes the type struct itself
fn type_commit_new(type : ptr<Type>) -> u64 {
  store64 + type Type.hash 0; // reset hash, in case the type was modified
  let hash = sdbm_hash(type, sizeof Type);
  store64 + type Type.hash hash;
  type_push_new(type);
}

// checks if `type` is valid inside of `container`
fn type_check_constraints(container : ptr<Type>, type : ptr<Type>) -> u64 {
  let result = TYPE_CONSTRAINT_INVALID;
  if type_is_container(container) {
    store64 @result TYPE_CONSTRAINT_VALID;
  }
  else if and eq type_base(container) MAX_PRIMITIVE_TYPE > type_base(container) MAX_PRIMITIVE_TYPE {
    store64 @result TYPE_CONSTRAINT_UNDECIDABLE;
  }
  result;
}

fn type_deflate(type : ptr<Type>, type_out : ptr<Type>) -> none {
  if type_out {
    type_init(type_out, TypeNone, 0, 0, 1);
  }
  let id = type_sub_id(type);
  if neq id 0 {
    if type_is_container(type) {
      if type_out {
        type_from_id(id, type_out);
      }
    }
  }
}

// contract : Type[]
fn type_from_contract(contract : ptr<Type>, count : u64, mode : u64, result_out : ptr<Type>) -> u64 {
  assert(neq count 0, "number of elements in contract must be greater than 0\n");
  let result = NoError;
  let fail : u64 = 0;

  type_init(result_out, TypeNone, 0, 0, 1);

  if eq count 1 {
    let type : Type = 0;
    memcpy(at type, contract, sizeof Type);
    let lookup : u64 = type_lookup(at type);
    if neq lookup UINT64_MAX {
      memcpy(result_out, at type, sizeof Type);
    }
    else if eq mode TYPE_CONTRACT_CREATE {
      // TODO(lucas): check if this type is valid
      { let _ = type_commit_new(at type); }
      memcpy(result_out, at type, sizeof Type);
    }
    else {
      store64 @fail 1;
    }
  }
  else {
    let i : u64 = - count 1;
    let primary_type : Type = 0;
    type_init(
      at primary_type,
      TypeNone,
      0, // sub type id
      0, // size
      1  // count
    );
    let sub_type : Type = 0;
    memcpy(at sub_type, + contract * sizeof Type i, sizeof Type);

    while and eq fail 0 > i 0 {
      memcpy(at primary_type, + contract * sizeof Type - i 1, sizeof Type);
      let sub_type_id = type_lookup(at sub_type);
      if and eq mode TYPE_CONTRACT_CREATE eq sub_type_id UINT64_MAX {
        store64 @sub_type_id type_commit_new(at sub_type);
      }
      if neq sub_type_id UINT64_MAX {
        let primary_type_count : u64 = load64 + at primary_type Type.count;
        let type : Type = 0;
        type_init(at type, type_base(at primary_type), sub_type_id, load64 + at primary_type Type.size, primary_type_count);

        let constraint : u64 = type_check_constraints(at primary_type, at sub_type);
        if or eq constraint TYPE_CONSTRAINT_VALID eq constraint TYPE_CONSTRAINT_UNDECIDABLE {
          let lookup : u64 = type_lookup(at type);
          if eq lookup UINT64_MAX {
            // type does not exist, create new type if mode is TYPE_CONTRACT_CREATE
            if eq mode TYPE_CONTRACT_CREATE {
              let new_type_id : u64 = type_commit_new(at type);
              assert(neq new_type_id 0, "failed to push new type\n");
              memcpy(result_out, at type, sizeof Type);
              memcpy(at sub_type, at type, sizeof Type); // sub type is now the newly created type
            }
            else {
              store64 @fail 1;
            }
          }
          else {
            // type exists
            memcpy(result_out, at type, sizeof Type);
            memcpy(at sub_type, at type, sizeof Type); // sub type is the newly created type
          }
        }
        else { // constraint failed
          store64 @fail 1;
        }
      }
      else {
        store64 @fail 1;
      }
      store64 @i - i 1;
    }
  }

  if fail {
    store64 @result Error;
  }
  result;
}

fn typecheck_print_types(fd : u64) -> none {
  dprintf(fd, "typecheck_print_types:\n", NULL);
  let i : u64 = 0;
  let count : u64 = load64 + c Compile.type_count;
  while < i count {
    let type : Type = 0;
    memcpy(at type, + + c Compile.types * sizeof Type i, sizeof Type);

    dprintf(fd, "%d: ", @i);
    type_printline(fd, at type);

    store64 @i + 1 i;
  }
}

fn type_contract_stack_reset -> none {
  store64 + c Compile.type_contract_count 0;
}

fn type_contract_stack_push(type : ptr<Type>) -> u64 {
  let result = NoError;
  let count = cast ptr<u64> + c Compile.type_contract_count;
  if < deref count MAX_TYPE_CONTRACT_STACK {
    memcpy(+ + c Compile.type_contract_stack * sizeof Type deref count, type, sizeof Type);
    store64 count + 1 deref count;
  }
  else {
    store64 @result Error;
  }
  result;
}

fn is_numerical(type : ptr<Type>) -> u64 {
  let value = type_base(type);
  or or or
    eq value TypeUnsigned64
    eq value TypeUnsigned32
    eq value TypeUnsigned16
    eq value TypeUnsigned8;
}

fn ts_push(type : ptr<Type>, type_out : ptr<Type>) -> none {
  if type_out {
    type_init(type_out, TypeNone, 0, 0, 1);
  }
  let ts_count = cast ptr<u64> + c Compile.ts_count;
  if < deref ts_count MAX_TYPE_STACK {
    memcpy(+ + c Compile.ts * sizeof Type deref ts_count, type, sizeof Type);
    store64 ts_count + 1 deref ts_count;
    if type_out {
      memcpy(type_out, type, sizeof Type);
    }
  }
  else {
    assert(0, "type stack overflow\n");
  }
}

fn ts_push_primitive(primitive : u64, type_out : ptr<Type>) -> none {
  let type : Type = 0;
  type_init(at type, primitive, 0, compile_type_size(primitive), 1);
  ts_push(at type, type_out);
}

fn ts_pop(type_out : ptr<Type>) -> none {
  if type_out {
    type_init(type_out, TypeNone, 0, 0, 1);
  }
  let ts_count = cast ptr<u64> + c Compile.ts_count;
  if < deref ts_count MAX_TYPE_STACK {
    store64 ts_count - deref ts_count 1;
    if type_out {
      memcpy(type_out, + + c Compile.ts * sizeof Type deref ts_count, sizeof Type);
    }
  }
  else {
    assert(0, "type stack underflow\n");
  }
}

fn ts_top(type_out : ptr<Type>) -> none {
  if type_out {
    type_init(type_out, TypeNone, 0, 0, 1);
  }
  let ts_count = cast ptr<u64> + c Compile.ts_count;
  if < deref ts_count MAX_TYPE_STACK {
    if type_out {
      memcpy(type_out, + + c Compile.ts * sizeof Type - deref ts_count 1, sizeof Type);
    }
  }
}

fn vs_push(value : ptr<Value>) -> u64 {
  let result = NoError;
  let vs_count = cast ptr<u64> + c Compile.vs_count;
  if < deref vs_count MAX_TYPE_STACK {
    memcpy(+ + c Compile.vs * sizeof Value deref vs_count, value, sizeof Value);
    store64 vs_count + 1 deref vs_count;
  }
  else {
    assert(0, "value stack overflow\n");
    store64 @result Error;
  }
  result;
}

fn vs_top(value_out : ptr<Value>) -> none {
  let vs_count : u64 = load64 + c Compile.vs_count;
  if < vs_count MAX_TYPE_STACK {
    if value_out {
      memcpy(value_out, + + c Compile.vs * sizeof Value - vs_count 1, sizeof Value);
    }
  }
  else {
    if value_out {
      store64 @value_out NULL;
    }
  }
}

fn vs_pop(value_out : ptr<Value>) -> u64 {
  let result = NoError;
  let vs_count = cast ptr<u64> + c Compile.vs_count;
  if < deref vs_count MAX_TYPE_STACK {
    if value_out {
      vs_top(value_out);
    }
    store64 vs_count - deref vs_count 1;
  }
  else {
    assert(0, "value stack underflow\n");
    store64 @result Error;
  }
  result;
}

// block : Block*, fs : Function*, token : Token*, symbol_out : Symbol**
fn token_to_compile_type(block : ptr<Block>, fs : ptr<Function>, token : ptr, symbol_out : ptr, type_out : ptr<Type>) -> none {
  type_init(type_out, TypeNone, 0, 0, 1);
  let token_type = load64 + token Token.type;
  if eq token_type T_ANY {
    type_init(type_out, TypeAny, 0, sizeof any, 1);
  }
  else if eq token_type T_PTR {
    type_init(type_out, TypePtr, 0, sizeof ptr, 1);
  }
  else if eq token_type T_UNSIGNED64 {
    type_init(type_out, TypeUnsigned64, 0, sizeof u64, 1);
  }
  else if eq token_type T_UNSIGNED32 {
    type_init(type_out, TypeUnsigned32, 0, sizeof u32, 1);
  }
  else if eq token_type T_UNSIGNED16 {
    type_init(type_out, TypeUnsigned16, 0, sizeof u16, 1);
  }
  else if eq token_type T_UNSIGNED8 {
    type_init(type_out, TypeUnsigned8, 0, sizeof u8, 1);
  }
  else if or eq token_type T_CSTRING eq token_type T_CSTR {
    type_init(type_out, TypeCString, 0, sizeof cstr, 1);
  }
  else if eq token_type T_IDENTIFIER {
    let symbol = NULL;
    let buffer : Buffer = 0;
    buffer_init(at buffer, cast ptr load64 + token Token.buffer, load64 + token Token.length);
    if eq compile_lookup_value(block, fs, @buffer, @symbol, NULL, NULL) NoError {
      if neq symbol_out NULL {
        store64 symbol_out symbol;
      }
      memcpy(type_out, + symbol Symbol.type, sizeof Type);
    }
  }
}

// result is stored in Compile.type_contract_stack
// Type
//   None | Value
//   Type
// block : ptr<Block>, fs : ptr<Function>, ast : ptr<Ast>
fn collect_types_from_node(block : ptr<Block>, fs : ptr<Function>, ast : ptr) -> u64 {
  let result = NoError;
  let sub_type_node = NULL;
  if ast {
    let type : Type = 0;
    let symbol = NULL;
    token_to_compile_type(block, fs, + ast Ast.token, @symbol, at type);
    let array_specifier_node = cast ptr load64 + + ast Ast.node * sizeof ptr 0;
    if neq load64 + array_specifier_node Ast.type AstNone {
      { let _ = _typecheck(block, fs, array_specifier_node); }
      let value : Value = 0;
      { let _ = vs_pop(at value); }
      let array_specifier_type : Type = 0;
      ts_pop(at array_specifier_type);
      if is_numerical(at array_specifier_type) {
        store64 + at type Type.count load64 + at value Value.num;
      }
      else {
        store64 @result Error;
      }
    }
    if and symbol eq type_base(at type) TypeNone {
      store64 @result Error;
    }
    else if eq type_contract_stack_push(at type) NoError {
      if eq load64 + ast Ast.count 2 {
        store64 @sub_type_node load64 + + ast Ast.node * sizeof ptr 1;
      }
      store64 @result collect_types_from_node(block, fs, sub_type_node);
      store64 @result NoError;
    }
    else {
      store64 @result Error;
    }
  }
  result;
}

// block : Block*, fs : Function*, ast : Ast*, mode : u64, type_out : Type*
fn type_contract_from_type_node(block : ptr<Block>, fs : ptr<Function>, ast : ptr, mode : u64, type_out : ptr<Type>, accept_none_type : u64) -> u64 {
  let result = Error;
  let collected_types_result = collect_types_from_node(block, fs, ast);
  if eq collected_types_result NoError {
    let type : Type = 0;
    let contract = cast ptr<Type> + c Compile.type_contract_stack;
    let count : u64 = load64 + c Compile.type_contract_count;
    if eq type_from_contract(contract, count, mode, at type) NoError {
      memcpy(type_out, at type, sizeof Type);
      store64 @result NoError;
      if eq accept_none_type 0 {
        if eq type_base(at type) TypeNone {
          store64 @result Error;
        }
      }
    }
    type_contract_stack_reset();
  }
  result;
}

fn check_func_signatures(a : ptr<Function>, b : ptr<Function>) -> u64 {
  let result : u64 = 1;
  if and
    eq load64 + a Function.argc load64 + b Function.argc
    types_are_equal(cast ptr<Type> + a Function.rtype, cast ptr<Type> + b Function.rtype) {

    let i : u64 = 0;
    let argc : u64 = load64 + a Function.argc;
    let done : u64 = 0;
    while and eq done 0 < i argc {
      let arg_a : u64 = load64 + + a Function.argc * sizeof u64 i;
      let arg_b : u64 = load64 + + b Function.argc * sizeof u64 i;
      let type_a : Type = 0;
      memcpy(at type_a, + + + c Compile.symbols * sizeof Symbol arg_a Symbol.type, sizeof Type);
      let type_b : Type = 0;
      memcpy(at type_b, + + + c Compile.symbols * sizeof Symbol arg_b Symbol.type, sizeof Type);
      if eq types_are_equal(at type_a, at type_b) 0 {
        store64 @result 0;
        store64 @done 1;
      }
      store64 @i + 1 i;
    }
  }
  else {
    store64 @result 0;
  }
  result;
}

// ast : Ast*
fn is_branch_konst_eval(ast : ptr) -> u64 {
  let konst = 1;
  let i = 0;
  let count = load64 + ast Ast.count;
  while < i count {
    let node = cast ptr load64 + + ast Ast.node * sizeof ptr i;
    if eq load64 + node Ast.konst 0 {
      store64 @konst 0;
      store64 @i count;
    }
    store64 @i + 1 i;
  }
  konst;
}

fn typecheck_node_list(block : ptr<Block>, fs : ptr<Function>, ast : ptr) -> u64 {
  let i = 0;
  let count = load64 + ast Ast.count;
  while < i count {
    let _ = _typecheck(block, fs, cast ptr load64 + + ast Ast.node * sizeof ptr i);
    store64 @i + 1 i;
  }
  load64 + c Compile.status;
}

fn typecheck_value(block : ptr<Block>, fs : ptr<Function>, ast : ptr) -> u64 {
  let token_type = load64 + + ast Ast.token Token.type;
  if eq token_type T_NUMBER {
    let value : Value = 0;
    store64 + @value Value.num load64 + + ast Ast.token Token.v;
    store64 + @value Value.konst 1;
    store64 + ast Ast.konst 1;
    { let _ = vs_push(at value); }
    ts_push_primitive(TypeUnsigned64, cast ptr<Type> NULL);
  }
  else if eq token_type T_CSTRING {
    let value : Value = 0;
    memset(@value, 0, sizeof Value);
    { let _ = vs_push(at value); }
    ts_push_primitive(TypeCString, cast ptr<Type> NULL);
  }
  else if eq token_type T_IDENTIFIER {
    let symbol : ptr = NULL;
    let symbol_index = UINT64_MAX;
    let token_buffer : Buffer = 0;
    buffer_init(at token_buffer, cast ptr load64 + + ast Ast.token Token.buffer, load64 + + ast Ast.token Token.length);

    if eq compile_lookup_value(block, fs, @token_buffer, @symbol, @symbol_index, NULL) NoError {
      store64 + symbol Symbol.ref_count + 1 load64 + symbol Symbol.ref_count;
      store64 + + ast Ast.token Token.v symbol_index;
      store64 + ast Ast.konst load64 + + symbol Symbol.value Value.konst;
      let size : u64 = load64 + symbol Symbol.size;
      let type : Type = 0;
      memcpy(at type, + symbol Symbol.type, sizeof Type);
      if and > size MAX_STRUCT_SIZE eq type_base(at type) TypeStruct {
        let args : any = MAX_STRUCT_SIZE;
        typecheck_error_at(+ ast Ast.token, "can not push a struct with size greater than %d\n", @args);
      }
      else {
        { let _ = vs_push(cast ptr<Value> + symbol Symbol.value); }
        ts_push(at type, cast ptr<Type> NULL);
      }
    }
    else {
      let message = tmp_it;
      tmp_push_cstr("symbol `");
      tmp_push_str(load64 + + ast Ast.token Token.buffer, load64 + + ast Ast.token Token.length);
      tmp_push_cstr("` not defined\n");
      tmp_push_byte(cast u8 0);
      compile_error_at(+ ast Ast.token, cast cstr message);
      store64 @tmp_it message;
    }
  }
  else if or eq token_type T_AT eq token_type T_AT_WORD {
    let symbol : ptr = NULL;
    let symbol_index = UINT64_MAX;
    let token_buffer : Buffer = 0;
    buffer_init(at token_buffer, cast ptr load64 + + ast Ast.token Token.buffer, load64 + + ast Ast.token Token.length);
    if eq compile_lookup_value(block, fs, @token_buffer, @symbol, @symbol_index, NULL) NoError {
      store64 + symbol Symbol.ref_count + 1 load64 + symbol Symbol.ref_count;
      store64 + + ast Ast.token Token.v symbol_index;
      let type : Type = 0;
      memcpy(at type, + symbol Symbol.type, sizeof Type);
      if eq token_type T_AT_WORD {
        const count = 2;
        let contract : Type[count] = 0;
        type_init(cast ptr<Type> + at contract * sizeof Type 0, TypePtr, 0, sizeof ptr, 1);
        memcpy(+ at contract * sizeof Type 1, at type, sizeof Type);
        let ptr_type : Type = 0;
        if eq type_from_contract(cast ptr<Type> at contract, count, TYPE_CONTRACT_CREATE, at ptr_type) NoError {
          let value : Value = 0;
          memcpy(at value, + symbol Symbol.value, sizeof Value);
          store64 + at value Value.konst 0;
          { let _ = vs_push(at value); }
          ts_push(at ptr_type, cast ptr<Type> NULL);
        }
        else {
          typecheck_error_at(+ ast Ast.token, "invalid pointer type construction\n", NULL);
        }
      }
      else {
        let value : Value = 0;
        memcpy(at value, + symbol Symbol.value, sizeof Value);
        store64 + at value Value.konst 0;
        { let _ = vs_push(at value); }
        let ptr_type : Type = 0;
        type_init(at ptr_type, TypePtr, 0, sizeof ptr, 1);
        ts_push(at ptr_type, cast ptr<Type> NULL);
      }
      store64 + ast Ast.konst 0;
    }
    else {
      let message = tmp_it;
      tmp_push_cstr("symbol `");
      tmp_push_str(load64 + + ast Ast.token Token.buffer, load64 + + ast Ast.token Token.length);
      tmp_push_cstr("` not defined\n");
      tmp_push_byte(cast u8 0);
      compile_error_at(+ ast Ast.token, cast cstr message);
      store64 @tmp_it message;
    }
  }
  else {
    assert(0, "invalid token type\n");
  }
  load64 + c Compile.status;
}

fn typecheck_binop_expr(block : ptr<Block>, fs : ptr<Function>, ast : ptr) -> u64 {
  { let _ = typecheck_node_list(block, fs, ast); }
  let b : Type = 0;
  let a : Type = 0;
  ts_pop(at b);
  ts_pop(at a);
  if and
    or or or is_numerical(at a) eq type_base(at a) TypeAny eq type_base(at a) TypePtr eq type_base(at a) TypeCString
    or or or is_numerical(at b) eq type_base(at b) TypeAny eq type_base(at b) TypePtr eq type_base(at b) TypeCString {
    let va : Value = 0;
    let vb : Value = 0;
    { let _ = vs_pop(at vb); }
    { let _ = vs_pop(at va); }
    store64 + ast Ast.konst and load64 + @va Value.konst load64 + @vb Value.konst;

    let num : u64 = 0;
    let token_type = load64 + + ast Ast.token Token.type;
    if eq token_type T_ADD {
      store64 @num + load64 + @va Value.num load64 + @vb Value.num;
    }
    else if eq token_type T_SUB {
      store64 @num - load64 + @va Value.num load64 + @vb Value.num;
    }
    else if eq token_type T_MUL {
      store64 @num * load64 + @va Value.num load64 + @vb Value.num;
    }
    else if eq token_type T_DIV {
      if eq load64 + @vb Value.konst 1 {
        if eq load64 + @vb Value.num 0 {
          typecheck_error("divide by zero arithmetic error\n");
        }
        else {
          store64 @num / load64 + @va Value.num load64 + @vb Value.num;
        }
      }
    }
    else if eq token_type T_DIVMOD {
      if eq load64 + @vb Value.konst 1 {
        if eq load64 + @vb Value.num 0 {
          typecheck_error("modulo by zero arithmetic error\n");
        }
        else {
          store64 @num % load64 + @va Value.num load64 + @vb Value.num;
        }
      }
    }
    else if eq token_type T_LSHIFT {
      store64 @num lshift load64 + @va Value.num load64 + @vb Value.num;
    }
    else if eq token_type T_RSHIFT {
      store64 @num rshift load64 + @va Value.num load64 + @vb Value.num;
    }
    else if eq token_type T_LT {
      store64 @num < load64 + @va Value.num load64 + @vb Value.num;
    }
    else if eq token_type T_GT {
      store64 @num > load64 + @va Value.num load64 + @vb Value.num;
    }
    else if eq token_type T_AND {
      store64 @num and load64 + @va Value.num load64 + @vb Value.num;
    }
    else if eq token_type T_OR {
      store64 @num or load64 + @va Value.num load64 + @vb Value.num;
    }
    else if eq token_type T_XOR {
      store64 @num xor load64 + @va Value.num load64 + @vb Value.num;
    }
    else if eq token_type T_EQ {
      store64 @num eq load64 + @va Value.num load64 + @vb Value.num;
    }
    else if eq token_type T_NEQ {
      store64 @num neq load64 + @va Value.num load64 + @vb Value.num;
    }
    else {
      assert(0, "unhandled operator\n");
    }
    let value : Value = 0;
    store64 + @value Value.num num;
    let konst : u64 = is_branch_konst_eval(ast);
    store64 + ast Ast.konst konst;
    store64 + @value Value.konst konst;
    { let _ = vs_push(at value); }
    ts_push(at a, cast ptr<Type> NULL);
  }
  else {
    typecheck_error("type mismatch in binary operator expression\n");
  }
  load64 + c Compile.status;
}

fn typecheck_uop_expr(block : ptr<Block>, fs : ptr<Function>, ast : ptr) -> u64 {
  let ts_count : u64 = load64 + c Compile.ts_count;
  { let _ = typecheck_node_list(block, fs, ast); }
  store64 + ast Ast.konst is_branch_konst_eval(ast);
  let ts_delta : u64 = - load64 + c Compile.ts_count ts_count;
  if eq ts_delta 1 {
    let token_type = load64 + + ast Ast.token Token.type;
    if eq token_type T_PRINT {
      { let _ = vs_pop(cast ptr<Value> NULL); }
      ts_pop(cast ptr<Type> NULL);
    }
    else if or or or or
      eq token_type T_DEREF
      eq token_type T_LOAD64
      eq token_type T_LOAD32
      eq token_type T_LOAD16
      eq token_type T_LOAD8 {
      ts_pop(cast ptr<Type> NULL);
      ts_push_primitive(TypeUnsigned64, cast ptr<Type> NULL);
      store64 + ast Ast.konst 0;
    }
    else if eq token_type T_DEREF_WORD {
      let type : Type = 0;
      ts_pop(at type);
      let deflated_type : Type = 0;
      type_deflate(at type, at deflated_type);
      if neq type_base(at deflated_type) TypeNone {
        ts_push(at deflated_type, cast ptr<Type> NULL);
      }
      else {
        typecheck_error_at(+ ast Ast.token, "can not dereference this type\n", NULL);
      }
      store64 + ast Ast.konst 0;
    }
    else if eq token_type T_LOGICAL_NOT {
      let value : Value = 0;
      { let _ = vs_pop(at value); }
      store64 + @value Value.num not load64 + @value Value.num;
      { let _ = vs_push(at value); }
    }
    else if eq token_type T_NOT {
      let value : Value = 0;
      { let _ = vs_pop(at value); }
      store64 + @value Value.num ~ load64 + @value Value.num;
      { let _ = vs_push(at value); }
    }
  }
  else {
    typecheck_error("no value was produced in the rhs of the unary expression\n");
  }
  load64 + c Compile.status;
}

fn typecheck_func_definition(block : ptr<Block>, fs : ptr<Function>, ast : ptr) -> u64 {
  if eq cast u64 block + c Compile.global {
    let params = cast ptr load64 + + ast Ast.node * sizeof ptr 0;
    let body = cast ptr load64 + + ast Ast.node * sizeof ptr 1;
    let rtype_node : ptr = NULL;
    if eq load64 + ast Ast.count 3 {
      store64 @rtype_node load64 + + ast Ast.node * sizeof ptr 2;
    }

    let explicit_rtype : Type = 0;
    type_init(at explicit_rtype, TypeNone, 0, 0, 1);

    let argc : u64 = load64 + params Ast.count;
    if or eq argc MAX_FUNC_ARGC < argc MAX_FUNC_ARGC { // argc <= MAX_FUNC_ARGC
      let symbol : ptr = NULL;
      let symbol_index : u64 = UINT64_MAX;
      if eq compile_declare_value(block, fs, + ast Ast.token, @symbol, @symbol_index) NoError {
        let local_block = block_push(cast ptr<Block> block);
        let type : Type = 0;
        type_init(at type, TypeFunc, symbol_index, sizeof ptr, 1);
        let type_size : u64 = compile_type_size(TypeFunc);

        store64 + symbol Symbol.imm UINT64_MAX;
        store64 + symbol Symbol.size type_size;
        store64 + symbol Symbol.konst 0;
        store64 + symbol Symbol.sym_type SYM_FUNC;
        memcpy(+ symbol Symbol.type, at type, sizeof Type);
        store64 + + ast Ast.token Token.v symbol_index;
        memcpy(+ symbol Symbol.token, + ast Ast.token, sizeof Token);
        let value = cast ptr<Value> + symbol Symbol.value;
        store64 + value Value.konst 0;
        let func = cast ptr<Function> + value Value.func;
        function_init(func);
        store64 + func Function.ir_address UINT64_MAX;
        store64 + func Function.label symbol_index;
        store64 + func Function.argc argc;
        store64 + func Function.locals_offset 0;
        type_init(cast ptr<Type> + func Function.rtype, TypeNone, 0, type_size, 1);

        let new_type_id : u64 = type_commit_new(at type); // TODO(lucas): handle error

        if neq rtype_node NULL {
          if eq type_contract_from_type_node(block, fs, rtype_node, TYPE_CONTRACT_CREATE, at explicit_rtype, 1) NoError {
            memcpy(+ func Function.rtype, at explicit_rtype, sizeof Type);
          }
          else {
            typecheck_error_at(+ rtype_node Ast.token, "unknown or invalid return type in function definition\n", NULL);
          }
        }

        let i : u64 = 0;
        let fail : u64 = 0;
        while and eq fail 0 < i argc {
          let arg_node = cast ptr load64 + + params Ast.node * sizeof ptr i;
          let arg : Token = 0;
          let arg_type_token : Token = 0;
          memcpy(@arg, + arg_node Ast.token, sizeof Token);
          memcpy(@arg_type_token, + load64 + + arg_node Ast.node * sizeof ptr 0 Ast.token, sizeof Token);

          let arg_symbol : ptr = NULL;
          let arg_symbol_index : u64 = UINT64_MAX;
          if eq compile_declare_value(local_block, func, @arg, @arg_symbol, @arg_symbol_index) NoError {
            store64 + + func Function.args * sizeof u64 i arg_symbol_index;
            let arg_type : Type = 0;

            let arg_type_node : ptr = cast ptr load64 + + arg_node Ast.node * sizeof ptr 0;
            if eq type_contract_from_type_node(block, fs, arg_type_node, TYPE_CONTRACT_CREATE, at arg_type, 0) NoError {
              let arg_type_id : u64 = type_lookup(at arg_type);
              assert(neq arg_type_id UINT64_MAX, "invalid type\n");
              let size : u64 = compile_type_size(arg_type_id);
              if eq type_base(at arg_type) TypeStruct {
                store64 @size compile_type_size(arg_type_id);
                if > size MAX_STRUCT_SIZE {
                  let args : any = MAX_STRUCT_SIZE;
                  typecheck_error_at(@arg_type_token, "can not have a parameter of type struct with a greater size than %d\n", @args);
                  store64 @fail 1;
                }
              }
              if eq fail 0 {
                store64 + arg_symbol Symbol.imm UINT64_MAX;
                store64 + arg_symbol Symbol.size size;
                store64 + arg_symbol Symbol.konst 0;
                store64 + arg_symbol Symbol.sym_type SYM_FUNC_ARG;
                memcpy(+ arg_symbol Symbol.type, at arg_type, sizeof Type);
                memcpy(+ arg_symbol Symbol.token, @arg, sizeof Token);
                store64 + + arg_symbol Symbol.token Token.v i; // TODO(lucas): store argument index in symbol value field instead
              }
            }
            else {
              typecheck_error_at(@arg_type_token, "unknown or invalid type\n", NULL);
            }
          }
          else {
            compile_error_at(@arg, "duplicate argument name\n");
            store64 @fail 1;
          }
          store64 @i + 1 i;
        }

        let ts_count : u64 = load64 + c Compile.ts_count;
        let func_body_block = block_push(local_block);

        { let _ = typecheck_node_list(func_body_block, fs, body); }
        let konst_body : u64 = is_branch_konst_eval(body);
        store64 + body Ast.konst konst_body;
        store64 + ast Ast.konst konst_body;
        store64 + + symbol Symbol.value Value.konst konst_body;

        let rtype : Type = 0;
        type_init(at rtype, TypeNone, 0, 0, 1);
        let ts_delta : u64 = - load64 + c Compile.ts_count ts_count;
        if > ts_delta 1 {
          typecheck_error_at(+ ast Ast.token, "too many values produced by function\n", NULL);
        }
        else {
          if neq ts_delta 0 {
            { let _ = vs_pop(cast ptr<Value> NULL); }
            ts_pop(at rtype);
          }

          if rtype_node {
            if and neq types_are_equal(at explicit_rtype, at rtype) 1 neq type_base(at explicit_rtype) TypeAny {
              // TODO(lucas): more detailed error message
              compile_error_at(+ rtype_node Ast.token, "function returns a value that does not match the return type\n");
            }
          }
          // type inference for the return type
          else {
            memcpy(+ func Function.rtype, at rtype, sizeof Type);
          }

          if eq strncmp(cast cstr + symbol Symbol.name, "main", MAX_NAME_SIZE) 0 {
            store64 + symbol Symbol.ref_count + load64 + symbol Symbol.ref_count 1;
            store64 + c Compile.entry_point + load64 + c Compile.entry_point 1;
          }
        }
        block_pop(); // func_body_block
        block_pop(); // local_block
      }
      else {
        compile_error_at(+ ast Ast.token, "symbol already exists\n");
      }
    }
    else {
      let message = cast cstr tmp_it;
      sprintf(cast ptr message, "reached function parameter count limit of %d\n", @MAX_FUNC_ARGC);
      compile_error_at(+ ast Ast.token, message);
    }
  }
  else {
    compile_error_at(+ ast Ast.token, "functions are only permitted to be defined in the global block\n");
  }
  load64 + c Compile.status;
}

fn typecheck_func_call(block : ptr<Block>, fs : ptr<Function>, ast : ptr) -> u64 {
  let symbol : ptr = NULL;
  let symbol_index : u64 = UINT64_MAX;
  let token_buffer : Buffer = 0;
  buffer_init(at token_buffer, cast ptr load64 + + ast Ast.token Token.buffer, load64 + + ast Ast.token Token.length);
  if eq compile_lookup_value(block, fs, @token_buffer, @symbol, @symbol_index, NULL) NoError {
    store64 + symbol Symbol.ref_count + 1 load64 + symbol Symbol.ref_count;
    store64 + + ast Ast.token Token.v symbol_index;
    let arg_list = cast ptr load64 + + ast Ast.node * sizeof ptr 0;
    let func = cast ptr<Function> + + symbol Symbol.value Value.func;
    let type : Type = 0;
    memcpy(at type, + symbol Symbol.type, sizeof Type);
    if or eq type_base(at type) TypeFunc eq type_base(at type) TypeSyscallFunc {
      let argc : u64 = load64 + func Function.argc;
      if eq argc load64 + arg_list Ast.count {
        store64 + + symbol Symbol.token Token.v symbol_index; // TODO(lucas): store this in the symbol value field, or someplace else
        let done : u64 = 0;
        let i : u64 = - argc 1;
        if > argc 0 {
          while eq done 0 {
            let node = cast ptr load64 + + arg_list Ast.node * sizeof ptr i;
            { let _ = _typecheck(block, fs, node); }
            let arg_in_type : Type = 0;
            ts_top(at arg_in_type);

            if eq type_base(at type) TypeSyscallFunc {
              // any type is allowed here
              // we still want to type check the arguments of the call
              // which is why this is here instead of outside the loop
            }
            else {
              // Symbol* arg = &c->symbols[func->args[i]];
              let arg_symbol_index : u64 = load64 + + func Function.args * sizeof u64 i;
              let arg = cast ptr + + c Compile.symbols * sizeof Symbol arg_symbol_index;
              let arg_type : Type = 0;
              memcpy(at arg_type, + arg Symbol.type, sizeof Type);

              if and
                  neq types_are_equal(at arg_type, at arg_in_type) 1
                  neq type_base(at arg_type) TypeAny {
                {
                  // TODO(lucas): error message type strings
                  typecheck_error_at(+ node Ast.token, "type mismatch in function call, got `?`, but `?` was expected\n", NULL);
                }
                store64 + c Compile.status NoError; // to print additional error message
                {
                  let args : any = + symbol Symbol.name;
                  typecheck_error_at(+ arg Symbol.token, "from function `%s`\n", @args);
                }
                store64 @done 1;
              }
            }
            { let _ = vs_pop(cast ptr<Value> NULL); }
            ts_pop(cast ptr<Type> NULL);
            if eq i 0 {
              store64 @done 1;
            }
            else {
              store64 @i - i 1;
            }
          }
        }

        let rtype : Type = 0;
        memcpy(at rtype, + func Function.rtype, sizeof Type);
        if neq type_base(at rtype) TypeNone {
          store64 + + symbol Symbol.value Value.konst 0;  // NOTE(lucas): temporary (why?)
          store64 + ast Ast.konst load64 + + symbol Symbol.value Value.konst;
          { let _ = vs_push(cast ptr<Value> + symbol Symbol.value); }
          ts_push(at rtype, cast ptr<Type> NULL);
        }
      }
      else {
        let message = cast cstr tmp_it;
        tmp_push_cstr("function `");
        tmp_push_cstr(cast cstr + symbol Symbol.name);
        tmp_push_cstr("` takes ");
        tmp_push_u64(load64 + func Function.argc);
        tmp_push_cstr(" argument(s), but ");
        tmp_push_u64(load64 + arg_list Ast.count);
        tmp_push_cstr(" was given\n");
        tmp_push_byte(cast u8 0);
        compile_error_at(+ ast Ast.token, message);
        store64 @tmp_it message;
      }
    }
    else {
      let type : Type = 0;
      memcpy(at type, + symbol Symbol.type, sizeof Type);
      // TODO(lucas): error message type strings
      typecheck_error_at(+ ast Ast.token, "function calls of type `?` is not permitted\n", NULL);
    }
  }
  else {
    let message = tmp_it;
    tmp_push_cstr("symbol `");
    tmp_push_str(cast cstr load64 + @token_buffer Buffer.data, load64 + @token_buffer Buffer.length);
    tmp_push_cstr("` not defined\n");
    tmp_push_byte(cast u8 0);
    compile_error_at(+ ast Ast.token, cast cstr message);
    store64 @tmp_it message;
  }
  load64 + c Compile.status;
}

fn typecheck_while_statement(block : ptr<Block>, fs : ptr<Function>, ast : ptr) -> u64 {
  let cond = cast ptr load64 + + ast Ast.node * sizeof ptr 0;
  let body = cast ptr load64 + + ast Ast.node * sizeof ptr 1;
  { let _ = _typecheck(block, fs, cond); }
  let type : Type = 0;
  ts_pop(at type); // pop type of condition result
  { let _ = vs_pop(cast ptr<Value> NULL); } // pop value of condition result
  if or or eq type_base(at type) TypeCString eq type_base(at type) TypePtr is_numerical(at type) {
    let local_block = block_push(cast ptr<Block> block);
    { let _ = _typecheck(local_block, fs, body); }
    block_pop(); // local_block
    store64 + ast Ast.konst is_branch_konst_eval(ast);
  }
  else {
    typecheck_error_at(+ cond Ast.token, "invalid type in while statement condition\n", NULL);
  }
  load64 + c Compile.status;
}

fn typecheck_if_statement(block : ptr<Block>, fs : ptr<Function>, ast : ptr) -> u64 {
  let cond = cast ptr load64 + + ast Ast.node * sizeof ptr 0;
  let body = cast ptr load64 + + ast Ast.node * sizeof ptr 1;
  { let _ = _typecheck(block, fs, cond); }
  let cond_konst = is_branch_konst_eval(cond);
  store64 + cond Ast.konst cond_konst;

  let type : Type = 0;
  ts_pop(at type); // pop type of condition result
  let value : Value = 0;
  { let _ = vs_pop(at value); } // pop value of condition result

  if or or eq type_base(at type) TypeCString eq type_base(at type) TypePtr is_numerical(at type) {
    let collapse = 0;
    if cond_konst {
      let else_body = NULL;
      if eq ast_child_count(ast) 3 {
        store64 @else_body load64 + + ast Ast.node * sizeof ptr 2;
      }
      if neq load64 + at value Value.num 0 {
        // if statement condition is true, remove potential else branch
        // move body of if statement to the current ast branch
        if else_body {
          ast_pop(ast); // remove else body branch
        }
        ast_move(ast, body);
        { let _ = _typecheck(block, fs, ast); } // typecheck if body
      }
      else if else_body {
        // if statement condition is false, move body of potential else to the current ast branch
        ast_move(ast, else_body);
        { let _ = _typecheck(block, fs, ast); } // typecheck else body
      }
      store64 @collapse 1;
    }

    if eq collapse 0 {
      let local_block = block_push(block);
      { let _ = _typecheck(local_block, fs, body); }
      block_pop(); // local_block

      if eq load64 + ast Ast.count 3 {
        let else_body = cast ptr load64 + + ast Ast.node * sizeof ptr 2;
        let else_local_block = block_push(block);
        { let _ = _typecheck(else_local_block, fs, else_body); }
        block_pop(); // else_local_block
      }
    }
    store64 + ast Ast.konst is_branch_konst_eval(ast);
  }
  else {
    typecheck_error_at(+ cond Ast.token, "invalid type in if statement condition\n", NULL);
  }
  load64 + c Compile.status;
}

// AST representation:
// LetStatement
//   ExprList
//     Expression
//     ...
//   Type
//     None | Value (array specifier)
//     Type (optional sub type)
// TODO(lucas): simplify
fn typecheck_let_statement(block : ptr<Block>, fs : ptr<Function>, ast : ptr) -> u64 {
  let result = NoError;
  let konst = eq load64 + ast Ast.type AstConstStatement;
  let ts_count = load64 + c Compile.ts_count;
  let num_elements = 1;
  let rhs = cast ptr load64 + + ast Ast.node * sizeof ptr 0;
  let ast_type = NULL;
  if eq load64 + ast Ast.count 2 {
    store64 @ast_type cast ptr load64 + + ast Ast.node * sizeof ptr 1;
  }

  // typecheck the rhs of the statement
  { let _ = typecheck_node_list(block, fs, rhs); }
  store64 + rhs Ast.konst is_branch_konst_eval(rhs);
  store64 + ast Ast.konst is_branch_konst_eval(rhs);

  // make sure that rhs actually produced any values
  let ts_delta = - load64 + c Compile.ts_count ts_count;
  if eq ts_delta 0 {
    typecheck_error_at(+ ast Ast.token, "no value was produced in the rhs of the let statement\n", NULL);
  }
  else {
    // typecheck explicit type, if there is one
    let explicit_type : Type = 0;
    type_init(at explicit_type, TypeNone, 0, 0, 1);

    // for if the type is a function
    let explicit_type_value : Value = 0;

    if neq ast_type NULL {
      if eq type_contract_from_type_node(block, fs, ast_type, TYPE_CONTRACT_CREATE, at explicit_type, 0) NoError {
        if eq type_base(at explicit_type) TypeFunc {
          let id = type_sub_id(at explicit_type);
          let expl_type_symbol = cast ptr<Symbol> + + c Compile.symbols * sizeof Symbol id;
          memcpy(at explicit_type_value, + expl_type_symbol Symbol.value, sizeof Value);
        }
        store64 @num_elements load64 + at explicit_type Type.count;
        if and > num_elements 1 > ts_delta num_elements {
          typecheck_error_at(cast ptr + load64 + rhs Ast.node Ast.token, "number of elements in rhs exceeded the array size specifier\n", NULL);
        }
      }
      else {
        typecheck_error_at(cast ptr + ast_type Ast.token, "invalid type construction\n", NULL);
      }
    }

    let imm = UINT64_MAX; // index to immediate value, in case this is a constant

    let value : Value = 0;
    let prev_value : Value = 0;
    vs_top(at value);
    vs_top(at prev_value);

    let type : Type = 0;
    ts_top(at type);
    let prev_type : Type = 0;
    ts_top(at prev_type);

    if neq type_base(at explicit_type) TypeNone {
      memcpy(at prev_type, at explicit_type, sizeof Type);
      if eq type_base(at explicit_type) TypeFunc {
        memcpy(@prev_value, @explicit_type_value, sizeof Value);
      }
    }

    let i = 0;
    let done = 0;
    while and not done < i ts_delta {
      ts_pop(at type);
      { let _ = vs_pop(at value); }
      if or eq type_base(at explicit_type) TypeStruct eq type_base(at explicit_type) TypeAny {
        // do nothing, all is permitted here
      }
      else {
        if and eq type_base(at type) TypeFunc eq type_base(at prev_type) TypeFunc {
          if eq check_func_signatures(cast ptr<Function> + at value Value.func, cast ptr<Function> + at prev_value Value.func) 0 {
            typecheck_error_at(+ ast Ast.token, "incompatible type in expression list\n", NULL);
            store64 @done 1;
          }
        }
        else if and is_numerical(at explicit_type) is_numerical(at type) {
          // do nothing, this is ok
        }
        else if eq types_are_equal(at type, at prev_type) 0 {
          typecheck_error_at(+ ast Ast.token, "incompatible type in expression list\n", NULL);
          store64 @done 1;
        }
        memcpy(at prev_type, at type, sizeof Type);
      }
      memcpy(@prev_value, @value, sizeof Value);
      if eq konst 1 {
        if is_numerical(at type) {
          store64 @imm compile_push_value(+ @value Value.num, sizeof u64);
        }
        else {
          typecheck_error_at(+ ast Ast.token, "only numeric values are allowed in constants\n", NULL);
          store64 @done 1;
        }
      }
      store64 @i + 1 i;
    }

    // no array specifier was used, therefore num_elements is set to however many elements there was in the rhs
    if eq num_elements 1 {
      store64 @num_elements ts_delta;
      if > num_elements 1 {
        let contract : Type = 0;
        // check if explicit type is defined, when array specifier is not
        if neq type_base(at explicit_type) TypeNone {
          // here the array element count is inferred only
          memcpy(at contract, at explicit_type, sizeof Type);
        }
        // otherwise infer a new array-based type,
        // based on the most recently used array element type of the rhs (does not really matter which element that is selected as they are all constrained to be of the same type)
        else {
          memcpy(at contract, at type, sizeof Type);
        }
        store64 + at contract Type.count num_elements;
        let inferred_type : Type = 0;
        { let _ = type_from_contract(at contract, 1, TYPE_CONTRACT_CREATE, at inferred_type); } // TODO(lucas): handle error
        memcpy(at explicit_type, at inferred_type, sizeof Type);
      }
    }

    if neq type_base(at explicit_type) TypeNone {
      memcpy(at type, at explicit_type, sizeof Type);
    }

    // if this is a constant, make sure to update the immediate value index
    if eq konst 1 {
      let decrement = * sizeof u64 - ts_delta 1;
      store64 @imm - imm decrement;
    }

    let type_count : u64 = load64 + at type Type.count;
    let type_size : u64 = load64 + at type Type.size;

    let symbol : ptr = NULL;
    let symbol_index = UINT64_MAX;
    if eq compile_declare_value(block, fs, + ast Ast.token, @symbol, @symbol_index) NoError {
      store64 + symbol Symbol.imm imm;
      store64 + symbol Symbol.size * type_count type_size;
      store64 + symbol Symbol.num_elements_init ts_delta;
      store64 + symbol Symbol.konst konst;
      if eq cast u64 block + c Compile.global {
        store64 + symbol Symbol.sym_type SYM_GLOBAL_VAR;
      }
      else {
        store64 + symbol Symbol.sym_type SYM_LOCAL_VAR;
      }
      store64 + at value Value.konst konst;
      memcpy(+ symbol Symbol.type, at type, sizeof Type);
      memcpy(+ symbol Symbol.value, @value, sizeof Value);
      store64 + + symbol Symbol.token Token.v symbol_index;
      store64 + + ast Ast.token Token.v symbol_index;
    }
  }
  result;
}

fn typecheck_struct(block : ptr<Block>, fs : ptr<Function>, ast : ptr) -> u64 {
  let fields = cast ptr load64 + + ast Ast.node * sizeof ptr 0;
  let field_offset : u64 = 0;
  let i : u64 = 0;
  let count : u64 = load64 + fields Ast.count;
  let fail : u64 = 0;

  let struct_name : Buffer = 0;
  buffer_init(
    at struct_name,
    cast ptr load64 + + ast Ast.token Token.buffer,
    load64 + + ast Ast.token Token.length
  );
  let type_info : Struct_type_info = 0;
  struct_type_info_init(at type_info);
  let struct_type_field : Struct_field = 0;

  while and eq fail 0 < i count {
    let field = cast ptr load64 + + fields Ast.node * sizeof ptr i;
    let field_type_node = cast ptr load64 + + field Ast.node * sizeof ptr 0; // type + array specifier
    let field_name = cast cstr load64 + + field Ast.token Token.buffer;
    let field_length = load64 + + field Ast.token Token.length;

    let it = tmp_it;
    tmp_push_str(cast cstr load64 + at struct_name Buffer.data, load64 + at struct_name Buffer.length);
    tmp_push_cstr(".");
    tmp_push_str(load64 + + field Ast.token Token.buffer, load64 + + field Ast.token Token.length);

    store64 + + field Ast.token Token.buffer it;
    store64 + + field Ast.token Token.length - tmp_it it;

    let symbol : ptr = NULL;
    let symbol_index : u64 = UINT64_MAX;
    let imm : u64 = compile_push_value(@field_offset, sizeof field_offset);
    let value : Value = 0;
    store64 + @value Value.num field_offset;
    store64 + @value Value.konst 1;

    if eq compile_declare_value(block, fs, + field Ast.token, @symbol, @symbol_index) NoError {
      store64 + symbol Symbol.imm imm;
      store64 + symbol Symbol.size sizeof u64;
      store64 + symbol Symbol.konst 1;
      if eq cast u64 block + c Compile.global {
        store64 + symbol Symbol.sym_type SYM_GLOBAL_VAR;
      }
      else {
        store64 + symbol Symbol.sym_type SYM_LOCAL_VAR;
      }
      type_init(cast ptr<Type> + symbol Symbol.type, TypeUnsigned64, 0, sizeof u64, 1);
      memcpy(+ symbol Symbol.value, @value, sizeof Value);

      let field_size : u64 = 0;
      let field_type : Type = 0;

      if eq type_contract_from_type_node(block, fs, field_type_node, TYPE_CONTRACT_CREATE, at field_type, 0) NoError {
        let type_id : u64 = type_lookup(at field_type);
        store64 @field_size compile_type_size(type_id);
      }
      else {
        typecheck_error_at(+ field_type_node Ast.token, "unknown or invalid type in struct field\n", NULL);
      }

      store64 @field_size * load64 + at field_type Type.size load64 + at field_type Type.count;

      // done constructing this struct field
      if eq fail 0 {
        { let _ = struct_field_init(at struct_type_field, cast ptr<u8[MAX_NAME_SIZE]> field_name, field_length, at field_type, field_offset); }
        { let _ = struct_create_field(at type_info, at struct_type_field); }
      }

      // update field offset
      store64 @field_offset + field_offset field_size;
    }
    else {
      compile_error_at(+ field Ast.token, "symbol already exists\n");
      store64 @fail 1;
    }
    store64 @i + 1 i;
  }
  // struct symbol definition
  let symbol : ptr = NULL;
  let symbol_index : u64 = UINT64_MAX;
  let value : Value = 0;
  memset(@value, 0, sizeof Value);

  if eq compile_declare_value(block, fs, + ast Ast.token, @symbol, @symbol_index) NoError {
    store64 + symbol Symbol.imm UINT64_MAX;
    store64 + symbol Symbol.size field_offset;
    store64 + symbol Symbol.konst 0;
    if eq cast u64 block + c Compile.global {
      store64 + symbol Symbol.sym_type SYM_GLOBAL_VAR;
    }
    else {
      store64 + symbol Symbol.sym_type SYM_LOCAL_VAR;
    }
    let type : Type = 0;
    type_init(
      at type,
      TypeStruct,
      load64 + c Compile.struct_id,
      field_offset, // size
      1
    );
    { let _ = struct_type_push(at type_info); }
    memcpy(+ symbol Symbol.type, at type, sizeof Type);
    memcpy(+ symbol Symbol.value, @value, sizeof Value);

    let new_type_id : u64 = type_commit_new(at type); // TODO(lucas): handle error
  }
  else {
    compile_error_at(+ ast Ast.token, "symbol already exists\n");
  }
  load64 + c Compile.status;
}

// FIELD ACCESS
//
// the typechecker is only concerned with the final field that is going to be accessed,
// however the ir code generator needs information about how to actually access that field.
// if an intermediate field is a pointer to some data, that pointer needs to be accessed in some way.
//
// typechecker needs:
//    - type of the accessed field, to be pushed onto the type stack, and that's it.
// ir needs:
//    - (at minimum): type of field, offset to said field
//    - (at most): a stack of intermediate fields (or some other representation), containing the offsets and types of those fields.
//        that way, the ir knows how to generate code to access the data of the field in question.
//
// example:
//
// struct B (
//    x : u64,
//    y : u64
// );
//
// struct A (
//    a : u64,
//    b : ptr<B>
// );
//
// fn hello -> none {
//    let a : A = 0;
//    print :a:b:x;
//    print load64 + (load64 + at a A.b) 8; // :a:b:y
// }
//
// the generated code for `:a:b:x` would be along the lines of:
//    I_PUSH_LOCAL 8 | as :a is on the stack we can directly access :b from here (offset of 8 will point to A.b)
//    I_PUSH_IMM   8 | we want to access B.y, which has an offset of 8
//    I_ADD          | add that offset to the pointer of A.b
//    I_LOADx        | load y based on its type
//                   | we're done
//
fn typecheck_field_access(block : ptr<Block>, fs : ptr<Function>, ast : ptr, type_context : ptr<Type_context>) -> u64 {
  let symbol = NULL;
  let symbol_id = UINT64_MAX;
  let buffer : Buffer = 0;
  buffer_init(at buffer, cast ptr load64 + + ast Ast.token Token.buffer, load64 + + ast Ast.token Token.length);
  if eq compile_lookup_value(block, fs, @buffer, @symbol, @symbol_id, NULL) NoError {
    store64 + type_context Type_context.symbol_id symbol_id;
    let type = cast ptr<Type> + symbol Symbol.type;
    if eq type_base(type) TypeStruct {
      let field_nodes = cast ptr + ast Ast.node;
      let i = 0;
      let count = load64 + ast Ast.count;

      let struct_type_info = struct_fetch_type_info(type_sub_id(type));
      let struct_field = cast ptr<Struct_field> NULL;
      let offset = 0;

      while < i count {
        let node = cast ptr load64 + field_nodes * sizeof ptr i;
        let field_name : u8[MAX_NAME_SIZE] = 0;
        memset(at field_name, 0, sizeof field_name);
        memcpy(at field_name, load64 + + node Ast.token Token.buffer, load64 + + node Ast.token Token.length);
        store64 at struct_field struct_lookup_field(struct_type_info, at field_name);
        if struct_field {
          store64 @offset + offset load64 + struct_field Struct_field.offset;
          store64 @type + struct_field Struct_field.type;
          if eq type_base(type) TypeStruct {
            // update struct_type_info as this field is a struct
            store64 @struct_type_info struct_fetch_type_info(type_sub_id(type));
          }
        }
        else {
          let args : any = at field_name;
          typecheck_error_at(+ node Ast.token, "struct `?` has no field named `%s`\n", @args);
        }
        store64 @i + 1 i;
      }

      if type_context {
        memcpy(+ type_context Type_context.type, type, sizeof Type);
        store64 + type_context Type_context.offset offset;
      }
    }
    else {
      typecheck_error_at(+ ast Ast.token, "field access is only allowed on struct types\n", NULL);
    }
  }
  else {
    compile_error_at(+ ast Ast.token, "symbol not defined\n");
  }
  load64 + c Compile.status;
}

fn typecheck(block : ptr<Block>, fs : ptr<Function>, ast : ptr) -> u64 {
  if eq load64 + c Compile.status NoError {
    let ast_type = load64 + ast Ast.type;
    if eq ast_type AstValue {
      let _ = typecheck_value(block, fs, ast);
    }
    else if eq ast_type AstExpression {
      { let _ = typecheck(block, fs, cast ptr load64 + + ast Ast.node * sizeof ptr 0); }
      let konst = is_branch_konst_eval(ast);
      store64 + ast Ast.konst konst;
    }
    else if or or eq ast_type AstExprList eq ast_type AstStatement eq ast_type AstStatementList {
      let _ = typecheck_node_list(block, fs, ast);
      let konst = is_branch_konst_eval(ast);
      store64 + ast Ast.konst konst;
    }
    else if eq ast_type AstBinopExpression {
      let _ = typecheck_binop_expr(block, fs, ast);
    }
    else if eq ast_type AstUopExpression {
      let _ = typecheck_uop_expr(block, fs, ast);
    }
    else if or eq ast_type AstLetStatement eq ast_type AstConstStatement {
      { let _ = typecheck_let_statement(block, fs, ast); }
    }
    else if eq ast_type AstBlockStatement {
      let local_block = block_push(cast ptr<Block> block);
      { let _ = typecheck_node_list(local_block, fs, ast); }
      block_pop();
      store64 + ast Ast.konst is_branch_konst_eval(ast);
    }
    else if eq ast_type AstFuncDefinition {
      let _ = typecheck_func_definition(block, fs, ast);
    }
    else if eq ast_type AstFuncCall {
      let _ = typecheck_func_call(block, fs, ast);
    }
    else if eq ast_type AstWhileStatement {
      let _ = typecheck_while_statement(block, fs, ast);
    }
    else if eq ast_type AstIfStatement {
      let _ = typecheck_if_statement(block, fs, ast);
    }
    else if eq ast_type AstAssignment {
      let first = cast ptr load64 + + ast Ast.node * sizeof ptr 0;
      let second = cast ptr load64 + + ast Ast.node * sizeof ptr 1;
      { let _ = typecheck(block, fs, first); }
      let a : Type = 0;
      ts_pop(at a);
      { let _ = typecheck(block, fs, second); }
      if or eq type_base(at a) TypePtr eq type_base(at a) TypeAny {
        ts_pop(cast ptr<Type> NULL);
        { let _ = vs_pop(cast ptr<Value> NULL); }
        { let _ = vs_pop(cast ptr<Value> NULL); }
      }
      else {
        typecheck_error_at(+ first Ast.token, "type mismatch in assignment statement\n", NULL);
      }
    }
    else if eq ast_type AstSizeof {
      // t : ptr<Token>
      let t = cast ptr + ast Ast.token;
      let size : u64 = 0;
      let token_type = load64 + t Token.type;
      if or eq token_type T_UNSIGNED64 eq token_type T_NUMBER {
        store64 @size sizeof u64;
      }
      else if eq token_type T_UNSIGNED32 {
        store64 @size sizeof u32;
      }
      else if eq token_type T_UNSIGNED16 {
        store64 @size sizeof u16;
      }
      else if eq token_type T_UNSIGNED8 {
        store64 @size sizeof u8;
      }
      else if or or or
        eq token_type T_PTR
        eq token_type T_CSTRING
        eq token_type T_CSTR
        eq token_type T_ANY {
        store64 @size sizeof ptr;
      }
      else if eq token_type T_IDENTIFIER {
        let symbol = NULL;
        let buffer : Buffer = 0;
        buffer_init(at buffer, cast ptr load64 + t Token.buffer, load64 + t Token.length);
        if eq compile_lookup_value(block, fs, @buffer, @symbol, NULL, NULL) NoError {
          let type = cast ptr<Type> + symbol Symbol.type;
          store64 @size * load64 + type Type.count load64 + type Type.size;
        }
        else {
          typecheck_error_at(cast ptr t, "symbol not defined\n", NULL);
        }
      }
      else {
        assert(0, "type not implemented yet\n");
      }
      let value : Value = 0;
      store64 + @value Value.num size;
      store64 + @value Value.konst 1;
      { let _ = vs_push(at value); }
      store64 + t Token.v size;
      store64 + ast Ast.konst 1;
      ts_push_primitive(TypeUnsigned64, cast ptr<Type> NULL);
    }
    else if eq ast_type AstEnum {
      let type_node = cast ptr load64 + + ast Ast.node * sizeof ptr 0;
      let enum_node = cast ptr load64 + + ast Ast.node * sizeof ptr 1;
      let value : Value = 0;
      store64 + @value Value.num 0;
      store64 + @value Value.konst 1;
      let i : u64 = 0;
      let count : u64 = load64 + enum_node Ast.count;

      let type : Type = 0;
      token_to_compile_type(block, fs, + type_node Ast.token, NULL, at type);
      if is_numerical(at type) {
        while < i count {
          let node = cast ptr load64 + + enum_node Ast.node * sizeof ptr i;
          let symbol : ptr = NULL;
          let symbol_index : u64 = UINT64_MAX;
          let imm : u64 = compile_push_value(+ @value Value.num, sizeof u64);

          if eq compile_declare_value(block, fs, + node Ast.token, @symbol, @symbol_index) NoError {
            store64 + symbol Symbol.imm imm;
            store64 + symbol Symbol.size compile_type_size(type_base(at type));
            store64 + symbol Symbol.konst 1;
            if eq cast u64 block + c Compile.global {
              store64 + symbol Symbol.sym_type SYM_GLOBAL_VAR;
            }
            else {
              store64 + symbol Symbol.sym_type SYM_LOCAL_VAR;
            }
            memcpy(+ symbol Symbol.type, at type, sizeof Type);
            memcpy(+ symbol Symbol.value, @value, sizeof Value);
          }
          else {
            compile_error_at(+ node Ast.token, "symbol already exists\n");
          }

          store64 + @value Value.num + 1 load64 + @value Value.num;
          store64 @i + 1 i;
        }
      }
      else {
        typecheck_error_at(+ type_node Ast.token, "expected numerical type in enumerator expression\n", NULL);
      }
    }
    else if eq ast_type AstStruct {
      let _ = typecheck_struct(block, fs, ast);
    }
    else if eq ast_type AstCastExpression {
      let type_expr = cast ptr load64 + + ast Ast.node * sizeof ptr 0;
      let expr = cast ptr load64 + + ast Ast.node * sizeof ptr 1;
      { let _ = typecheck(block, fs, expr); }
      let expr_type : Type = 0;
      ts_pop(at expr_type);
      let cast_type : Type = 0;
      { let _ = type_contract_from_type_node(block, fs, type_expr, TYPE_CONTRACT_CREATE, at cast_type, 0); }
      if and neq type_base(at cast_type) TypeNone neq type_base(at cast_type) TypeFunc {
        ts_push(at cast_type, cast ptr<Type> NULL);
      }
      else {
        // TODO(lucas): error message type strings
        typecheck_error_at(+ type_expr Ast.token, "cannot cast from type `?` to `?`\n", NULL);
      }
    }
    else if eq ast_type AstStaticAssert {
      let expr = cast ptr load64 + + ast Ast.node * sizeof ptr 0;
      let node = cast ptr load64 + + ast Ast.node * sizeof ptr 1;
      { let _ = typecheck(block, fs, expr); }
      ts_pop(cast ptr<Type> NULL);
      let value : Value = 0;
      { let _ = vs_pop(at value); }
      if eq load64 + @value Value.konst 0 {
        typecheck_error("can not do static assert on an expression that is evaluated at runtime\n");
      }
      else if eq load64 + @value Value.num 0 {
        let node_token = cast ptr + node Ast.token;
        let message = cast cstr tmp_it;
        tmp_push_cstr("[static assertion failed]: ");
        tmp_push_str(load64 + node_token Token.buffer, load64 + node_token Token.length);
        tmp_push_cstr("\n");
        tmp_push_byte(cast u8 0);
        compile_error_at(+ expr Ast.token, message);
        store64 @tmp_it message;
      }
    }
    else if eq ast_type AstFieldAccess {
      let type_context : Type_context = 0;
      type_context_init(at type_context);
      if eq typecheck_field_access(block, fs, ast, at type_context) NoError {
        let id = type_context_push(at type_context);
        if neq id UINT64_MAX {
          store64 + ast Ast.type_context_id id;
          ts_push(cast ptr<Type> + at type_context Type_context.type, cast ptr<Type> NULL);
          let value : Value = 0;
          memset(at value, 0, sizeof Value);
          { let _ = vs_push(at value); }
        }
        else {
          assert(0, "failed to push type context\n"); // TODO(lucas): handle error
        }
      }
    }
    else {
      let message = cast cstr tmp_it;
      sprintf(cast ptr message, "unreachable AST node with id `%d`\n", @ast_type);
      assert(0, message);
    }
  }

  load64 + c Compile.status;
}

fn typecheck_program(ast : ptr) -> u64 {
  assert(cast u64 ast, "something went very wrong\n");
  store64 @_typecheck typecheck;
  store64 @_type_print type_print;
  store64 @_type_printline type_printline;

  let time_start : timespec = 0;
  let time_end : timespec = 0;
  { let _ = clock_gettime(CLOCK_MONOTONIC, at time_start); }

  let _ = typecheck(cast ptr<Block> + c Compile.global, cast ptr<Function> NULL, cast ptr load64 + + ast Ast.node * sizeof ptr 0);
  { let _ = clock_gettime(CLOCK_MONOTONIC, at time_end); }

  if neq load64 + c Compile.vs_count 0 {
    typecheck_error("unhandled data on the value stack\n");
  }

  if and neq load64 + c Compile.ts_count 0 eq load64 + c Compile.status NoError {
    typecheck_error("unhandled data on the type stack\n");
  }

  assert(eq load64 + c Compile.block_count 0, "block stack not empty\n");

  if eq load64 + c Compile.status NoError {
    print_time_elapsed("type checking took", @time_start, @time_end);
    typecheck_print_unused();
  }

  typecheck_print_stack(STDOUT_FILENO);

  load64 + c Compile.status;
}
