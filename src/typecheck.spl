// typecheck.spl

// TODO(lucas): temporary, allow passing and pushing structs of any size
const MAX_STRUCT_SIZE = sizeof u64;
const MAX_PUSH_SIZE = sizeof u64;
const DEFAULT_TYPE_BUFFER_SIZE = 256;

enum u64 (
  TYPE_CONTRACT_LOOKUP,
  TYPE_CONTRACT_CREATE
);

enum u64 (
  TYPE_CONSTRAINT_VALID, // valid constraint, we're good to continue
  TYPE_CONSTRAINT_INVALID // not a valid constraint, stop
);

fn typecheck_function(block: ptr<Block>, fs: ptr<Function>, ast: ptr) -> u64 0;
let _typecheck = typecheck_function;
fn type_print_func_sig(fd: u64, type: ptr<Type>) -> none {}
let _type_print = type_print_func_sig;
let _type_printline = type_print_func_sig;
fn type_write_to_buffer_func_sig(buffer: ptr<ptr>, size: ptr<u64>, type: ptr<Type>) -> none {}
let _type_write_to_buffer = type_write_to_buffer_func_sig;

let typecheck_funcs = cast typecheck_function[MAX_AST_TYPE] 0;

fn typecheck_print_unused -> none {
  if not load64 + @options Options.disable_dce {
    let i = MAX_SYSCALL_FUNCTION;
    let count = load64 + c Compile.symbol_count;
    while < i count {
      let symbol: Symbol = 0;
      memcpy(@symbol, + + c Compile.symbols * sizeof Symbol i, sizeof Symbol);
      let ref_count = load64 + @symbol Symbol.ref_count;
      let sym_type = load64 + @symbol Symbol.sym_type;
      if and eq ref_count 0 eq sym_type SYM_FUNC {
        let args: any = (
          + @symbol Symbol.name
        );
        warning_at(+ @symbol Symbol.token, "`%s` defined but not used\n", @args);
      }
      store64 @i + 1 i;
    }
  }
}

fn typecheck_error(message: cstr) -> none {
  if eq load64 + c Compile.status NoError {
    color_set(COLOR_ERROR);
    dprintf(STDERR_FILENO, "[typecheck-error]: ", null);
    color_reset();
    dprintf(STDERR_FILENO, "%s", @message);
    store64 + c Compile.status Error;
  }
  store64 + c Compile.error_count + 1 load64 + c Compile.error_count;
}

// token: Token*
fn typecheck_error_at(token: ptr, format: cstr, args: any) -> none {
  const fd: u64 = STDERR_FILENO;
  if eq load64 + c Compile.status NoError {
    {
      let args: any = (
        load64 + token Token.filename,
        load64 + token Token.line,
        load64 + token Token.column
      );
      color_set(COLOR_ERROR);
      dprintf(fd, "[typecheck-error]: ", null);
      color_set(COLOR_EXTRA);
      dprintf(fd, "%s:%d:%d: ", @args);
      color_reset();
    }
    dprintf(fd, format, args);
    printline(fd, cast cstr load64 + token Token.source, cast cstr load64 + token Token.buffer, load64 + token Token.length, 1, NUM_LINES_TO_PRINT);
    store64 + c Compile.status Error;
  }
  store64 + c Compile.error_count + 1 load64 + c Compile.error_count;
}

fn type_context_init(context: ptr<Type_context>) -> none {
  type_init(cast ptr<Type> + context Type_context.type, TypeNone, 0, 0, 1);
  store64 + context Type_context.offset 0;
  store64 + context Type_context.symbol_id UINT64_MAX;
}

fn type_context_push(context: ptr<Type_context>) -> u64 {
  let id = cast ptr<u64> + c Compile.type_context_count;
  let result = UINT64_MAX;
  if < deref id MAX_TYPE_CONTEXT {
    store64 @result deref id;
    memcpy(+ + c Compile.type_contexts * sizeof Type_context deref id, context, sizeof Type_context);
    store64 id + 1 deref id;
  }
  else {
    assert(0, "type context capacity reached\n");
  }
  result;
}

fn type_context_from_id(id: u64) -> ptr<Type_context> {
  let result = cast ptr<Type_context> null;
  if < id load64 + c Compile.type_context_count {
    store64 @result + + c Compile.type_contexts * sizeof Type_context id;
  }
  result;
}

fn struct_field_init(field: ptr<Struct_field>, name: ptr<u8[MAX_NAME_SIZE]>, length: u64, type: ptr<Type>, offset: u64) -> u64 {
  let result = Error;
  if < length MAX_NAME_SIZE {
    strncpy(cast cstr + field Struct_field.name, cast cstr name, length);
    memcpy(+ field Struct_field.type, type, sizeof Type);
    store64 + field Struct_field.offset offset;
    store64 @result NoError;
  }
  result;
}

fn struct_type_info_init(info: ptr<Struct_type_info>, name: ptr<u8[MAX_NAME_SIZE]>, name_length: u64) -> none {
  memset(+ info Struct_type_info.name, 0, MAX_NAME_SIZE);
  strncpy(cast cstr + info Struct_type_info.name, cast cstr name, name_length);
  store64 + info Struct_type_info.count 0;
}

fn struct_lookup_field(info: ptr<Struct_type_info>, name: ptr<u8[MAX_NAME_SIZE]>) -> ptr<Struct_field> {
  let result = cast ptr<Struct_field> null;

  let i = 0;
  let count = load64 + info Struct_type_info.count;
  while < i count {
    let lookup = cast ptr<Struct_field> + + info Struct_type_info.fields * sizeof Struct_field i;
    if eq strncmp(cast cstr + lookup Struct_field.name, cast cstr name, MAX_NAME_SIZE) 0 {
      store64 @result lookup;
    }
    store64 @i + 1 i;
  }

  result;
}

fn struct_create_field(info: ptr<Struct_type_info>, field: ptr<Struct_field>) -> u64 {
  let result = Error;
  if eq struct_lookup_field(info, cast ptr<u8[MAX_NAME_SIZE]> + field Struct_field.name) null {
    let index = cast ptr<u64> + info Struct_type_info.count;
    let new_field = cast ptr<Struct_field> + + info Struct_type_info.fields * sizeof Struct_field deref index;
    store64 index + 1 deref index;
    memcpy(new_field, field, sizeof Struct_field);
    store64 @result NoError;
  }
  result;
}

fn struct_fetch_field(info: ptr<Struct_type_info>, field_index: u64) -> ptr<Struct_field> {
  let result = cast ptr<Struct_field> null;
  let count = load64 + info Struct_type_info.count;
  if < field_index count {
    store64 @result + + info Struct_type_info.fields * sizeof Struct_field field_index;
  }
  result;
}

fn struct_fetch_type_info(id: u64) -> ptr<Struct_type_info> {
  let result = cast ptr<Struct_type_info> null;
  let struct_id = load64 + c Compile.struct_id;
  if < id struct_id {
    store64 @result + + c Compile.struct_type_info * sizeof Struct_type_info id;
  }
  result;
}

fn struct_type_push(info: ptr<Struct_type_info>) -> u64 {
  let result = NoError;
  let struct_id = cast ptr<u64> + c Compile.struct_id;
  memcpy(cast any + + c Compile.struct_type_info * sizeof Struct_type_info deref struct_id, info, sizeof Struct_type_info);
  store64 struct_id + 1 deref struct_id;
  result;
}

fn struct_type_info_print(fd: u64, info: ptr<Struct_type_info>, flat: u64) -> none {
  let i = 0;
  let count = load64 + info Struct_type_info.count;
  dprintf(fd, "(", null);
  if eq flat 0 {
    dprintf(fd, "\n", null);
  }
  while < i count {
    let field = struct_fetch_field(info, i);
    let field_type: Type = 0;
    memcpy(at field_type, + field Struct_field.type, sizeof Type);

    let args: any = + field Struct_field.name;
    if eq flat 0 {
      dprintf(fd, "  ", null);
    }
    dprintf(fd, "%s: ", @args);
    _type_print(fd, at field_type);

    store64 @i + 1 i;
    if < i count {
      dprintf(fd, ",", null);
      if flat {
        dprintf(fd, " ", null);
      }
    }
    if eq flat 0 {
      dprintf(fd, "\n", null);
    }
  }
  dprintf(fd, ")", null);
}

fn struct_type_info_printline(fd: u64, info: ptr<Struct_type_info>, flat: u64) -> none {
  struct_type_info_print(fd, info, flat);
  dprintf(fd, "\n", null);
}

fn func_signature_write_to_buffer(buffer: ptr<ptr>, size: ptr<u64>, func: ptr<Func_signature>) -> none {
  asnprintf(buffer, size, "(", null);
  let arg_index: u64 = 0;
  let argc: u64 = load64 + func Func_signature.argc;
  while < arg_index argc {
    let arg_type = cast ptr<Type> + + func Func_signature.args * sizeof Type arg_index;
    _type_write_to_buffer(buffer, size, arg_type);
    store64 @arg_index + 1 arg_index;
    if < arg_index argc {
      asnprintf(buffer, size, ", ", null);
    }
  }
  asnprintf(buffer, size, ") -> ", null);
  _type_write_to_buffer(buffer, size, cast ptr<Type> + func Func_signature.rtype);
}

fn func_signature_print(fd: u64, func: ptr<Func_signature>) -> none {
  let buffer_size = DEFAULT_TYPE_BUFFER_SIZE;
  let buffer: u8[buffer_size] = 0;
  let bp = at buffer;

  func_signature_write_to_buffer(cast ptr<ptr> at bp, at buffer_size, func);
  let args: any = at buffer;
  dprintf(fd, "%s", @args);
}

fn func_signatures_print(fd: u64) -> none {
  dprintf(fd, "func_signatures_print:\n", null);
  let i = 0;
  let count = load64 + c Compile.func_sig_count;
  while < i count {
    let func = cast ptr<Func_signature> + + c Compile.func_signatures * sizeof Func_signature i;
    dprintf(fd, "%d: ", @i);
    func_signature_print(fd, func);
    dprintf(fd, "\n", null);
    store64 at i + 1 i;
  }
}

// for now `ptr` is the only type that is a container i.e. a type that can contain other types
fn type_is_container(type: ptr<Type>) -> u64 {
  eq type_base(type) TypePtr;
}

fn type_write_to_buffer(buffer: ptr<ptr>, size: ptr<u64>, type: ptr<Type>) -> none {
  // check if this is a container type
  if type_is_container(type) {
    let args: any = load64 + @compile_type_str * sizeof cstr type_base(type);
    asnprintf(buffer, size, "%s<", @args);
    let next_type: Type = 0;
    memcpy(at next_type, + + c Compile.types * sizeof Type type_sub_id(type), sizeof Type);
    type_write_to_buffer(buffer, size, at next_type);
    asnprintf(buffer, size, ">", null);
  }
  else if eq type_base(type) TypeStruct {
    let id = type_sub_id(type);
    let type_info = struct_fetch_type_info(id);
    let args: any = + type_info Struct_type_info.name;
    asnprintf(buffer, size, "struct %s", @args);
  }
  else if eq type_base(type) TypeUnion {
    let id = type_sub_id(type);
    let type_info = struct_fetch_type_info(id);
    let args: any = + type_info Struct_type_info.name;
    asnprintf(buffer, size, "union %s", @args);
  }
  else if eq type_base(type) TypeFunc {
    let func = cast ptr<Func_signature> + + c Compile.func_signatures * sizeof Func_signature type_sub_id(type);
    func_signature_write_to_buffer(buffer, size, func);
  }
  // primitive type
  else {
    let args: any = load64 + @compile_type_str * sizeof cstr type_base(type);
    asnprintf(buffer, size, "%s", @args);
  }
  let count = load64 + type Type.count;
  if > count 1 {
    asnprintf(buffer, size, "[%d]", @count);
  }
}

fn type_print(fd: u64, type: ptr<Type>) -> none {
  let buffer_size = DEFAULT_TYPE_BUFFER_SIZE;
  let buffer: u8[buffer_size] = 0;
  let bp = at buffer;
  type_write_to_buffer(cast ptr<ptr> at bp, at buffer_size, type);
  let args: any = at buffer;
  dprintf(fd, "%s", @args);
}

fn type_to_buffer(buffer: ptr, size: u64, type: ptr<Type>) -> none {
  type_write_to_buffer(at buffer, at size, type);
}

fn type_printline(fd: u64, type: ptr<Type>) -> none {
  type_print(fd, type);
  dprintf(fd, "\n", null);
}

fn typecheck_print_types(fd: u64) -> none {
  dprintf(fd, "typecheck_print_types:\n", null);
  let i: u64 = 0;
  let count: u64 = load64 + c Compile.type_count;
  while < i count {
    let type = cast ptr<Type> + + c Compile.types * sizeof Type i;
    dprintf(fd, "%d: ", @i);
    type_printline(fd, type);
    store64 @i + 1 i;
  }
}

fn types_are_equal(a: ptr<Type>, b: ptr<Type>) -> u64 {
  and and
    eq load64 + a Type.base     load64 + b Type.base
    eq load64 + a Type.sub_id   load64 + b Type.sub_id
    eq load64 + a Type.count    load64 + b Type.count;
}

fn typecheck_print_stack(fd: u64) -> none {
  let i = 0;
  let count = load64 + c Compile.ts_count;
  while < i count {
    let type: Type = 0;
    memcpy(at type, + + c Compile.ts * sizeof Type i, sizeof Type);
    let value: Value = 0;
    memcpy(at value, + + c Compile.vs * sizeof Value i, sizeof Value);
    dprintf(fd, "%d: ", @i);
    type_print(fd, at type);
    let args: any = load64 + @value Value.num;
    dprintf(fd, " = %d\n", @args);
    store64 @i + 1 i;
  }
}

fn type_from_id(id: u64, type_out: ptr<Type>) -> none {
  let type_count: u64 = load64 + c Compile.type_count;
  if < id type_count {
    memcpy(type_out, + + c Compile.types * sizeof Type id, sizeof Type);
  }
  else {
    assert(0, "type_from_id: bad type id\n");
  }
}

fn compile_type_size(type_id: u64) -> u64 {
  let result = 0;
  if < type_id load64 + c Compile.type_count {
    let type: Type = 0;
    type_from_id(type_id, at type);
    store64 @result load64 + at type Type.size;
  }
  result;
}

fn type_lookup(type: ptr<Type>) -> u64 {
  let result: u64 = UINT64_MAX;
  let done: u64 = 0;
  let i: u64 = 0;
  let type_count: u64 = load64 + c Compile.type_count;
  while and eq done 0 < i type_count {
    let t: Type = 0;
    memcpy(at t, + + c Compile.types * sizeof Type i, sizeof Type);
    if types_are_equal(type, at t) {
      store64 @result i;
      store64 @done 1;
    }
    store64 @i + 1 i;
  }
  result;
}

fn type_push_new(type: ptr<Type>) -> u64 {
  let type_count = cast ptr<u64> + c Compile.type_count;
  let id = deref type_count;
  if < deref type_count MAX_COMPILE_TYPE {
    memcpy(+ + c Compile.types * sizeof Type deref type_count, type, sizeof Type);
    store64 type_count + 1 deref type_count;
  }
  else {
    assert(0, "compile type capacity reached, increase capacity\n");
  }
  id; // return id of the newly created type
}

// same as type_push_new but hash the type as well
// simply hashes the type struct itself
fn type_commit_new(type: ptr<Type>) -> u64 {
  store64 + type Type.hash 0; // reset hash, in case the type was modified
  let hash = sdbm_hash(type, sizeof Type);
  store64 + type Type.hash hash;
  type_push_new(type);
}

// checks if `type` is valid inside of `container`
fn type_check_constraints(container: ptr<Type>, type: ptr<Type>) -> u64 {
  let result = TYPE_CONSTRAINT_INVALID;
  if type_is_container(container) {
    store64 @result TYPE_CONSTRAINT_VALID;
  }
  else if and eq type_base(container) MAX_PRIMITIVE_TYPE > type_base(container) MAX_PRIMITIVE_TYPE {
    store64 @result TYPE_CONSTRAINT_VALID;
  }
  result;
}

fn type_deflate(type: ptr<Type>, type_out: ptr<Type>) -> none {
  if type_out {
    type_init(type_out, TypeNone, 0, 0, 1);
  }
  let id = type_sub_id(type);
  if neq id 0 {
    if type_is_container(type) {
      if type_out {
        type_from_id(id, type_out);
      }
    }
  }
}

// contract: Type[]
fn type_from_contract(contract: ptr<Type>, count: u64, mode: u64, result_out: ptr<Type>) -> u64 {
  assert(neq count 0, "number of elements in contract must be greater than 0\n");
  let result = NoError;
  let fail: u64 = 0;

  type_init(result_out, TypeNone, 0, 0, 1);

  if eq count 1 {
    let type: Type = 0;
    memcpy(at type, contract, sizeof Type);
    let lookup: u64 = type_lookup(at type);
    if neq lookup UINT64_MAX {
      memcpy(result_out, at type, sizeof Type);
    }
    else if eq mode TYPE_CONTRACT_CREATE {
      // TODO(lucas): check if this type is valid
      { let _ = type_commit_new(at type); }
      memcpy(result_out, at type, sizeof Type);
    }
    else {
      store64 @fail 1;
    }
  }
  else {
    let i: u64 = - count 1;
    let primary_type: Type = 0;
    type_init(
      at primary_type,
      TypeNone,
      0, // sub type id
      0, // size
      1  // count
    );
    let sub_type: Type = 0;
    memcpy(at sub_type, + contract * sizeof Type i, sizeof Type);

    while and eq fail 0 > i 0 {
      memcpy(at primary_type, + contract * sizeof Type - i 1, sizeof Type);
      let sub_type_id = type_lookup(at sub_type);
      if and eq mode TYPE_CONTRACT_CREATE eq sub_type_id UINT64_MAX {
        store64 @sub_type_id type_commit_new(at sub_type);
      }
      if neq sub_type_id UINT64_MAX {
        let primary_type_count: u64 = load64 + at primary_type Type.count;
        let type: Type = 0;
        type_init(at type, type_base(at primary_type), sub_type_id, load64 + at primary_type Type.size, primary_type_count);

        let constraint: u64 = type_check_constraints(at primary_type, at sub_type);
        if eq constraint TYPE_CONSTRAINT_VALID {
          let lookup: u64 = type_lookup(at type);
          if eq lookup UINT64_MAX {
            // type does not exist, create new type if mode is TYPE_CONTRACT_CREATE
            if eq mode TYPE_CONTRACT_CREATE {
              let new_type_id: u64 = type_commit_new(at type);
              assert(neq new_type_id 0, "failed to push new type\n");
              memcpy(result_out, at type, sizeof Type);
              memcpy(at sub_type, at type, sizeof Type); // sub type is now the newly created type
            }
            else {
              store64 @fail 1;
            }
          }
          else {
            // type exists
            memcpy(result_out, at type, sizeof Type);
            memcpy(at sub_type, at type, sizeof Type); // sub type is the newly created type
          }
        }
        else { // constraint failed
          store64 @fail 1;
        }
      }
      else {
        store64 @fail 1;
      }
      store64 @i - i 1;
    }
  }

  if fail {
    store64 @result Error;
  }
  result;
}

fn type_contract_stack_reset -> none {
  store64 + c Compile.type_contract_count 0;
}

fn type_contract_stack_push(type: ptr<Type>) -> u64 {
  let result = NoError;
  let count = cast ptr<u64> + c Compile.type_contract_count;
  if < deref count MAX_TYPE_CONTRACT_STACK {
    memcpy(+ + c Compile.type_contract_stack * sizeof Type deref count, type, sizeof Type);
    store64 count + 1 deref count;
  }
  else {
    store64 @result Error;
  }
  result;
}

fn func_signature_init(func: ptr<Func_signature>) -> none {
  store64 + func Func_signature.argc 0;
  type_from_id(TypeNone, cast ptr<Type> + func Func_signature.rtype);
}

fn func_signature_push(func: ptr<Func_signature>) -> u64 {
  let count = cast ptr<u64> + c Compile.func_sig_count;
  let id: u64 = UINT64_MAX;
  if < deref count MAX_COMPILE_TYPE {
    memcpy(+ + c Compile.func_signatures * sizeof Func_signature deref count, func, sizeof Func_signature);
    store64 @id deref count;
    store64 count + 1 deref count;
  }
  id;
}

fn func_signature_add_arg(func: ptr<Func_signature>, arg: ptr<Type>, is_syscall_func: u64) -> u64 {
  let result = NoError;
  let argc = cast ptr<u64> + func Func_signature.argc;
  if or is_syscall_func < deref argc MAX_FUNC_ARGC { // hack: ignore bounds check if this is a syscall function
    memcpy(+ + func Func_signature.args * sizeof Type deref argc, arg, sizeof Type);
    store64 argc + 1 deref argc;
  }
  else {
    store64 @result Error;
  }
  result;
}

fn func_signature_set_rtype(func: ptr<Func_signature>, rtype: ptr<Type>) -> none {
  memcpy(+ func Func_signature.rtype, rtype, sizeof Type);
}

fn func_signature_from_id(id: u64) -> ptr<Func_signature> {
  let result = cast ptr<Func_signature> null;
  if < id load64 + c Compile.func_sig_count {
    store64 @result + + c Compile.func_signatures * sizeof Func_signature id;
  }
  result;
}

fn func_signatures_compare(a: ptr<Func_signature>, b: ptr<Func_signature>) -> u64 {
  let result = 1;
  if eq load64 + a Func_signature.argc load64 + b Func_signature.argc {
    let i = 0;
    let argc = load64 + a Func_signature.argc;
    let done = 0;
    while and eq done 0 < i argc {
      let arg_a = cast ptr<Type> + + a Func_signature.args * sizeof Type i;
      let arg_b = cast ptr<Type> + + b Func_signature.args * sizeof Type i;
      if eq types_are_equal(arg_a, arg_b) 0 {
        store64 @result 0;
        store64 @done 1;
      }
      store64 @i + 1 i;
    }
  }
  else {
    store64 @result 0;
  }
  result;
}

fn is_numerical(type: ptr<Type>) -> u64 {
  let value = type_base(type);
  or or or
    eq value TypeUnsigned64
    eq value TypeUnsigned32
    eq value TypeUnsigned16
    eq value TypeUnsigned8;
}

fn ts_push(type: ptr<Type>, type_out: ptr<Type>) -> none {
  if type_out {
    type_init(type_out, TypeNone, 0, 0, 1);
  }
  let ts_count = cast ptr<u64> + c Compile.ts_count;
  if < deref ts_count MAX_TYPE_STACK {
    memcpy(+ + c Compile.ts * sizeof Type deref ts_count, type, sizeof Type);
    store64 ts_count + 1 deref ts_count;
    if type_out {
      memcpy(type_out, type, sizeof Type);
    }
  }
  else {
    assert(0, "type stack overflow\n");
  }
}

fn ts_push_primitive(primitive: u64, type_out: ptr<Type>) -> none {
  let type: Type = 0;
  type_init(at type, primitive, 0, compile_type_size(primitive), 1);
  ts_push(at type, type_out);
}

fn ts_pop(type_out: ptr<Type>) -> none {
  if type_out {
    type_init(type_out, TypeNone, 0, 0, 1);
  }
  let ts_count = cast ptr<u64> + c Compile.ts_count;
  if < deref ts_count MAX_TYPE_STACK {
    store64 ts_count - deref ts_count 1;
    if type_out {
      memcpy(type_out, + + c Compile.ts * sizeof Type deref ts_count, sizeof Type);
    }
  }
  else {
    assert(0, "type stack underflow\n");
  }
}

fn ts_top(type_out: ptr<Type>) -> none {
  if type_out {
    type_init(type_out, TypeNone, 0, 0, 1);
  }
  let ts_count = cast ptr<u64> + c Compile.ts_count;
  if < deref ts_count MAX_TYPE_STACK {
    if type_out {
      memcpy(type_out, + + c Compile.ts * sizeof Type - deref ts_count 1, sizeof Type);
    }
  }
}

fn vs_push(value: ptr<Value>) -> u64 {
  let result = NoError;
  let vs_count = cast ptr<u64> + c Compile.vs_count;
  if < deref vs_count MAX_TYPE_STACK {
    memcpy(+ + c Compile.vs * sizeof Value deref vs_count, value, sizeof Value);
    store64 vs_count + 1 deref vs_count;
  }
  else {
    assert(0, "value stack overflow\n");
    store64 @result Error;
  }
  result;
}

fn vs_top(value_out: ptr<Value>) -> none {
  let vs_count: u64 = load64 + c Compile.vs_count;
  if < vs_count MAX_TYPE_STACK {
    if value_out {
      memcpy(value_out, + + c Compile.vs * sizeof Value - vs_count 1, sizeof Value);
    }
  }
  else {
    if value_out {
      store64 @value_out null;
    }
  }
}

fn vs_pop(value_out: ptr<Value>) -> u64 {
  let result = NoError;
  let vs_count = cast ptr<u64> + c Compile.vs_count;
  if < deref vs_count MAX_TYPE_STACK {
    if value_out {
      vs_top(value_out);
    }
    store64 vs_count - deref vs_count 1;
  }
  else {
    assert(0, "value stack underflow\n");
    store64 @result Error;
  }
  result;
}

// block: Block*, fs: Function*, token: Token*, symbol_out: Symbol**
fn token_to_compile_type(block: ptr<Block>, fs: ptr<Function>, token: ptr, symbol_out: ptr, type_out: ptr<Type>) -> none {
  type_init(type_out, TypeNone, 0, 0, 1);
  let token_type = load64 + token Token.type;
  if eq token_type T_ANY {
    type_init(type_out, TypeAny, 0, sizeof any, 1);
  }
  else if eq token_type T_PTR {
    type_init(type_out, TypePtr, 0, sizeof ptr, 1);
  }
  else if eq token_type T_UNSIGNED64 {
    type_init(type_out, TypeUnsigned64, 0, sizeof u64, 1);
  }
  else if eq token_type T_UNSIGNED32 {
    type_init(type_out, TypeUnsigned32, 0, sizeof u32, 1);
  }
  else if eq token_type T_UNSIGNED16 {
    type_init(type_out, TypeUnsigned16, 0, sizeof u16, 1);
  }
  else if eq token_type T_UNSIGNED8 {
    type_init(type_out, TypeUnsigned8, 0, sizeof u8, 1);
  }
  else if or eq token_type T_CSTRING eq token_type T_CSTR {
    type_init(type_out, TypeCString, 0, sizeof cstr, 1);
  }
  else if eq token_type T_IDENTIFIER {
    let symbol = null;
    let buffer: Buffer = 0;
    buffer_init(at buffer, cast ptr load64 + token Token.buffer, load64 + token Token.length);
    if eq compile_lookup_value(block, fs, @buffer, @symbol, null, null) NoError {
      if neq symbol_out null {
        store64 symbol_out symbol;
      }
      memcpy(type_out, + symbol Symbol.type, sizeof Type);
    }
  }
}

// result is stored in Compile.type_contract_stack
// Type
//   None | Value
//   Type
// block: ptr<Block>, fs: ptr<Function>, ast: ptr<Ast>
fn collect_types_from_node(block: ptr<Block>, fs: ptr<Function>, ast: ptr) -> u64 {
  let result = NoError;
  let sub_type_node = null;
  if ast {
    let type: Type = 0;
    let symbol = null;
    token_to_compile_type(block, fs, + ast Ast.token, @symbol, at type);
    let array_specifier_node = cast ptr load64 + + ast Ast.node * sizeof ptr 0;
    if neq load64 + array_specifier_node Ast.type AstNone {
      { let _ = _typecheck(block, fs, array_specifier_node); }
      let value: Value = 0;
      { let _ = vs_pop(at value); }
      let array_specifier_type: Type = 0;
      ts_pop(at array_specifier_type);
      if is_numerical(at array_specifier_type) {
        store64 + at type Type.count load64 + at value Value.num;
      }
      else {
        store64 @result Error;
      }
    }
    if and symbol eq type_base(at type) TypeNone {
      store64 @result Error;
    }
    else if eq type_contract_stack_push(at type) NoError {
      if eq load64 + ast Ast.count 2 {
        store64 @sub_type_node load64 + + ast Ast.node * sizeof ptr 1;
      }
      store64 @result collect_types_from_node(block, fs, sub_type_node);
      store64 @result NoError;
    }
    else {
      store64 @result Error;
    }
  }
  result;
}

// block: Block*, fs: Function*, ast: Ast*, mode: u64, type_out: Type*
fn type_contract_from_type_node(block: ptr<Block>, fs: ptr<Function>, ast: ptr, mode: u64, type_out: ptr<Type>, accept_none_type: u64) -> u64 {
  let result = Error;
  let collected_types_result = collect_types_from_node(block, fs, ast);
  if eq collected_types_result NoError {
    let type: Type = 0;
    let contract = cast ptr<Type> + c Compile.type_contract_stack;
    let count: u64 = load64 + c Compile.type_contract_count;
    if eq type_from_contract(contract, count, mode, at type) NoError {
      memcpy(type_out, at type, sizeof Type);
      store64 @result NoError;
      if eq accept_none_type 0 {
        if eq type_base(at type) TypeNone {
          store64 @result Error;
        }
      }
    }
    type_contract_stack_reset();
  }
  result;
}

// ast: Ast*
fn is_branch_konst_eval(ast: ptr) -> u64 {
  let konst = 1;
  let i = 0;
  let count = load64 + ast Ast.count;
  while < i count {
    let node = cast ptr load64 + + ast Ast.node * sizeof ptr i;
    if eq load64 + node Ast.konst 0 {
      store64 @konst 0;
      store64 @i count;
    }
    store64 @i + 1 i;
  }
  konst;
}

fn typecheck_node_list(block: ptr<Block>, fs: ptr<Function>, ast: ptr) -> u64 {
  let i = 0;
  let count = load64 + ast Ast.count;
  while < i count {
    let _ = _typecheck(block, fs, cast ptr load64 + + ast Ast.node * sizeof ptr i);
    store64 @i + 1 i;
  }
  load64 + c Compile.status;
}

fn typecheck_none(block: ptr<Block>, fs: ptr<Function>, ast: ptr) -> u64 {
  load64 + c Compile.status;
}

fn typecheck_value(block: ptr<Block>, fs: ptr<Function>, ast: ptr) -> u64 {
  let token_type = load64 + + ast Ast.token Token.type;
  if eq token_type T_NUMBER {
    let value: Value = 0;
    store64 + @value Value.num load64 + + ast Ast.token Token.v;
    store64 + @value Value.konst 1;
    store64 + ast Ast.konst 1;
    { let _ = vs_push(at value); }
    ts_push_primitive(TypeUnsigned64, cast ptr<Type> null);
  }
  else if eq token_type T_CSTRING {
    let value: Value = 0;
    memset(@value, 0, sizeof Value);
    { let _ = vs_push(at value); }
    ts_push_primitive(TypeCString, cast ptr<Type> null);
  }
  else if eq token_type T_IDENTIFIER {
    let symbol: ptr = null;
    let symbol_index = UINT64_MAX;
    let token_buffer: Buffer = 0;
    buffer_init(at token_buffer, cast ptr load64 + + ast Ast.token Token.buffer, load64 + + ast Ast.token Token.length);

    if eq compile_lookup_value(block, fs, @token_buffer, @symbol, @symbol_index, null) NoError {
      store64 + symbol Symbol.ref_count + 1 load64 + symbol Symbol.ref_count;
      store64 + + ast Ast.token Token.v symbol_index;
      store64 + ast Ast.konst load64 + + symbol Symbol.value Value.konst;
      let type: Type = 0;
      memcpy(at type, + symbol Symbol.type, sizeof Type);
      let size = load64 + at type Type.size;
      if > size MAX_PUSH_SIZE {
        let args: any = MAX_PUSH_SIZE;
        typecheck_error_at(+ ast Ast.token, "can not push an item with size greater than %d\n", @args);
      }
      else {
        { let _ = vs_push(cast ptr<Value> + symbol Symbol.value); }
        ts_push(at type, cast ptr<Type> null);
      }
    }
    else {
      let message = tmp_it;
      tmp_push_cstr("symbol `");
      tmp_push_str(load64 + + ast Ast.token Token.buffer, load64 + + ast Ast.token Token.length);
      tmp_push_cstr("` not defined\n");
      tmp_push_byte(cast u8 0);
      compile_error_at(+ ast Ast.token, cast cstr message);
      store64 @tmp_it message;
    }
  }
  else if or eq token_type T_AT eq token_type T_AT_WORD {
    let symbol: ptr = null;
    let symbol_index = UINT64_MAX;
    let token_buffer: Buffer = 0;
    buffer_init(at token_buffer, cast ptr load64 + + ast Ast.token Token.buffer, load64 + + ast Ast.token Token.length);
    if eq compile_lookup_value(block, fs, @token_buffer, @symbol, @symbol_index, null) NoError {
      store64 + symbol Symbol.ref_count + 1 load64 + symbol Symbol.ref_count;
      store64 + + ast Ast.token Token.v symbol_index;
      let type: Type = 0;
      memcpy(at type, + symbol Symbol.type, sizeof Type);
      if eq token_type T_AT_WORD {
        const count = 2;
        let contract: Type[count] = 0;
        type_init(cast ptr<Type> + at contract * sizeof Type 0, TypePtr, 0, sizeof ptr, 1);
        memcpy(+ at contract * sizeof Type 1, at type, sizeof Type);
        let ptr_type: Type = 0;
        if eq type_from_contract(cast ptr<Type> at contract, count, TYPE_CONTRACT_CREATE, at ptr_type) NoError {
          let value: Value = 0;
          memcpy(at value, + symbol Symbol.value, sizeof Value);
          store64 + at value Value.konst 0;
          { let _ = vs_push(at value); }
          ts_push(at ptr_type, cast ptr<Type> null);
        }
        else {
          typecheck_error_at(+ ast Ast.token, "invalid pointer type construction\n", null);
        }
      }
      else {
        let value: Value = 0;
        memcpy(at value, + symbol Symbol.value, sizeof Value);
        store64 + at value Value.konst 0;
        { let _ = vs_push(at value); }
        let ptr_type: Type = 0;
        type_init(at ptr_type, TypePtr, 0, sizeof ptr, 1);
        ts_push(at ptr_type, cast ptr<Type> null);
      }
      store64 + ast Ast.konst 0;
    }
    else {
      let message = tmp_it;
      tmp_push_cstr("symbol `");
      tmp_push_str(load64 + + ast Ast.token Token.buffer, load64 + + ast Ast.token Token.length);
      tmp_push_cstr("` not defined\n");
      tmp_push_byte(cast u8 0);
      compile_error_at(+ ast Ast.token, cast cstr message);
      store64 @tmp_it message;
    }
  }
  else {
    assert(0, "invalid token type\n");
  }
  load64 + c Compile.status;
}

fn typecheck_expr(block: ptr<Block>, fs: ptr<Function>, ast: ptr) -> u64 {
  let _ = _typecheck(block, fs, cast ptr load64 + + ast Ast.node * sizeof ptr 0);
  store64 + ast Ast.konst is_branch_konst_eval(ast);
  load64 + c Compile.status;
}

fn typecheck_list_of_nodes(block: ptr<Block>, fs: ptr<Function>, ast: ptr) -> u64 {
  let _ = typecheck_node_list(block, fs, ast);
  store64 + ast Ast.konst is_branch_konst_eval(ast);
  load64 + c Compile.status;
}

fn typecheck_block_statement(block: ptr<Block>, fs: ptr<Function>, ast: ptr) -> u64 {
  let local_block = block_push(block);
  { let _ = typecheck_node_list(local_block, fs, ast); }
  block_pop(); // local_block
  store64 + ast Ast.konst is_branch_konst_eval(ast);
  load64 + c Compile.status;
}

fn typecheck_binop_expr(block: ptr<Block>, fs: ptr<Function>, ast: ptr) -> u64 {
  { let _ = typecheck_node_list(block, fs, ast); }
  let b: Type = 0;
  let a: Type = 0;
  ts_pop(at b);
  ts_pop(at a);
  if and
    or or or is_numerical(at a) eq type_base(at a) TypeAny eq type_base(at a) TypePtr eq type_base(at a) TypeCString
    or or or is_numerical(at b) eq type_base(at b) TypeAny eq type_base(at b) TypePtr eq type_base(at b) TypeCString {
    let va: Value = 0;
    let vb: Value = 0;
    { let _ = vs_pop(at vb); }
    { let _ = vs_pop(at va); }
    store64 + ast Ast.konst and load64 + @va Value.konst load64 + @vb Value.konst;

    let num: u64 = 0;
    let token_type = load64 + + ast Ast.token Token.type;
    if eq token_type T_ADD {
      store64 @num + load64 + @va Value.num load64 + @vb Value.num;
    }
    else if eq token_type T_SUB {
      store64 @num - load64 + @va Value.num load64 + @vb Value.num;
    }
    else if eq token_type T_MUL {
      store64 @num * load64 + @va Value.num load64 + @vb Value.num;
    }
    else if eq token_type T_DIV {
      if eq load64 + @vb Value.konst 1 {
        if eq load64 + @vb Value.num 0 {
          typecheck_error("divide by zero arithmetic error\n");
        }
        else {
          store64 @num / load64 + @va Value.num load64 + @vb Value.num;
        }
      }
    }
    else if eq token_type T_DIVMOD {
      if eq load64 + @vb Value.konst 1 {
        if eq load64 + @vb Value.num 0 {
          typecheck_error("modulo by zero arithmetic error\n");
        }
        else {
          store64 @num % load64 + @va Value.num load64 + @vb Value.num;
        }
      }
    }
    else if eq token_type T_LSHIFT {
      store64 @num lshift load64 + @va Value.num load64 + @vb Value.num;
    }
    else if eq token_type T_RSHIFT {
      store64 @num rshift load64 + @va Value.num load64 + @vb Value.num;
    }
    else if eq token_type T_LT {
      store64 @num < load64 + @va Value.num load64 + @vb Value.num;
    }
    else if eq token_type T_GT {
      store64 @num > load64 + @va Value.num load64 + @vb Value.num;
    }
    else if eq token_type T_AND {
      store64 @num and load64 + @va Value.num load64 + @vb Value.num;
    }
    else if eq token_type T_OR {
      store64 @num or load64 + @va Value.num load64 + @vb Value.num;
    }
    else if eq token_type T_XOR {
      store64 @num xor load64 + @va Value.num load64 + @vb Value.num;
    }
    else if eq token_type T_EQ {
      store64 @num eq load64 + @va Value.num load64 + @vb Value.num;
    }
    else if eq token_type T_NEQ {
      store64 @num neq load64 + @va Value.num load64 + @vb Value.num;
    }
    else {
      assert(0, "unhandled operator\n");
    }
    let value: Value = 0;
    store64 + @value Value.num num;
    let konst = is_branch_konst_eval(ast);
    store64 + ast Ast.konst konst;
    store64 + @value Value.konst konst;
    { let _ = vs_push(at value); }
    ts_push(at a, cast ptr<Type> null);

    // if the expression is constant it can be collapsed into a single node
    if konst {
      ast_clear(ast);
      ast_init_node(ast, AstValue);
      let token = cast ptr<Token> + ast Ast.token;
      store64 + token Token.type T_NUMBER;
      store64 + token Token.v load64 + at value Value.num;
      store64 + ast Ast.konst konst;
    }
  }
  else {
    typecheck_error("type mismatch in binary operator expression\n");
  }
  load64 + c Compile.status;
}

fn typecheck_uop_expr(block: ptr<Block>, fs: ptr<Function>, ast: ptr) -> u64 {
  let ts_count: u64 = load64 + c Compile.ts_count;
  { let _ = typecheck_node_list(block, fs, ast); }
  store64 + ast Ast.konst is_branch_konst_eval(ast);
  let ts_delta: u64 = - load64 + c Compile.ts_count ts_count;
  if eq ts_delta 1 {
    let token_type = load64 + + ast Ast.token Token.type;
    if eq token_type T_PRINT {
      { let _ = vs_pop(cast ptr<Value> null); }
      ts_pop(cast ptr<Type> null);
    }
    else if or or or or
      eq token_type T_DEREF
      eq token_type T_LOAD64
      eq token_type T_LOAD32
      eq token_type T_LOAD16
      eq token_type T_LOAD8 {
      ts_pop(cast ptr<Type> null);
      ts_push_primitive(TypeUnsigned64, cast ptr<Type> null);
      store64 + ast Ast.konst 0;
    }
    else if eq token_type T_DEREF_WORD {
      let type: Type = 0;
      ts_pop(at type);
      let deflated_type: Type = 0;
      type_deflate(at type, at deflated_type);
      if neq type_base(at deflated_type) TypeNone {
        ts_push(at deflated_type, cast ptr<Type> null);
      }
      else {
        typecheck_error_at(+ ast Ast.token, "can not dereference this type\n", null);
      }
      store64 + ast Ast.konst 0;
    }
    else if eq token_type T_LOGICAL_NOT {
      let value: Value = 0;
      { let _ = vs_pop(at value); }
      store64 + @value Value.num not load64 + @value Value.num;
      { let _ = vs_push(at value); }
    }
    else if eq token_type T_NOT {
      let value: Value = 0;
      { let _ = vs_pop(at value); }
      store64 + @value Value.num ~ load64 + @value Value.num;
      { let _ = vs_push(at value); }
    }
  }
  else {
    typecheck_error("no value was produced in the rhs of the unary expression\n");
  }
  load64 + c Compile.status;
}

// AST representation:
// LetStatement
//   ExprList
//     Expression
//     ...
//   Type
//     None | Value (array specifier)
//     Type (optional sub type)
// TODO(lucas): simplify
fn typecheck_let_statement(block: ptr<Block>, fs: ptr<Function>, ast: ptr) -> u64 {
  let result = NoError;
  let konst = eq load64 + ast Ast.type AstConstStatement;
  let ts_count = load64 + c Compile.ts_count;
  let num_elements = 1;
  let rhs = cast ptr load64 + + ast Ast.node * sizeof ptr 0;
  let ast_type = null;
  if eq load64 + ast Ast.count 2 {
    store64 @ast_type cast ptr load64 + + ast Ast.node * sizeof ptr 1;
  }

  // typecheck the rhs of the statement
  { let _ = typecheck_node_list(block, fs, rhs); }
  let rhs_konst_branch = is_branch_konst_eval(rhs);
  store64 + rhs Ast.konst rhs_konst_branch;
  store64 + ast Ast.konst rhs_konst_branch;

  // make sure that rhs actually produced any values
  let ts_delta = - load64 + c Compile.ts_count ts_count;
  if eq ts_delta 0 {
    typecheck_error_at(+ ast Ast.token, "no value was produced in the rhs of the let statement\n", null);
  }
  else {
    // typecheck explicit type, if there is one
    let explicit_type: Type = 0;
    type_init(at explicit_type, TypeNone, 0, 0, 1);

    // for if the type is a function
    let explicit_type_value: Value = 0;

    if neq ast_type null {
      if eq type_contract_from_type_node(block, fs, ast_type, TYPE_CONTRACT_CREATE, at explicit_type, 0) NoError {
        if eq type_base(at explicit_type) TypeFunc {
          let id = type_sub_id(at explicit_type);
          let expl_type_symbol = cast ptr<Symbol> + + c Compile.symbols * sizeof Symbol id;
          memcpy(at explicit_type_value, + expl_type_symbol Symbol.value, sizeof Value);
        }
        store64 @num_elements load64 + at explicit_type Type.count;
        if and > num_elements 1 > ts_delta num_elements {
          typecheck_error_at(cast ptr + load64 + rhs Ast.node Ast.token, "number of elements in rhs exceeded the array size specifier\n", null);
        }
      }
      else {
        typecheck_error_at(cast ptr + ast_type Ast.token, "invalid type construction\n", null);
      }
    }

    let imm = UINT64_MAX; // index to immediate value, in case this is a constant

    let value: Value = 0;
    let prev_value: Value = 0;
    vs_top(at value);
    vs_top(at prev_value);

    let type: Type = 0;
    ts_top(at type);
    let prev_type: Type = 0;
    ts_top(at prev_type);

    if neq type_base(at explicit_type) TypeNone {
      memcpy(at prev_type, at explicit_type, sizeof Type);
      if eq type_base(at explicit_type) TypeFunc {
        memcpy(@prev_value, @explicit_type_value, sizeof Value);
      }
    }

    let i = 0;
    let done = 0;
    while and not done < i ts_delta {
      ts_pop(at type);
      { let _ = vs_pop(at value); }
      if or or eq type_base(at explicit_type) TypeStruct eq type_base(at explicit_type) TypeUnion eq type_base(at explicit_type) TypeAny {
        // do nothing, all is permitted here
      }
      else {
        if and eq type_base(at type) TypeFunc eq type_base(at prev_type) TypeFunc {
          let func_sig_a = func_signature_from_id(type_sub_id(at type));
          let func_sig_b = func_signature_from_id(type_sub_id(at prev_type));
          if eq func_signatures_compare(func_sig_a, func_sig_b) 0 {
            typecheck_error_at(+ ast Ast.token, "incompatible type in expression list\n", null);
            store64 @done 1;
          }
        }
        else if and is_numerical(at explicit_type) is_numerical(at type) {
          // do nothing, this is ok
        }
        else if eq types_are_equal(at type, at prev_type) 0 {
          typecheck_error_at(+ ast Ast.token, "incompatible type in expression list\n", null);
          store64 @done 1;
        }
        memcpy(at prev_type, at type, sizeof Type);
      }
      memcpy(@prev_value, @value, sizeof Value);
      if eq konst 1 {
        if is_numerical(at type) {
          store64 @imm compile_push_value(+ @value Value.num, sizeof u64);
        }
        else {
          typecheck_error_at(+ ast Ast.token, "only numeric values are allowed in constants\n", null);
          store64 @done 1;
        }
        if not rhs_konst_branch {
          typecheck_error_at(+ ast Ast.token, "can not assign a non-constant expression to a constant value\n", null);
          store64 @done 1;
        }
      }
      store64 @i + 1 i;
    }

    // no array specifier was used, therefore num_elements is set to however many elements there was in the rhs
    if eq num_elements 1 {
      store64 @num_elements ts_delta;
      if > num_elements 1 {
        let contract: Type = 0;
        // check if explicit type is defined, when array specifier is not
        if neq type_base(at explicit_type) TypeNone {
          // here the array element count is inferred only
          memcpy(at contract, at explicit_type, sizeof Type);
        }
        // otherwise infer a new array-based type,
        // based on the most recently used array element type of the rhs (does not really matter which element that is selected as they are all constrained to be of the same type)
        else {
          memcpy(at contract, at type, sizeof Type);
        }
        store64 + at contract Type.count num_elements;
        let inferred_type: Type = 0;
        { let _ = type_from_contract(at contract, 1, TYPE_CONTRACT_CREATE, at inferred_type); } // TODO(lucas): handle error
        memcpy(at explicit_type, at inferred_type, sizeof Type);
      }
    }

    if neq type_base(at explicit_type) TypeNone {
      memcpy(at type, at explicit_type, sizeof Type);
    }

    // if this is a constant, make sure to update the immediate value index
    if eq konst 1 {
      let decrement = * sizeof u64 - ts_delta 1;
      store64 @imm - imm decrement;
    }

    let type_count: u64 = load64 + at type Type.count;
    let type_size: u64 = load64 + at type Type.size;

    let symbol: ptr = null;
    let symbol_index = UINT64_MAX;
    if eq compile_declare_value(block, fs, + ast Ast.token, @symbol, @symbol_index) NoError {
      store64 + symbol Symbol.imm imm;
      store64 + symbol Symbol.size * type_count type_size;
      store64 + symbol Symbol.num_elements_init ts_delta;
      store64 + symbol Symbol.konst konst;
      if eq cast u64 block + c Compile.global {
        store64 + symbol Symbol.sym_type SYM_GLOBAL_VAR;
      }
      else {
        store64 + symbol Symbol.sym_type SYM_LOCAL_VAR;
      }
      store64 + at value Value.konst konst;
      memcpy(+ symbol Symbol.type, at type, sizeof Type);
      memcpy(+ symbol Symbol.value, @value, sizeof Value);
      store64 + + symbol Symbol.token Token.v symbol_index;
      store64 + + ast Ast.token Token.v symbol_index;
    }
  }
  result;
}

fn typecheck_func_definition(block: ptr<Block>, fs: ptr<Function>, ast: ptr) -> u64 {
  if eq cast u64 block + c Compile.global {
    let params = cast ptr load64 + + ast Ast.node * sizeof ptr 0;
    let body = cast ptr load64 + + ast Ast.node * sizeof ptr 1;
    let rtype_node: ptr = null;
    if eq load64 + ast Ast.count 3 {
      store64 @rtype_node load64 + + ast Ast.node * sizeof ptr 2;
    }

    let func_sig: Func_signature = 0;
    func_signature_init(at func_sig);

    let func_type: Type = 0;
    type_init(at func_type, TypeFunc, 0, sizeof ptr, 1);

    let explicit_rtype: Type = 0;
    type_init(at explicit_rtype, TypeNone, 0, 0, 1);

    let argc: u64 = load64 + params Ast.count;
    if or eq argc MAX_FUNC_ARGC < argc MAX_FUNC_ARGC { // argc <= MAX_FUNC_ARGC
      let symbol: ptr = null;
      let symbol_index: u64 = UINT64_MAX;
      if eq compile_declare_value(block, fs, + ast Ast.token, @symbol, @symbol_index) NoError {
        let local_block = block_push(cast ptr<Block> block);
        let type_size: u64 = compile_type_size(TypeFunc);

        store64 + symbol Symbol.imm UINT64_MAX;
        store64 + symbol Symbol.size type_size;
        store64 + symbol Symbol.konst 0;
        store64 + symbol Symbol.sym_type SYM_FUNC;
        store64 + + ast Ast.token Token.v symbol_index;
        memcpy(+ symbol Symbol.token, + ast Ast.token, sizeof Token);
        let value = cast ptr<Value> + symbol Symbol.value;
        store64 + value Value.konst 0;
        let func = cast ptr<Function> + value Value.func;
        function_init(func);
        store64 + func Function.ir_address UINT64_MAX;
        store64 + func Function.label symbol_index;
        store64 + func Function.argc argc;
        store64 + func Function.locals_offset 0;

        if neq rtype_node null {
          if eq type_contract_from_type_node(block, fs, rtype_node, TYPE_CONTRACT_CREATE, at explicit_rtype, 1) NoError {
            // explicit return type
            func_signature_set_rtype(at func_sig, at explicit_rtype);
          }
          else {
            typecheck_error_at(+ rtype_node Ast.token, "unknown or invalid return type in function definition\n", null);
          }
        }

        let i: u64 = 0;
        let fail: u64 = 0;
        while and eq fail 0 < i argc {
          let arg_node = cast ptr load64 + + params Ast.node * sizeof ptr i;
          let arg: Token = 0;
          let arg_type_token: Token = 0;
          memcpy(@arg, + arg_node Ast.token, sizeof Token);
          memcpy(@arg_type_token, + load64 + + arg_node Ast.node * sizeof ptr 0 Ast.token, sizeof Token);

          let arg_symbol: ptr = null;
          let arg_symbol_index: u64 = UINT64_MAX;
          if eq compile_declare_value(local_block, func, @arg, @arg_symbol, @arg_symbol_index) NoError {
            let arg_type: Type = 0;

            let arg_type_node: ptr = cast ptr load64 + + arg_node Ast.node * sizeof ptr 0;
            if eq type_contract_from_type_node(block, fs, arg_type_node, TYPE_CONTRACT_CREATE, at arg_type, 0) NoError {
              let arg_type_id: u64 = type_lookup(at arg_type);
              assert(neq arg_type_id UINT64_MAX, "invalid type\n");
              let size: u64 = compile_type_size(arg_type_id);
              store64 @size compile_type_size(arg_type_id);
              if > size MAX_PUSH_SIZE {
                let args: any = MAX_PUSH_SIZE;
                typecheck_error_at(@arg_type_token, "can not have a parameter of type struct with a greater size than %d\n", @args);
                store64 @fail 1;
              }
              if eq fail 0 {
                store64 + arg_symbol Symbol.imm UINT64_MAX;
                store64 + arg_symbol Symbol.size size;
                store64 + arg_symbol Symbol.konst 0;
                store64 + arg_symbol Symbol.local_id + sizeof u64 * sizeof u64 i;
                store64 + arg_symbol Symbol.sym_type SYM_FUNC_ARG;
                memcpy(+ arg_symbol Symbol.type, at arg_type, sizeof Type);
                memcpy(+ arg_symbol Symbol.token, @arg, sizeof Token);
                store64 + + arg_symbol Symbol.token Token.v i; // TODO(lucas): store argument index in symbol value field instead. TODO(lucas): remove this as it is not used anymore (not for function arguments anyway)
                { let _ = func_signature_add_arg(at func_sig, at arg_type, 0); }
              }
            }
            else {
              typecheck_error_at(@arg_type_token, "unknown or invalid type\n", null);
            }
          }
          else {
            compile_error_at(@arg, "duplicate argument name\n");
            store64 @fail 1;
          }
          store64 @i + 1 i;
        }

        let func_sig_id = func_signature_push(at func_sig);
        let func_sig_type = func_signature_from_id(func_sig_id);

        store64 + at func_type Type.sub_id func_sig_id;

        let new_type_id: u64 = type_commit_new(at func_type); // TODO(lucas): handle error
        memcpy(+ symbol Symbol.type, at func_type, sizeof Type);

        let ts_count: u64 = load64 + c Compile.ts_count;

        let func_body_block = block_push(local_block);
        { let _ = typecheck_node_list(func_body_block, fs, body); }

        let konst_body: u64 = is_branch_konst_eval(body);
        store64 + body Ast.konst konst_body;
        store64 + ast Ast.konst konst_body;
        store64 + + symbol Symbol.value Value.konst konst_body;

        let rtype: Type = 0;
        type_init(at rtype, TypeNone, 0, 0, 1);
        let ts_delta: u64 = - load64 + c Compile.ts_count ts_count;
        if > ts_delta 1 {
          typecheck_error_at(+ ast Ast.token, "too many values produced by function\n", null);
        }
        else {
          if neq ts_delta 0 {
            { let _ = vs_pop(cast ptr<Value> null); }
            ts_pop(at rtype);
          }

          if rtype_node {
            if and neq types_are_equal(at explicit_rtype, at rtype) 1 neq type_base(at explicit_rtype) TypeAny {
              // TODO(lucas): more detailed error message
              compile_error_at(+ rtype_node Ast.token, "function returns a value that does not match the return type\n");
            }
          }
          // type inference for the return type
          else {
            // inferred return type
            func_signature_set_rtype(func_sig_type, at rtype);
          }

          if eq strncmp(cast cstr + symbol Symbol.name, "main", MAX_NAME_SIZE) 0 {
            store64 + symbol Symbol.ref_count + load64 + symbol Symbol.ref_count 1;
            store64 + c Compile.entry_point + load64 + c Compile.entry_point 1;
          }
        }
        block_pop(); // func_body_block
        block_pop(); // local_block
      }
      else {
        compile_error_at(+ ast Ast.token, "symbol already exists\n");
      }
    }
    else {
      let message = cast cstr tmp_it;
      sprintf(cast ptr message, "reached function parameter count limit of %d\n", @MAX_FUNC_ARGC);
      compile_error_at(+ ast Ast.token, message);
    }
  }
  else {
    compile_error_at(+ ast Ast.token, "functions are only permitted to be defined in the global block\n");
  }
  load64 + c Compile.status;
}

fn typecheck_func_call(block: ptr<Block>, fs: ptr<Function>, ast: ptr) -> u64 {
  let symbol: ptr = null;
  let symbol_index: u64 = UINT64_MAX;
  let token_buffer: Buffer = 0;
  buffer_init(at token_buffer, cast ptr load64 + + ast Ast.token Token.buffer, load64 + + ast Ast.token Token.length);
  if eq compile_lookup_value(block, fs, @token_buffer, @symbol, @symbol_index, null) NoError {
    store64 + symbol Symbol.ref_count + 1 load64 + symbol Symbol.ref_count;
    store64 + + ast Ast.token Token.v symbol_index;
    let arg_list = cast ptr load64 + + ast Ast.node * sizeof ptr 0;
    let func = cast ptr<Function> + + symbol Symbol.value Value.func;
    let type: Type = 0;
    memcpy(at type, + symbol Symbol.type, sizeof Type);
    if or eq type_base(at type) TypeFunc eq type_base(at type) TypeSyscallFunc {

      let func_sig = func_signature_from_id(type_sub_id(at type));

      let argc: u64 = load64 + func_sig Func_signature.argc;
      if eq argc load64 + arg_list Ast.count {
        store64 + + symbol Symbol.token Token.v symbol_index; // TODO(lucas): store this in the symbol value field, or someplace else
        let done: u64 = 0;
        let i: u64 = - argc 1;
        if > argc 0 {
          while eq done 0 {
            let node = cast ptr load64 + + arg_list Ast.node * sizeof ptr i;
            { let _ = _typecheck(block, fs, node); }
            let arg_in_type: Type = 0;
            ts_top(at arg_in_type);

            if eq type_base(at type) TypeSyscallFunc {
              // any type is allowed here
              // we still want to type check the arguments of the call
              // which is why this is here instead of outside the loop
            }
            else {
              let arg_type: Type = 0;
              memcpy(at arg_type, + + func_sig Func_signature.args * sizeof Type i, sizeof Type);

              if and eq type_base(at arg_type) TypeFunc eq type_base(at arg_in_type) TypeFunc {
                let func_sig_a = func_signature_from_id(type_sub_id(at arg_type));
                let func_sig_b = func_signature_from_id(type_sub_id(at arg_in_type));
                if eq func_signatures_compare(func_sig_a, func_sig_b) 0 {
                  let buffer_size = DEFAULT_TYPE_BUFFER_SIZE;
                  let in_type_str: u8[buffer_size] = 0;
                  let type_str: u8[buffer_size] = 0;
                  type_to_buffer(@type_str, buffer_size, at arg_type);
                  type_to_buffer(@in_type_str, buffer_size, at arg_in_type);
                  let args: any = at in_type_str, at type_str;
                  typecheck_error_at(+ node Ast.token, "type mismatch in function call, got `%s`, but `%s` was expected\n", @args);
                  store64 @done 1;
                }
              }
              else if and
                  neq types_are_equal(at arg_type, at arg_in_type) 1
                  neq type_base(at arg_type) TypeAny {
                let buffer_size = DEFAULT_TYPE_BUFFER_SIZE;
                let in_type_str: u8[buffer_size] = 0;
                let type_str: u8[buffer_size] = 0;
                type_to_buffer(@type_str, buffer_size, at arg_type);
                type_to_buffer(@in_type_str, buffer_size, at arg_in_type);
                let args: any = at in_type_str, at type_str;
                typecheck_error_at(+ node Ast.token, "type mismatch in function call, got `%s`, but `%s` was expected\n", @args);
                store64 @done 1;
              }
            }
            { let _ = vs_pop(cast ptr<Value> null); }
            ts_pop(cast ptr<Type> null);
            if eq i 0 {
              store64 @done 1;
            }
            else {
              store64 @i - i 1;
            }
          }
        }

        let rtype: Type = 0;
        memcpy(at rtype, + func_sig Func_signature.rtype, sizeof Type);
        if neq type_base(at rtype) TypeNone {
          store64 + ast Ast.konst load64 + + symbol Symbol.value Value.konst;
          { let _ = vs_push(cast ptr<Value> + symbol Symbol.value); }
          ts_push(at rtype, cast ptr<Type> null);
        }
      }
      else {
        let message = cast cstr tmp_it;
        let args: any = + symbol Symbol.name, load64 + func_sig Func_signature.argc, load64 + arg_list Ast.count;
        sprintf(cast ptr message, "function `%s` takes %d argument(s), but %d was given\n", @args);
        compile_error_at(+ ast Ast.token, message);
      }
    }
    else {
      let type: Type = 0;
      memcpy(at type, + symbol Symbol.type, sizeof Type);
      let buffer_size = DEFAULT_TYPE_BUFFER_SIZE;
      let type_str: u8[buffer_size] = 0;
      type_to_buffer(@type_str, buffer_size, at type);
      let args: any = at type_str;
      typecheck_error_at(+ ast Ast.token, "function calls of type `%s` is not permitted\n", @args);
    }
  }
  else {
    let message = tmp_it;
    let args: any = load64 + @token_buffer Buffer.data, load64 + @token_buffer Buffer.length;
    sprintf(cast ptr message, "symbol `%*s` not defined\n", @args);
    compile_error_at(+ ast Ast.token, cast cstr message);
    store64 @tmp_it message;
  }
  load64 + c Compile.status;
}

fn typecheck_assignment(block: ptr<Block>, fs: ptr<Function>, ast: ptr) -> u64 {
  let first = cast ptr load64 + + ast Ast.node * sizeof ptr 0;
  let second = cast ptr load64 + + ast Ast.node * sizeof ptr 1;
  { let _ = _typecheck(block, fs, first); }
  let a: Type = 0;
  ts_pop(at a);
  { let _ = _typecheck(block, fs, second); }
  let b: Type = 0;
  ts_pop(at b);
  if or eq type_base(at a) TypePtr eq type_base(at a) TypeAny {
    let deref_a: Type = 0;
    type_deflate(at a, at deref_a);
    if types_are_equal(at deref_a, at b) {
      { let _ = vs_pop(cast ptr<Value> null); }
      { let _ = vs_pop(cast ptr<Value> null); }
      // just to get things up and running i'm sticking with the `type context` way of passing on types to the ir
      // might just slap on type as well as value directly onto the ast later on
      let type_context: Type_context = 0;
      type_context_init(at type_context);
      memcpy(+ at type_context Type_context.type, at deref_a, sizeof Type);
      store64 + at type_context Type_context.symbol_id UINT64_MAX;
      let id = type_context_push(at type_context);
      assert(neq id UINT64_MAX, "failed to push type context\n"); // TODO(lucas): handle error
      store64 + ast Ast.type_context_id id;
    }
    else {
      typecheck_error_at(+ first Ast.token, "type mismatch in assignment statement\n", null);
    }
  }
  else {
    typecheck_error_at(+ first Ast.token, "type mismatch in assignment statement\n", null);
  }
  load64 + c Compile.status;
}

fn typecheck_store_operation(block: ptr<Block>, fs: ptr<Function>, ast: ptr) -> u64 {
  let first = cast ptr load64 + + ast Ast.node * sizeof ptr 0;
  let second = cast ptr load64 + + ast Ast.node * sizeof ptr 1;
  { let _ = _typecheck(block, fs, first); }
  let a: Type = 0;
  ts_pop(at a);
  { let _ = _typecheck(block, fs, second); }
  if or eq type_base(at a) TypePtr eq type_base(at a) TypeAny {
    ts_pop(cast ptr<Type> null);
    { let _ = vs_pop(cast ptr<Value> null); }
    { let _ = vs_pop(cast ptr<Value> null); }
  }
  else {
    typecheck_error_at(+ first Ast.token, "type mismatch in store statement\n", null);
  }
  load64 + c Compile.status;
}


fn typecheck_while_statement(block: ptr<Block>, fs: ptr<Function>, ast: ptr) -> u64 {
  let cond = cast ptr load64 + + ast Ast.node * sizeof ptr 0;
  let body = cast ptr load64 + + ast Ast.node * sizeof ptr 1;
  { let _ = _typecheck(block, fs, cond); }
  let type: Type = 0;
  ts_pop(at type); // pop type of condition result
  { let _ = vs_pop(cast ptr<Value> null); } // pop value of condition result
  if or or eq type_base(at type) TypeCString eq type_base(at type) TypePtr is_numerical(at type) {
    let local_block = block_push(cast ptr<Block> block);
    { let _ = _typecheck(local_block, fs, body); }
    block_pop(); // local_block
    store64 + ast Ast.konst is_branch_konst_eval(ast);
  }
  else {
    typecheck_error_at(+ cond Ast.token, "invalid type in while statement condition\n", null);
  }
  load64 + c Compile.status;
}


fn typecheck_if_statement(block: ptr<Block>, fs: ptr<Function>, ast: ptr) -> u64 {
  let cond = cast ptr load64 + + ast Ast.node * sizeof ptr 0;
  let body = cast ptr load64 + + ast Ast.node * sizeof ptr 1;
  { let _ = _typecheck(block, fs, cond); }
  let cond_konst = is_branch_konst_eval(cond);
  store64 + cond Ast.konst cond_konst;

  let type: Type = 0;
  ts_pop(at type); // pop type of condition result
  let value: Value = 0;
  { let _ = vs_pop(at value); } // pop value of condition result

  if or or eq type_base(at type) TypeCString eq type_base(at type) TypePtr is_numerical(at type) {
    let collapse = 0;
    if cond_konst {
      let else_body = null;
      if eq ast_child_count(ast) 3 {
        store64 @else_body load64 + + ast Ast.node * sizeof ptr 2;
      }
      if neq load64 + at value Value.num 0 {
        // if statement condition is true, remove potential else branch
        // move body of if statement to the current ast branch
        if else_body {
          ast_pop(ast); // remove else body branch
        }
        ast_move(ast, body);
        { let _ = _typecheck(block, fs, ast); } // typecheck if body
      }
      else if else_body {
        // if statement condition is false, move body of potential else to the current ast branch
        ast_move(ast, else_body);
        { let _ = _typecheck(block, fs, ast); } // typecheck else body
      }
      else {
        // single if statment with a false condition, remove it
        ast_clear(ast); // clear the contents of the node
        ast_init_node(ast, AstNone);
      }
      store64 @collapse 1;
    }

    if eq collapse 0 {
      let local_block = block_push(block);
      { let _ = _typecheck(local_block, fs, body); }
      block_pop(); // local_block

      if eq load64 + ast Ast.count 3 {
        let else_body = cast ptr load64 + + ast Ast.node * sizeof ptr 2;
        let else_local_block = block_push(block);
        { let _ = _typecheck(else_local_block, fs, else_body); }
        block_pop(); // else_local_block
      }
    }
    store64 + ast Ast.konst is_branch_konst_eval(ast);
  }
  else {
    typecheck_error_at(+ cond Ast.token, "invalid type in if statement condition\n", null);
  }
  load64 + c Compile.status;
}

fn typecheck_sizeof(block: ptr<Block>, fs: ptr<Function>, ast: ptr) -> u64 {
  // t: ptr<Token>
  let t = cast ptr + ast Ast.token;
  let size: u64 = 0;
  let token_type = load64 + t Token.type;
  if or eq token_type T_UNSIGNED64 eq token_type T_NUMBER {
    store64 @size sizeof u64;
  }
  else if eq token_type T_UNSIGNED32 {
    store64 @size sizeof u32;
  }
  else if eq token_type T_UNSIGNED16 {
    store64 @size sizeof u16;
  }
  else if eq token_type T_UNSIGNED8 {
    store64 @size sizeof u8;
  }
  else if or or or
    eq token_type T_PTR
    eq token_type T_CSTRING
    eq token_type T_CSTR
    eq token_type T_ANY {
    store64 @size sizeof ptr;
  }
  else if eq token_type T_IDENTIFIER {
    let symbol = null;
    let buffer: Buffer = 0;
    buffer_init(at buffer, cast ptr load64 + t Token.buffer, load64 + t Token.length);
    if eq compile_lookup_value(block, fs, @buffer, @symbol, null, null) NoError {
      let type = cast ptr<Type> + symbol Symbol.type;
      store64 @size * load64 + type Type.count load64 + type Type.size;
    }
    else {
      typecheck_error_at(cast ptr t, "symbol not defined\n", null);
    }
  }
  else {
    assert(0, "type not implemented yet\n");
  }
  let value: Value = 0;
  store64 + @value Value.num size;
  store64 + @value Value.konst 1;
  { let _ = vs_push(at value); }
  store64 + t Token.v size;
  store64 + ast Ast.konst 1;
  ts_push_primitive(TypeUnsigned64, cast ptr<Type> null);
  load64 + c Compile.status;
}

fn typecheck_enum(block: ptr<Block>, fs: ptr<Function>, ast: ptr) -> u64 {
  let type_node = cast ptr load64 + + ast Ast.node * sizeof ptr 0;
  let enum_node = cast ptr load64 + + ast Ast.node * sizeof ptr 1;
  let value: Value = 0;
  store64 + @value Value.num 0;
  store64 + @value Value.konst 1;
  let i: u64 = 0;
  let count: u64 = load64 + enum_node Ast.count;

  let type: Type = 0;
  token_to_compile_type(block, fs, + type_node Ast.token, null, at type);
  if is_numerical(at type) {
    while < i count {
      let node = cast ptr load64 + + enum_node Ast.node * sizeof ptr i;
      let symbol: ptr = null;
      let symbol_index: u64 = UINT64_MAX;
      let imm: u64 = compile_push_value(+ @value Value.num, sizeof u64);

      if eq compile_declare_value(block, fs, + node Ast.token, @symbol, @symbol_index) NoError {
        store64 + symbol Symbol.imm imm;
        store64 + symbol Symbol.size compile_type_size(type_base(at type));
        store64 + symbol Symbol.konst 1;
        if eq cast u64 block + c Compile.global {
          store64 + symbol Symbol.sym_type SYM_GLOBAL_VAR;
        }
        else {
          store64 + symbol Symbol.sym_type SYM_LOCAL_VAR;
        }
        memcpy(+ symbol Symbol.type, at type, sizeof Type);
        memcpy(+ symbol Symbol.value, @value, sizeof Value);
      }
      else {
        compile_error_at(+ node Ast.token, "symbol already exists\n");
      }

      store64 + @value Value.num + 1 load64 + @value Value.num;
      store64 @i + 1 i;
    }
  }
  else {
    typecheck_error_at(+ type_node Ast.token, "expected numerical type in enumerator expression\n", null);
  }
  load64 + c Compile.status;
}

fn typecheck_structure(block: ptr<Block>, fs: ptr<Function>, ast: ptr, is_union: u64) -> u64 {
  let fields = cast ptr load64 + + ast Ast.node * sizeof ptr 0;
  let field_offset: u64 = 0;
  let i: u64 = 0;
  let count: u64 = load64 + fields Ast.count;
  let fail: u64 = 0;

  let struct_name: Buffer = 0;
  buffer_init(
    at struct_name,
    cast ptr load64 + + ast Ast.token Token.buffer,
    load64 + + ast Ast.token Token.length
  );

  let type_info: Struct_type_info = 0;
  struct_type_info_init(at type_info, cast ptr<u8[MAX_NAME_SIZE]> load64 + at struct_name Buffer.data, load64 + at struct_name Buffer.length);
  let struct_type_field: Struct_field = 0;
  let largest_field_offset = 0; // for unions

  while and eq fail 0 < i count {
    let field = cast ptr load64 + + fields Ast.node * sizeof ptr i;
    let field_type_node = cast ptr load64 + + field Ast.node * sizeof ptr 0; // type + array specifier
    let field_name = cast cstr load64 + + field Ast.token Token.buffer;
    let field_length = load64 + + field Ast.token Token.length;

    let it = tmp_it;
    tmp_push_str(cast cstr load64 + at struct_name Buffer.data, load64 + at struct_name Buffer.length);
    tmp_push_cstr(".");
    tmp_push_str(load64 + + field Ast.token Token.buffer, load64 + + field Ast.token Token.length);

    store64 + + field Ast.token Token.buffer it;
    store64 + + field Ast.token Token.length - tmp_it it;

    let symbol: ptr = null;
    let symbol_index: u64 = UINT64_MAX;
    let imm: u64 = compile_push_value(@field_offset, sizeof field_offset);
    let value: Value = 0;
    store64 + @value Value.num field_offset;
    store64 + @value Value.konst 1;

    if eq compile_declare_value(block, fs, + field Ast.token, @symbol, @symbol_index) NoError {
      store64 + symbol Symbol.imm imm;
      store64 + symbol Symbol.size sizeof u64;
      store64 + symbol Symbol.konst 1;
      if eq cast u64 block + c Compile.global {
        store64 + symbol Symbol.sym_type SYM_GLOBAL_VAR;
      }
      else {
        store64 + symbol Symbol.sym_type SYM_LOCAL_VAR;
      }
      type_init(cast ptr<Type> + symbol Symbol.type, TypeUnsigned64, 0, sizeof u64, 1);
      memcpy(+ symbol Symbol.value, @value, sizeof Value);

      let field_size: u64 = 0;
      let field_type: Type = 0;

      if eq type_contract_from_type_node(block, fs, field_type_node, TYPE_CONTRACT_CREATE, at field_type, 0) NoError {
        let type_id: u64 = type_lookup(at field_type);
        store64 @field_size compile_type_size(type_id);
      }
      else {
        typecheck_error_at(+ field_type_node Ast.token, "unknown or invalid type in struct field\n", null);
      }

      store64 @field_size * load64 + at field_type Type.size load64 + at field_type Type.count;

      // done constructing this struct field
      if eq fail 0 {
        { let _ = struct_field_init(at struct_type_field, cast ptr<u8[MAX_NAME_SIZE]> field_name, field_length, at field_type, field_offset); }
        { let _ = struct_create_field(at type_info, at struct_type_field); }
      }

      // update field offset
      store64 @field_offset + field_offset field_size;
      if is_union {
        if < largest_field_offset field_offset {
          store64 @largest_field_offset field_offset;
        }
        store64 @field_offset 0;
      }
    }
    else {
      compile_error_at(+ field Ast.token, "symbol already exists\n");
      store64 @fail 1;
    }
    store64 @i + 1 i;
  }
  // struct symbol definition
  let symbol: ptr = null;
  let symbol_index: u64 = UINT64_MAX;
  let value: Value = 0;
  memset(@value, 0, sizeof Value);

  if is_union {
    store64 @field_offset largest_field_offset;
  }

  if eq compile_declare_value(block, fs, + ast Ast.token, @symbol, @symbol_index) NoError {
    store64 + symbol Symbol.imm UINT64_MAX;
    store64 + symbol Symbol.size field_offset;
    store64 + symbol Symbol.konst 0;
    if eq cast u64 block + c Compile.global {
      store64 + symbol Symbol.sym_type SYM_GLOBAL_VAR;
    }
    else {
      store64 + symbol Symbol.sym_type SYM_LOCAL_VAR;
    }
    let type: Type = 0;
    let primitive_type = TypeStruct;
    if is_union {
      store64 @primitive_type TypeUnion;
    }
    type_init(
      at type,
      primitive_type,
      load64 + c Compile.struct_id,
      field_offset, // size
      1
    );
    { let _ = struct_type_push(at type_info); }
    memcpy(+ symbol Symbol.type, at type, sizeof Type);
    memcpy(+ symbol Symbol.value, @value, sizeof Value);

    let new_type_id: u64 = type_commit_new(at type); // TODO(lucas): handle error
  }
  else {
    compile_error_at(+ ast Ast.token, "symbol already exists\n");
  }
  load64 + c Compile.status;
}

fn typecheck_struct(block: ptr<Block>, fs: ptr<Function>, ast: ptr) -> u64 {
  typecheck_structure(block, fs, ast, 0);
}

fn typecheck_union(block: ptr<Block>, fs: ptr<Function>, ast: ptr) -> u64 {
  typecheck_structure(block, fs, ast, 1);
}

fn typecheck_cast_expr(block: ptr<Block>, fs: ptr<Function>, ast: ptr) -> u64 {
  let type_expr = cast ptr load64 + + ast Ast.node * sizeof ptr 0;
  let expr = cast ptr load64 + + ast Ast.node * sizeof ptr 1;
  { let _ = _typecheck(block, fs, expr); }
  let expr_type: Type = 0;
  ts_pop(at expr_type);
  let cast_type: Type = 0;
  { let _ = type_contract_from_type_node(block, fs, type_expr, TYPE_CONTRACT_CREATE, at cast_type, 0); }
  if neq type_base(at cast_type) TypeNone {
    ts_push(at cast_type, cast ptr<Type> null);
  }
  else {
    let buffer_size = DEFAULT_TYPE_BUFFER_SIZE;
    let from_str: u8[buffer_size] = 0;
    let to_str: u8[buffer_size] = 0;
    type_to_buffer(@from_str, buffer_size, at expr_type);
    type_to_buffer(@to_str, buffer_size, at cast_type);
    let args: any = at from_str, at to_str;
    typecheck_error_at(+ type_expr Ast.token, "cannot cast from type `%s` to `%s`\n", @args);
  }
  load64 + c Compile.status;
}

fn typecheck_static_assert(block: ptr<Block>, fs: ptr<Function>, ast: ptr) -> u64 {
  let expr = cast ptr load64 + + ast Ast.node * sizeof ptr 0;
  let node = cast ptr load64 + + ast Ast.node * sizeof ptr 1;
  { let _ = _typecheck(block, fs, expr); }
  ts_pop(cast ptr<Type> null);
  let value: Value = 0;
  { let _ = vs_pop(at value); }
  if eq load64 + @value Value.konst 0 {
    typecheck_error("can not do static assert on an expression that is evaluated at runtime\n");
  }
  else if eq load64 + @value Value.num 0 {
    let node_token = cast ptr + node Ast.token;
    let message = cast cstr tmp_it;
    tmp_push_cstr("[static assertion failed]: ");
    tmp_push_str(load64 + node_token Token.buffer, load64 + node_token Token.length);
    tmp_push_cstr("\n");
    tmp_push_byte(cast u8 0);
    compile_error_at(+ expr Ast.token, message);
    store64 @tmp_it message;
  }
  load64 + c Compile.status;
}

// FIELD ACCESS
//
// the typechecker is only concerned with the final field that is going to be accessed,
// however the ir code generator needs information about how to actually access that field.
// if an intermediate field is a pointer to some data, that pointer needs to be accessed in some way.
//
// typechecker needs:
//    - type of the accessed field, to be pushed onto the type stack, and that's it.
// ir needs:
//    - (at minimum): type of field, offset to said field
//    - (at most): a stack of intermediate fields (or some other representation), containing the offsets and types of those fields.
//        that way, the ir knows how to generate code to access the data of the field in question.
//
// example:
//
// struct B (
//    x: u64,
//    y: u64
// );
//
// struct A (
//    a: u64,
//    b: ptr<B>
// );
//
// fn hello -> none {
//    let a: A = 0;
//    print :a:b:x;
//    print load64 + (load64 + at a A.b) 8; // :a:b:y
// }
//
// the generated code for `:a:b:x` would be along the lines of:
//    I_PUSH_LOCAL 8 | as :a is on the stack we can directly access :b from here (offset of 8 will point to A.b)
//    I_PUSH_IMM   8 | we want to access B.y, which has an offset of 8
//    I_ADD          | add that offset to the pointer of A.b
//    I_LOADx        | load y based on its type
//                   | we're done
//
fn typecheck_field_access_collect(block: ptr<Block>, fs: ptr<Function>, ast: ptr, type_context: ptr<Type_context>) -> u64 {
  let symbol = null;
  let symbol_id = UINT64_MAX;
  let buffer: Buffer = 0;
  buffer_init(at buffer, cast ptr load64 + + ast Ast.token Token.buffer, load64 + + ast Ast.token Token.length);
  if eq compile_lookup_value(block, fs, @buffer, @symbol, @symbol_id, null) NoError {
    store64 + type_context Type_context.symbol_id symbol_id;
    let type = cast ptr<Type> + symbol Symbol.type;
    if eq type_base(type) TypeStruct {
      let field_nodes = cast ptr + ast Ast.node;
      let i = 0;
      let count = load64 + ast Ast.count;

      let struct_type_info = struct_fetch_type_info(type_sub_id(type));
      let struct_field = cast ptr<Struct_field> null;
      let offset = 0;

      while < i count {
        let node = cast ptr load64 + field_nodes * sizeof ptr i;
        let field_name: u8[MAX_NAME_SIZE] = 0;
        memset(at field_name, 0, sizeof field_name);
        memcpy(at field_name, load64 + + node Ast.token Token.buffer, load64 + + node Ast.token Token.length);
        store64 at struct_field struct_lookup_field(struct_type_info, at field_name);
        if struct_field {
          store64 @offset + offset load64 + struct_field Struct_field.offset;
          store64 @type + struct_field Struct_field.type;
          if eq type_base(type) TypeStruct {
            // update struct_type_info as this field is a struct
            store64 @struct_type_info struct_fetch_type_info(type_sub_id(type));
          }
        }
        else {
          let args: any = + struct_type_info Struct_type_info.name, at field_name;
          typecheck_error_at(+ node Ast.token, "struct `%s` has no field named `%s`\n", @args);
        }
        store64 @i + 1 i;
      }

      if type_context {
        memcpy(+ type_context Type_context.type, type, sizeof Type);
        store64 + type_context Type_context.offset offset;
      }
    }
    else {
      typecheck_error_at(+ ast Ast.token, "field access is only allowed on struct types\n", null);
    }
  }
  else {
    compile_error_at(+ ast Ast.token, "symbol not defined\n");
  }
  load64 + c Compile.status;
}

fn typecheck_field_access(block: ptr<Block>, fs: ptr<Function>, ast: ptr) -> u64 {
  let type_context: Type_context = 0;
  type_context_init(at type_context);
  if eq typecheck_field_access_collect(block, fs, ast, at type_context) NoError {
    let id = type_context_push(at type_context);
    if neq id UINT64_MAX {
      store64 + ast Ast.type_context_id id;
      ts_push(cast ptr<Type> + at type_context Type_context.type, cast ptr<Type> null);
      let value: Value = 0;
      memset(at value, 0, sizeof Value);
      { let _ = vs_push(at value); }
    }
    else {
      assert(0, "failed to push type context\n"); // TODO(lucas): handle error
    }
  }
  load64 + c Compile.status;
}

fn typecheck_undefined(block: ptr<Block>, fs: ptr<Function>, ast: ptr) -> u64 {
  let message = cast cstr tmp_it;
  let ast_type = load64 + ast Ast.type;
  sprintf(cast ptr message, "undefined AST node with id `%d`\n", @ast_type);
  assert(0, message);
  load64 + c Compile.status;
}

fn typecheck(block: ptr<Block>, fs: ptr<Function>, ast: ptr) -> u64 {
  if eq load64 + c Compile.status NoError {
    let ast_type = load64 + ast Ast.type;
    if < ast_type MAX_AST_TYPE {
      let func = cast typecheck_function load64 + at typecheck_funcs * sizeof ptr ast_type;
      let _ = func(block, fs, ast);
    }
  }
  load64 + c Compile.status;
}

fn typecheck_program(ast: ptr) -> u64 {
  assert(cast u64 ast, "something went very wrong\n");
  store64 @_typecheck typecheck;
  store64 @_type_print type_print;
  store64 @_type_printline type_printline;
  store64 @_type_write_to_buffer type_write_to_buffer;

  store64 + @typecheck_funcs * sizeof ptr AstNone             typecheck_none;
  store64 + @typecheck_funcs * sizeof ptr AstRoot             typecheck_undefined;
  store64 + @typecheck_funcs * sizeof ptr AstValue            typecheck_value;
  store64 + @typecheck_funcs * sizeof ptr AstExpression       typecheck_expr;
  store64 + @typecheck_funcs * sizeof ptr AstExprList         typecheck_list_of_nodes;
  store64 + @typecheck_funcs * sizeof ptr AstStatement        typecheck_list_of_nodes;
  store64 + @typecheck_funcs * sizeof ptr AstStatementList    typecheck_list_of_nodes;
  store64 + @typecheck_funcs * sizeof ptr AstBlockStatement   typecheck_block_statement;
  store64 + @typecheck_funcs * sizeof ptr AstBinopExpression  typecheck_binop_expr;
  store64 + @typecheck_funcs * sizeof ptr AstUopExpression    typecheck_uop_expr;
  store64 + @typecheck_funcs * sizeof ptr AstConstStatement   typecheck_let_statement;
  store64 + @typecheck_funcs * sizeof ptr AstLetStatement     typecheck_let_statement;
  store64 + @typecheck_funcs * sizeof ptr AstFuncDefinition   typecheck_func_definition;
  store64 + @typecheck_funcs * sizeof ptr AstFuncCall         typecheck_func_call;
  store64 + @typecheck_funcs * sizeof ptr AstParamList        typecheck_undefined;
  store64 + @typecheck_funcs * sizeof ptr AstAssignment       typecheck_assignment;
  store64 + @typecheck_funcs * sizeof ptr AstStore            typecheck_store_operation;
  store64 + @typecheck_funcs * sizeof ptr AstWhileStatement   typecheck_while_statement;
  store64 + @typecheck_funcs * sizeof ptr AstIfStatement      typecheck_if_statement;
  store64 + @typecheck_funcs * sizeof ptr AstType             typecheck_undefined;
  store64 + @typecheck_funcs * sizeof ptr AstSizeof           typecheck_sizeof;
  store64 + @typecheck_funcs * sizeof ptr AstEnum             typecheck_enum;
  store64 + @typecheck_funcs * sizeof ptr AstStruct           typecheck_struct;
  store64 + @typecheck_funcs * sizeof ptr AstUnion            typecheck_union;
  store64 + @typecheck_funcs * sizeof ptr AstCastExpression   typecheck_cast_expr;
  store64 + @typecheck_funcs * sizeof ptr AstStaticAssert     typecheck_static_assert;
  store64 + @typecheck_funcs * sizeof ptr AstArg              typecheck_undefined;
  store64 + @typecheck_funcs * sizeof ptr AstFieldAccess      typecheck_field_access;

  let time_start: Timespec = 0;
  let time_end: Timespec = 0;
  get_time(at time_start);

  let _ = typecheck(cast ptr<Block> + c Compile.global, cast ptr<Function> null, cast ptr load64 + + ast Ast.node * sizeof ptr 0);
  get_time(at time_end);

  if neq load64 + c Compile.vs_count 0 {
    typecheck_error("unhandled data on the value stack\n");
  }

  if and neq load64 + c Compile.ts_count 0 eq load64 + c Compile.status NoError {
    typecheck_error("unhandled data on the type stack\n");
  }

  if eq load64 + c Compile.status NoError {
    print_time_elapsed("type checking took", at time_start, at time_end);
    typecheck_print_unused();
    assert(eq load64 + c Compile.block_count 0, "block stack not empty\n");
  }

  typecheck_print_stack(STDOUT_FILENO);

  load64 + c Compile.status;
}
