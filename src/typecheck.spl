// typecheck.spl

// TODO(lucas): temporary, allow passing and pushing structs of any size
const MAX_STRUCT_SIZE = sizeof u64;

enum u64 (
  TYPE_CONTRACT_LOOKUP,
  TYPE_CONTRACT_CREATE
);

enum u64 (
  TYPE_CONSTRAINT_VALID, // valid constraint, we're good to continue
  TYPE_CONSTRAINT_INVALID,  // not a valid constraint, stop
  TYPE_CONSTRAINT_UNDECIDABLE // unwrapping of type is needed, thus we can not decide if the constraint is valid or not at this moment
);

fn typecheck_function(block : ptr, fs : ptr, ast : ptr) -> u64 0;
let _typecheck = typecheck_function;
fn type_print_func_sig(fd : u64, type : ptr<Type>) -> none {}
let _type_print = type_print_func_sig;
let _type_printline = type_print_func_sig;

fn typecheck_print_unused -> none {
  if not load64 + @options Options.disable_dce {
    let i = MAX_SYSCALL_FUNCTION;
    let count = load64 + c Compile.symbol_count;
    while < i count {
      let symbol : Symbol = 0;
      memcpy(@symbol, + + c Compile.symbols * sizeof Symbol i, sizeof Symbol);
      let ref_count = load64 + @symbol Symbol.ref_count;
      let sym_type = load64 + @symbol Symbol.sym_type;
      if and eq ref_count 0 eq sym_type SYM_FUNC {
        let args : any = (
          + @symbol Symbol.name
        );
        warning_at(+ @symbol Symbol.token, "`%s` defined but not used\n", @args);
      }
      store64 @i + 1 i;
    }
  }
}

fn typecheck_error(message : cstr) -> none {
  if eq load64 + c Compile.status NoError {
    dprintf(STDERR_FILENO, "[typecheck-error]: %s", @message);
    store64 + c Compile.status Error;
  }
  store64 + c Compile.error_count + 1 load64 + c Compile.error_count;
}

// token : Token*
fn typecheck_error_at(token : ptr, format : cstr, args : any) -> none {
  const fd : u64 = STDERR_FILENO;
  if eq load64 + c Compile.status NoError {
    {
      let args : any = (
        load64 + token Token.filename,
        load64 + token Token.line,
        load64 + token Token.column
      );
      dprintf(fd, "[typecheck-error]: %s:%d:%d: ", @args);
    }
    dprintf(fd, format, args);
    printline(fd, cast cstr load64 + token Token.source, cast cstr load64 + token Token.buffer, load64 + token Token.length, 1, NUM_LINES_TO_PRINT);
    store64 + c Compile.status Error;
  }
  store64 + c Compile.error_count + 1 load64 + c Compile.error_count;
}

fn struct_field_init(field : ptr<Struct_field>, name : ptr<u8>, length : u64, type : ptr<Type>, count : u64, offset : u64) -> u64 {
  let result = Error;
  if < length MAX_NAME_SIZE {
    strncpy(cast cstr + field Struct_field.name, cast cstr name, length);
    memcpy(+ field Struct_field.type, type, sizeof Type);
    store64 + field Struct_field.count count;
    store64 + field Struct_field.offset offset;
    store64 @result NoError;
  }
  result;
}

fn struct_type_info_init(info : ptr<Struct_type_info>) -> none {
  store64 + info Struct_type_info.count 0;
}

fn struct_lookup_field(info : ptr<Struct_type_info>, name : ptr<u8>) -> ptr<Struct_field> {
  let result = cast ptr<Struct_field> NULL;

  let i = 0;
  let count = load64 + info Struct_type_info.count;
  while < i count {
    let lookup = cast ptr<Struct_field> + + info Struct_type_info.fields * sizeof Struct_field i;
    if eq strncmp(cast cstr + lookup Struct_field.name, cast cstr name, MAX_NAME_SIZE) 0 {
      store64 @result lookup;
    }
    store64 @i + 1 i;
  }

  result;
}

fn struct_create_field(info : ptr<Struct_type_info>, field : ptr<Struct_field>) -> u64 {
  let result = Error;
  if eq struct_lookup_field(info, cast ptr<u8> + field Struct_field.name) NULL {
    let index = cast ptr<u64> + info Struct_type_info.count;
    let new_field = cast ptr<Struct_field> + + info Struct_type_info.fields * sizeof Struct_field deref index;
    store64 index + 1 deref index;
    memcpy(new_field, field, sizeof Struct_field);
    store64 @result NoError;
  }
  result;
}

fn struct_fetch_field(info : ptr<Struct_type_info>, field_index : u64) -> ptr<Struct_field> {
  let result = cast ptr<Struct_field> NULL;
  let count = load64 + info Struct_type_info.count;
  if < field_index count {
    store64 @result + + info Struct_type_info.fields * sizeof Struct_field field_index;
  }
  result;
}

fn struct_fetch_type_info(id : u64) -> ptr<Struct_type_info> {
  let result = cast ptr<Struct_type_info> NULL;
  let struct_id = load64 + c Compile.struct_id;
  if < id struct_id {
    store64 @result + + c Compile.struct_type_info * sizeof Struct_type_info id;
  }
  result;
}

fn struct_type_push(info : ptr<Struct_type_info>) -> u64 {
  let result = NoError;
  let struct_id = cast ptr<u64> + c Compile.struct_id;
  memcpy(cast any + + c Compile.struct_type_info * sizeof Struct_type_info deref struct_id, info, sizeof Struct_type_info);
  store64 struct_id + 1 deref struct_id;
  result;
}

fn struct_type_info_print(fd : u64, info : ptr<Struct_type_info>, flat : u64) -> none {
  let i = 0;
  let count = load64 + info Struct_type_info.count;
  dprintf(fd, "(", NULL);
  if eq flat 0 {
    dprintf(fd, "\n", NULL);
  }
  while < i count {
    let field = struct_fetch_field(info, i);
    let field_type : Type = 0;
    let field_count = load64 + field Struct_field.count;

    memcpy(at field_type, + field Struct_field.type, sizeof Type);

    let args : any = (
      + field Struct_field.name
    );
    if eq flat 0 {
      dprintf(fd, "  ", NULL);
    }
    dprintf(fd, "%s : ", @args);
    _type_print(fd, at field_type);
    if > field_count 1 {
      dprintf(fd, " : %d", @field_count);
    }
    store64 @i + 1 i;
    if < i count {
      dprintf(fd, ",", NULL);
      if flat {
        dprintf(fd, " ", NULL);
      }
    }
    if eq flat 0 {
      dprintf(fd, "\n", NULL);
    }
  }
  dprintf(fd, ")", NULL);
}

fn struct_type_info_printline(fd : u64, info : ptr<Struct_type_info>, flat : u64) -> none {
  struct_type_info_print(fd, info, flat);
  dprintf(fd, "\n", NULL);
}

// for now `ptr` is the only type that is a container i.e. a type that can contain other types
fn type_is_container(type : ptr<Type>) -> u64 {
  eq type_value(cast ptr type) TypePtr;
}

fn type_print(fd : u64, type : ptr<Type>) -> none {
  // check if this is a container type
  if type_is_container(type) {
    let args : any = (
      load64 + @compile_type_str * sizeof cstr type_value(cast ptr type)
    );
    dprintf(fd, "%s<", @args);
    let next_type : Type = 0;
    memcpy(at next_type, + + c Compile.types * sizeof Type type_id(cast ptr type), sizeof Type);
    type_print(fd, at next_type);
    dprintf(fd, ">", NULL);
  }
  else if eq type_value(cast ptr type) TypeStruct {
    let id = type_id(cast ptr type);
    let args : any = (
      load64 + @compile_type_str * sizeof cstr type_value(cast ptr type),
      id
    );
    dprintf(fd, "%s<%d> ", @args);
    let type_info = struct_fetch_type_info(id);
    struct_type_info_print(fd, type_info, 1);
  }
  else if eq type_value(cast ptr type) TypeFunc {
    let args : any = (
      load64 + @compile_type_str * sizeof cstr type_value(cast ptr type),
      type_id(cast ptr type)
    );
    dprintf(fd, "%s<%d>", @args);
  }
  // primitive type
  else {
    let args : any = (
      load64 + @compile_type_str * sizeof cstr type_value(cast ptr type)
    );
    dprintf(fd, "%s", @args);
  }
}

fn type_printline(fd : u64, type : ptr<Type>) -> none {
  type_print(fd, type);
  dprintf(fd, "\n", NULL);
}

fn typecheck_print_stack(fd : u64) -> none {
  let i = 0;
  let count = load64 + c Compile.ts_count;
  while < i count {
    let type : Type = 0;
    memcpy(at type, + + c Compile.ts * sizeof Type i, sizeof Type);
    let value : Value = 0;
    memcpy(at value, + + c Compile.vs * sizeof Value i, sizeof Value);
    dprintf(fd, "%d: ", @i);
    type_print(fd, at type);
    let args : any = load64 + @value Value.num;
    dprintf(fd, " = %d\n", @args);
    store64 @i + 1 i;
  }
}

fn compile_type_size(type_id : u64) -> u64 {
  let result = 0;
  if < type_id load64 + c Compile.type_count {
    store64 @result load64 + + c Compile.type_sizes * sizeof u64 type_id;
  }
  result;
}

fn type_lookup(type : ptr<Type>) -> u64 {
  let result : u64 = UINT64_MAX;
  let done : u64 = 0;
  let i : u64 = 0;
  let type_count : u64 = load64 + c Compile.type_count;
  while and eq done 0 < i type_count {
    let t : Type = 0;
    memcpy(at t, + + c Compile.types * sizeof Type i, sizeof Type);
    if types_are_equal(type, at t) {
      store64 @result i;
      store64 @done 1;
    }
    store64 @i + 1 i;
  }
  result;
}

fn type_from_id(id : u64, type_out : ptr<Type>) -> none {
  let type_count : u64 = load64 + c Compile.type_count;
  if < id type_count {
    memcpy(type_out, + + c Compile.types * sizeof Type id, sizeof Type);
  }
}

fn type_push_new(type : ptr<Type>, size : u64) -> u64 {
  let type_count = cast ptr<u64> + c Compile.type_count;
  let id = deref type_count;
  if < deref type_count MAX_COMPILE_TYPE {
    memcpy(+ + c Compile.types * sizeof Type deref type_count, type, sizeof Type);
    store64 + + c Compile.type_sizes * sizeof u64 deref type_count size;
    store64 type_count + 1 deref type_count;
  }
  else {
    assert(0, "compile type capacity reached, increase capacity\n");
  }
  id; // return id of the newly created type
}

// checks if `type` is valid inside of `container`
fn type_check_constraints(container : ptr<Type>, type : ptr<Type>) -> u64 {
  let result = TYPE_CONSTRAINT_INVALID;
  if type_is_container(container) {
    store64 @result TYPE_CONSTRAINT_VALID;
  }
  else if and eq type_value(cast ptr container) MAX_PRIMITIVE_TYPE > type_value(cast ptr container) MAX_PRIMITIVE_TYPE {
    store64 @result TYPE_CONSTRAINT_UNDECIDABLE;
  }
  result;
}

fn type_deflate(type : ptr<Type>, type_out : ptr<Type>) -> none {
  if type_out {
    type_init(type_out, TypeNone, 0);
  }
  let id = type_id(cast ptr type);
  if neq id 0 {
    if type_is_container(type) {
      if type_out {
        type_from_id(id, type_out);
      }
    }
  }
}

// contract : Type[]
fn type_from_contract(contract : ptr<Type>, count : u64, mode : u64, result_out : ptr<Type>) -> u64 {
  assert(neq count 0, "number of elements in contract must be greater than 0\n");
  let result = NoError;
  let fail : u64 = 0;

  type_init(result_out, TypeNone, 0);

  if eq count 1 {
    let type : Type = 0;
    memcpy(at type, contract, sizeof Type);
    let lookup : u64 = type_lookup(at type);
    if neq lookup UINT64_MAX {
      memcpy(result_out, at type, sizeof Type);
    }
    else {
      store64 @fail 1;
    }
  }

  let i : u64 = - count 1;
  let primary_type : Type = 0;
  type_init(at primary_type, TypeNone, 0);
  let sub_type : Type = 0;
  memcpy(at sub_type, + contract * sizeof Type i, sizeof Type);

  while and eq fail 0 > i 0 {
    memcpy(at primary_type, + contract * sizeof Type - i 1, sizeof Type);
    let sub_type_id = type_lookup(at sub_type);
    if neq sub_type_id UINT64_MAX {
      let type : Type = 0;
      type_init(at type, type_value(@primary_type), sub_type_id);

      let constraint : u64 = type_check_constraints(at primary_type, at sub_type);
      if or eq constraint TYPE_CONSTRAINT_VALID eq constraint TYPE_CONSTRAINT_UNDECIDABLE {
        let lookup : u64 = type_lookup(at type);
        if eq lookup UINT64_MAX {
          // type does not exist, create new type if mode is TYPE_CONTRACT_CREATE
          if eq mode TYPE_CONTRACT_CREATE {
            let lookup = type_lookup(at primary_type);
            let lookup_size = compile_type_size(lookup);
            let new_type_id : u64 = type_push_new(at type, lookup_size);
            assert(neq new_type_id 0, "failed to push new type\n");
            memcpy(result_out, at type, sizeof Type);
            memcpy(at sub_type, at type, sizeof Type); // sub type is now the newly created type
          }
          else {
            store64 @fail 1;
          }
        }
        else {
          // type exists
          memcpy(result_out, at type, sizeof Type);
          memcpy(at sub_type, at type, sizeof Type); // sub type is the newly created type
        }
      }
      else { // constraint failed
        store64 @fail 1;
      }
    }
    else {
      store64 @fail 1;
    }
    store64 @i - i 1;
  }

  if fail {
    store64 @result Error;
  }
  result;
}

fn typecheck_print_types(fd : u64) -> none {
  dprintf(fd, "typecheck_print_types:\n", NULL);
  let i : u64 = 0;
  let count : u64 = load64 + c Compile.type_count;
  while < i count {
    let type : Type = 0;
    memcpy(at type, + + c Compile.types * sizeof Type i, sizeof Type);
    let size : u64 = load64 + + c Compile.type_sizes * sizeof u64 i;

    dprintf(fd, "%d: ", @i);
    type_print(fd, at type);
    dprintf(fd, ": size = %d\n", @size);

    store64 @i + 1 i;
  }
}

fn type_contract_stack_reset -> none {
  store64 + c Compile.type_contract_count 0;
}

fn type_contract_stack_push(type : ptr<Type>) -> u64 {
  let result = NoError;
  let count = cast ptr<u64> + c Compile.type_contract_count;
  if < deref count MAX_TYPE_CONTRACT_STACK {
    memcpy(+ + c Compile.type_contract_stack * sizeof Type deref count, type, sizeof Type);
    store64 count + 1 deref count;
  }
  else {
    store64 @result Error;
  }
  result;
}

// block : Block*, fs : Function*, token : Token*, symbol_out : Symbol**
fn token_to_compile_type(block : ptr, fs : ptr, token : ptr, symbol_out : ptr, type_out : ptr<Type>) -> none {
  type_init(type_out, TypeNone, 0);
  let token_type = load64 + token Token.type;
  if eq token_type T_ANY {
    type_init(type_out, TypeAny, 0);
  }
  else if eq token_type T_PTR {
    type_init(type_out, TypePtr, 0);
  }
  else if eq token_type T_UNSIGNED64 {
    type_init(type_out, TypeUnsigned64, 0);
  }
  else if eq token_type T_UNSIGNED32 {
    type_init(type_out, TypeUnsigned32, 0);
  }
  else if eq token_type T_UNSIGNED16 {
    type_init(type_out, TypeUnsigned16, 0);
  }
  else if eq token_type T_UNSIGNED8 {
    type_init(type_out, TypeUnsigned8, 0);
  }
  else if or eq token_type T_CSTRING eq token_type T_CSTR {
    type_init(type_out, TypeCString, 0);
  }
  else if eq token_type T_IDENTIFIER {
    let symbol = NULL;
    let buffer : Buffer = 0;
    buffer_init(at buffer, cast ptr load64 + token Token.buffer, load64 + token Token.length);
    if eq compile_lookup_value(block, fs, @buffer, @symbol, NULL, NULL) NoError {
      if neq symbol_out NULL {
        store64 symbol_out symbol;
      }
      memcpy(type_out, + symbol Symbol.type, sizeof Type);
    }
  }
}

// result is stored in Compile.type_contract_stack
// Type
//   None | Value
//   Type
// block : ptr<Block>, fs : ptr<Function>, ast : ptr<Ast>
fn collect_types_from_node(block : ptr, fs : ptr, ast : ptr) -> u64 {
  let result = NoError;
  let sub_type_node = NULL;
  if ast {
    let type : Type = 0;
    let symbol = NULL;
    token_to_compile_type(block, fs, + ast Ast.token, @symbol, at type);
    if and symbol eq type_value(@type) TypeNone {
      store64 @result Error;
    }
    else if eq type_contract_stack_push(at type) NoError {
      if eq load64 + ast Ast.count 2 {
        store64 @sub_type_node load64 + + ast Ast.node * sizeof ptr 1;
      }
      store64 @result collect_types_from_node(block, fs, sub_type_node);
      store64 @result NoError;
    }
    else {
      store64 @result Error;
    }
  }
  result;
}

// block : Block*, fs : Function*, ast : Ast*, mode : u64, type_out : Type*
fn type_contract_from_type_node(block : ptr, fs : ptr, ast : ptr, mode : u64, type_out : ptr<Type>, accept_none_type : u64) -> u64 {
  let result = Error;
  let collected_types_result = collect_types_from_node(block, fs, ast);
  if eq collected_types_result NoError {
    let type : Type = 0;
    let contract = cast ptr<Type> + c Compile.type_contract_stack;
    let count : u64 = load64 + c Compile.type_contract_count;
    if eq type_from_contract(contract, count, mode, at type) NoError {
      memcpy(type_out, at type, sizeof Type);
      store64 @result NoError;
      if eq accept_none_type 0 {
        if eq type_value(@type) TypeNone {
          store64 @result Error;
        }
      }
    }
    type_contract_stack_reset();
  }
  result;
}

fn ts_push(type : ptr<Type>, type_out : ptr<Type>) -> none {
  if type_out {
    type_init(type_out, TypeNone, 0);
  }
  let ts_count = cast ptr<u64> + c Compile.ts_count;
  if < deref ts_count MAX_TYPE_STACK {
    memcpy(+ + c Compile.ts * sizeof Type deref ts_count, type, sizeof Type);
    store64 ts_count + 1 deref ts_count;
    if type_out {
      memcpy(type_out, type, sizeof Type);
    }
  }
  else {
    assert(0, "type stack overflow\n");
  }
}

fn ts_push_primitive(primitive : u64, type_out : ptr<Type>) -> none {
  let type : Type = 0;
  type_init(at type, primitive, 0);
  ts_push(at type, type_out);
}

fn ts_pop(type_out : ptr<Type>) -> none {
  if type_out {
    type_init(type_out, TypeNone, 0);
  }
  let ts_count = cast ptr<u64> + c Compile.ts_count;
  if < deref ts_count MAX_TYPE_STACK {
    store64 ts_count - deref ts_count 1;
    if type_out {
      memcpy(type_out, + + c Compile.ts * sizeof Type deref ts_count, sizeof Type);
    }
  }
  else {
    assert(0, "type stack underflow\n");
  }
}

fn ts_top(type_out : ptr<Type>) -> none {
  if type_out {
    type_init(type_out, TypeNone, 0);
  }
  let ts_count = cast ptr<u64> + c Compile.ts_count;
  if < deref ts_count MAX_TYPE_STACK {
    if type_out {
      memcpy(type_out, + + c Compile.ts * sizeof Type - deref ts_count 1, sizeof Type);
    }
  }
}

// value : Value*
fn vs_push(value : ptr) -> u64 {
  let result = NoError;
  if < load64 + c Compile.vs_count MAX_TYPE_STACK {
    memcpy(+ + c Compile.vs * sizeof Value load64 + c Compile.vs_count, value, sizeof Value);
    store64 + c Compile.vs_count + 1 load64 + c Compile.vs_count;
  }
  else {
    assert(0, "value stack overflow\n");
    store64 @result Error;
  }
  result;
}

fn vs_top(value_out : ptr) -> none {
  if < load64 + c Compile.vs_count MAX_TYPE_STACK {
    if value_out {
      memcpy(value_out, + + c Compile.vs * sizeof Value - load64 + c Compile.vs_count 1, sizeof Value);
    }
  }
  else {
    if value_out {
      store64 @value_out NULL;
    }
  }
}

fn vs_pop(value_out : ptr) -> u64 {
  let result = NoError;
  if < load64 + c Compile.vs_count MAX_TYPE_STACK {
    if value_out {
      vs_top(value_out);
    }
    store64 + c Compile.vs_count - load64 + c Compile.vs_count 1;
  }
  else {
    assert(0, "value stack underflow\n");
    store64 @result Error;
  }
  result;
}

fn check_func_signatures(a : ptr, b : ptr) -> u64 {
  let result : u64 = 1;
  if and
    eq load64 + a Function.argc load64 + b Function.argc
    types_are_equal(cast ptr<Type> + a Function.rtype, cast ptr<Type> + b Function.rtype) {

    let i : u64 = 0;
    let argc : u64 = load64 + a Function.argc;
    let done : u64 = 0;
    while and eq done 0 < i argc {
      let arg_a : u64 = load64 + + a Function.argc * sizeof u64 i;
      let arg_b : u64 = load64 + + b Function.argc * sizeof u64 i;
      let type_a : Type = 0;
      memcpy(at type_a, + + + c Compile.symbols * sizeof Symbol arg_a Symbol.type, sizeof Type);
      let type_b : Type = 0;
      memcpy(at type_b, + + + c Compile.symbols * sizeof Symbol arg_b Symbol.type, sizeof Type);
      if eq types_are_equal(at type_a, at type_b) 0 {
        store64 @result 0;
        store64 @done 1;
      }
      store64 @i + 1 i;
    }
  }
  else {
    store64 @result 0;
  }
  result;
}

// ast : Ast*
fn is_branch_konst_eval(ast : ptr) -> u64 {
  let konst = 1;
  let i = 0;
  let count = load64 + ast Ast.count;
  while < i count {
    let node = cast ptr load64 + + ast Ast.node * sizeof ptr i;
    if eq load64 + node Ast.konst 0 {
      store64 @konst 0;
      store64 @i count;
    }
    store64 @i + 1 i;
  }
  konst;
}

fn is_numerical(type : ptr<Type>) -> u64 {
  let value = type_value(cast ptr type);
  or or or
    eq value TypeUnsigned64
    eq value TypeUnsigned32
    eq value TypeUnsigned16
    eq value TypeUnsigned8;
}

fn typecheck_node_list(block : ptr, fs : ptr, ast : ptr) -> u64 {
  let i = 0;
  let count = load64 + ast Ast.count;
  while < i count {
    let _ = _typecheck(block, fs, cast ptr load64 + + ast Ast.node * sizeof ptr i);
    store64 @i + 1 i;
  }
  load64 + c Compile.status;
}

// AST representation:
// LetStatement
//   ExprList
//     Expression
//     ...
//   Type
//     None | Value (array specifier)
//     Type (optional sub type)
fn typecheck_let_statement(block : ptr, fs : ptr, ast : ptr) -> u64 {
  let result = NoError;
  let konst = eq load64 + ast Ast.type AstConstStatement;
  let ts_count = load64 + c Compile.ts_count;
  let num_elements = 1;
  let rhs = cast ptr load64 + + ast Ast.node * sizeof ptr 0;
  let ast_type = NULL;
  if eq load64 + ast Ast.count 2 {
    store64 @ast_type cast ptr load64 + + ast Ast.node * sizeof ptr 1;
  }

  // typecheck the rhs of the statement
  { let _ = typecheck_node_list(block, fs, rhs); }
  store64 + rhs Ast.konst is_branch_konst_eval(rhs);
  store64 + ast Ast.konst is_branch_konst_eval(rhs);

  // make sure that rhs actually produced any values
  let ts_delta = - load64 + c Compile.ts_count ts_count;
  if eq ts_delta 0 {
    typecheck_error_at(+ ast Ast.token, "no value was produced in the rhs of the let statement\n", NULL);
  }
  else {
    let expl_type_symbol = NULL;

    // typecheck explicit type, if there is one
    let explicit_type : Type = 0;
    type_init(at explicit_type, TypeNone, 0);

    // for if the type is a function
    let explicit_type_value : Value = 0;

    if neq ast_type NULL {
      if eq type_contract_from_type_node(block, fs, ast_type, TYPE_CONTRACT_CREATE, at explicit_type, 0) NoError {
        let token : Token = 0;
        memcpy(@token, + ast_type Ast.token, sizeof Token);
        if eq type_value(@explicit_type) TypeNone {
          let message = tmp_it;
          tmp_push_cstr("type `");
          tmp_push_str(load64 + @token Token.buffer, load64 + @token Token.length);
          tmp_push_cstr("` not defined\n");
          tmp_push_byte(cast u8 0);
          typecheck_error_at(@token, cast cstr message, NULL);
          store64 @tmp_it message;
        }
        else {
          if eq type_value(@explicit_type) TypeFunc {
            let id : u64 = type_id(@explicit_type);
            store64 @expl_type_symbol + + c Compile.symbols * sizeof Symbol id;
            memcpy(@explicit_type_value, + expl_type_symbol Symbol.value, sizeof Value);
          }

          // array size specifier
          let array_specifier_node : ptr = NULL;
          let ast_type_count : u64 = load64 + ast_type Ast.count;
          if > ast_type_count 0 {
            store64 @array_specifier_node cast ptr load64 + + ast_type Ast.node * sizeof ptr 0;
          }
          if array_specifier_node {
            if neq load64 + array_specifier_node Ast.type AstNone {
              { let _ = _typecheck(block, fs, array_specifier_node); }
              let value : Value = 0;
              { let _ = vs_pop(@value); }
              let array_specifier_type : Type = 0;
              ts_pop(at array_specifier_type);
              if is_numerical(at array_specifier_type) {
                store64 @num_elements load64 + @value Value.num;
                if > ts_delta num_elements {
                  typecheck_error_at(cast ptr + load64 + ast_type Ast.node Ast.token, "number of elements in rhs exceeded the array size specifier\n", NULL);
                }
              }
              else {
                typecheck_error_at(cast ptr + load64 + ast_type Ast.node Ast.token, "only numeric values are allowed in array size specifier\n", NULL);
              }
            }
          }
        }
      }
      else {
        typecheck_error_at(cast ptr + ast_type Ast.token, "invalid type construction\n", NULL);
      }
    }

    let imm = UINT64_MAX; // index to immediate value, in case this is a constant

    let value : Value = 0;
    let prev_value : Value = 0;
    vs_top(@value);
    vs_top(@prev_value);

    let type : Type = 0;
    ts_top(at type);
    let prev_type : Type = 0;
    ts_top(at prev_type);

    if neq type_value(@explicit_type) TypeNone {
      memcpy(at prev_type, at explicit_type, sizeof Type);
      if eq type_value(@explicit_type) TypeFunc {
        memcpy(@prev_value, @explicit_type_value, sizeof Value);
      }
    }

    if and eq konst 1 eq is_numerical(at type) 0 {
      typecheck_error_at(+ ast Ast.token, "only numeric values are allowed in constants\n", NULL);
    }
    else {
      let i = 0;
      let done = 0;
      while and not done < i ts_delta {
        ts_pop(at type);
        { let _ = vs_pop(@value); }
        if or eq type_value(@explicit_type) TypeStruct eq type_value(@explicit_type) TypeAny {
          // do nothing, all is permitted here
        }
        else {
          if and eq type_value(@type) TypeFunc eq type_value(@prev_type) TypeFunc {
            if eq check_func_signatures(+ @value Value.func, + @prev_value Value.func) 0 {
              typecheck_error_at(+ ast Ast.token, "incompatible type in expression list\n", NULL);
              store64 @done 1;
            }
          }
          else if and is_numerical(at explicit_type) is_numerical(at type) {
            // do nothing, this is ok
          }
          else if eq types_are_equal(at type, at prev_type) 0 {
            typecheck_error_at(+ ast Ast.token, "incompatible type in expression list\n", NULL);
            store64 @done 1;
          }
          memcpy(at prev_type, at type, sizeof Type);
        }
        memcpy(@prev_value, @value, sizeof Value);
        if eq konst 1 {
          store64 @imm compile_push_value(+ @value Value.num, sizeof u64);
        }
        store64 @i + 1 i;
      }
    }

    // no array specifier was used, therefore num_elements is set to however many elements there was in the rhs
    if eq num_elements 1 {
      store64 @num_elements ts_delta;
    }

    if neq type_value(@explicit_type) TypeNone {
      memcpy(at type, at explicit_type, sizeof Type);
    }

    // if this is a constant, make sure to update the immediate value index
    if eq konst 1 {
      let decrement = * - ts_delta 1 compile_type_size(TypeUnsigned64);
      store64 @imm - imm decrement;
    }

    let type_id : u64 = type_lookup(at type);
    assert(neq type_id UINT64_MAX, "invalid type\n");
    let type_size : u64 = compile_type_size(type_id);

    let symbol : ptr = NULL;
    let symbol_index = UINT64_MAX;
    if eq compile_declare_value(block, fs, + ast Ast.token, @symbol, @symbol_index) NoError {
      store64 + symbol Symbol.imm imm;
      store64 + symbol Symbol.size * num_elements type_size;
      store64 + symbol Symbol.num_elements_init ts_delta;
      store64 + symbol Symbol.konst konst;
      if eq cast u64 block + c Compile.global {
        store64 + symbol Symbol.sym_type SYM_GLOBAL_VAR;
      }
      else {
        store64 + symbol Symbol.sym_type SYM_LOCAL_VAR;
      }
      memcpy(+ symbol Symbol.type, at type, sizeof Type);
      memcpy(+ symbol Symbol.value, @value, sizeof Value);
      store64 + + symbol Symbol.token Token.v symbol_index;
      store64 + + ast Ast.token Token.v symbol_index;
      memcpy(at result, at type, sizeof Type);
    }
  }
  result;
}

fn typecheck(block : ptr, fs : ptr, ast : ptr) -> u64 {
  if eq load64 + c Compile.status NoError {
    let ast_type = load64 + ast Ast.type;
    if eq ast_type AstValue {
      let token_type = load64 + + ast Ast.token Token.type;
      if eq token_type T_NUMBER {
        let value : Value = 0;
        store64 + @value Value.num load64 + + ast Ast.token Token.v;
        store64 + @value Value.konst 1;
        store64 + ast Ast.konst 1;
        { let _ = vs_push(@value); }
        ts_push_primitive(TypeUnsigned64, cast ptr<Type> NULL);
      }
      else if eq token_type T_CSTRING {
        let value : Value = 0;
        memset(@value, 0, sizeof Value);
        { let _ = vs_push(@value); }
        ts_push_primitive(TypeCString, cast ptr<Type> NULL);
      }
      else if eq token_type T_IDENTIFIER {
        let symbol : ptr = NULL;
        let symbol_index = UINT64_MAX;
        let token_buffer : Buffer = 0;
        buffer_init(at token_buffer, cast ptr load64 + + ast Ast.token Token.buffer, load64 + + ast Ast.token Token.length);

        if eq compile_lookup_value(block, fs, @token_buffer, @symbol, @symbol_index, NULL) NoError {
          store64 + symbol Symbol.ref_count + 1 load64 + symbol Symbol.ref_count;
          store64 + + ast Ast.token Token.v symbol_index;
          { let _ = vs_push(+ symbol Symbol.value); }
          store64 + ast Ast.konst load64 + + symbol Symbol.value Value.konst;
          let size : u64 = load64 + symbol Symbol.size;
          let type : Type = 0;
          memcpy(at type, + symbol Symbol.type, sizeof Type);
          if and > size MAX_STRUCT_SIZE eq type_value(@type) TypeStruct {
            let args : any = MAX_STRUCT_SIZE;
            typecheck_error_at(+ ast Ast.token, "can not push a struct with size greater than %d\n", @args);
          }
          else {
            ts_push(at type, cast ptr<Type> NULL);
          }
        }
        else {
          let message = tmp_it;
          tmp_push_cstr("symbol `");
          tmp_push_str(load64 + + ast Ast.token Token.buffer, load64 + + ast Ast.token Token.length);
          tmp_push_cstr("` not defined\n");
          tmp_push_byte(cast u8 0);
          compile_error_at(+ ast Ast.token, cast cstr message);
          store64 @tmp_it message;
        }
      }
      else if or eq token_type T_AT eq token_type T_AT_WORD {
        let symbol : ptr = NULL;
        let symbol_index = UINT64_MAX;
        let token_buffer : Buffer = 0;
        buffer_init(at token_buffer, cast ptr load64 + + ast Ast.token Token.buffer, load64 + + ast Ast.token Token.length);
        if eq compile_lookup_value(block, fs, @token_buffer, @symbol, @symbol_index, NULL) NoError {
          store64 + symbol Symbol.ref_count + 1 load64 + symbol Symbol.ref_count;
          store64 + + ast Ast.token Token.v symbol_index;
          let type : Type = 0;
          memcpy(at type, + symbol Symbol.type, sizeof Type);
          if eq token_type T_AT_WORD {
            const count = 2;
            let contract : Type : count = 0;
            type_init(+ at contract * sizeof Type 0, TypePtr, 0);
            memcpy(+ at contract * sizeof Type 1, at type, sizeof Type);
            let ptr_type : Type = 0;
            if eq type_from_contract(at contract, count, TYPE_CONTRACT_CREATE, at ptr_type) NoError {
              { let _ = vs_push(+ symbol Symbol.value); }
              ts_push(at ptr_type, cast ptr<Type> NULL);
            }
            else {
              typecheck_error_at(+ ast Ast.token, "invalid pointer type construction\n", NULL);
            }
          }
          else {
            { let _ = vs_push(+ symbol Symbol.value); }
            let ptr_type : Type = 0;
            type_init(at ptr_type, TypePtr, 0);
            ts_push(at ptr_type, cast ptr<Type> NULL);
          }
        }
        else {
          let message = tmp_it;
          tmp_push_cstr("symbol `");
          tmp_push_str(load64 + + ast Ast.token Token.buffer, load64 + + ast Ast.token Token.length);
          tmp_push_cstr("` not defined\n");
          tmp_push_byte(cast u8 0);
          compile_error_at(+ ast Ast.token, cast cstr message);
          store64 @tmp_it message;
        }
      }
      else {
        assert(0, "invalid token type\n");
      }
    }
    else if eq ast_type AstExpression {
      { let _ = typecheck(block, fs, cast ptr load64 + + ast Ast.node * sizeof ptr 0); }
      let konst = is_branch_konst_eval(ast);
      store64 + ast Ast.konst konst;
    }
    else if or or eq ast_type AstExprList eq ast_type AstStatement eq ast_type AstStatementList {
      let _ = typecheck_node_list(block, fs, ast);
      let konst = is_branch_konst_eval(ast);
      store64 + ast Ast.konst konst;
    }
    else if eq ast_type AstBinopExpression {
      { let _ = typecheck_node_list(block, fs, ast); }
      let b : Type = 0;
      let a : Type = 0;
      ts_pop(at b);
      ts_pop(at a);
      if and
        or or or is_numerical(at a) eq type_value(@a) TypeAny eq type_value(@a) TypePtr eq type_value(@a) TypeCString
        or or or is_numerical(at b) eq type_value(@b) TypeAny eq type_value(@b) TypePtr eq type_value(@b) TypeCString {
        let va : Value = 0;
        let vb : Value = 0;
        { let _ = vs_pop(@vb); }
        { let _ = vs_pop(@va); }
        store64 + ast Ast.konst and load64 + @va Value.konst load64 + @vb Value.konst;

        let num : u64 = 0;
        let token_type = load64 + + ast Ast.token Token.type;
        if eq token_type T_ADD {
          store64 @num + load64 + @va Value.num load64 + @vb Value.num;
        }
        else if eq token_type T_SUB {
          store64 @num - load64 + @va Value.num load64 + @vb Value.num;
        }
        else if eq token_type T_MUL {
          store64 @num * load64 + @va Value.num load64 + @vb Value.num;
        }
        else if eq token_type T_DIV {
          if eq load64 + @vb Value.konst 1 {
            if eq load64 + @vb Value.num 0 {
              typecheck_error("divide by zero arithmetic error\n");
            }
            else {
              store64 @num / load64 + @va Value.num load64 + @vb Value.num;
            }
          }
        }
        else if eq token_type T_DIVMOD {
          if eq load64 + @vb Value.konst 1 {
            if eq load64 + @vb Value.num 0 {
              typecheck_error("modulo by zero arithmetic error\n");
            }
            else {
              store64 @num % load64 + @va Value.num load64 + @vb Value.num;
            }
          }
        }
        else if eq token_type T_LSHIFT {
          store64 @num lshift load64 + @va Value.num load64 + @vb Value.num;
        }
        else if eq token_type T_RSHIFT {
          store64 @num rshift load64 + @va Value.num load64 + @vb Value.num;
        }
        else if eq token_type T_LT {
          store64 @num < load64 + @va Value.num load64 + @vb Value.num;
        }
        else if eq token_type T_GT {
          store64 @num > load64 + @va Value.num load64 + @vb Value.num;
        }
        else if eq token_type T_AND {
          store64 @num and load64 + @va Value.num load64 + @vb Value.num;
        }
        else if eq token_type T_OR {
          store64 @num or load64 + @va Value.num load64 + @vb Value.num;
        }
        else if eq token_type T_XOR {
          store64 @num xor load64 + @va Value.num load64 + @vb Value.num;
        }
        else if eq token_type T_EQ {
          store64 @num eq load64 + @va Value.num load64 + @vb Value.num;
        }
        else if eq token_type T_NEQ {
          store64 @num neq load64 + @va Value.num load64 + @vb Value.num;
        }
        else {
          assert(0, "unhandled operator\n");
        }
        let value : Value = 0;
        store64 + @value Value.num num;
        let konst : u64 = is_branch_konst_eval(ast);
        store64 + ast Ast.konst konst;
        store64 + @value Value.konst konst;
        { let _ = vs_push(@value); }
        ts_push(at a, cast ptr<Type> NULL);
      }
      else {
        typecheck_error("type mismatch in binary operator expression\n");
      }
    }
    else if eq ast_type AstUopExpression {
      let ts_count : u64 = load64 + c Compile.ts_count;
      { let _ = typecheck_node_list(block, fs, ast); }
      store64 + ast Ast.konst is_branch_konst_eval(ast);
      let ts_delta : u64 = - load64 + c Compile.ts_count ts_count;
      if eq ts_delta 1 {
        let token_type = load64 + + ast Ast.token Token.type;
        if eq token_type T_PRINT {
          { let _ = vs_pop(NULL); }
          ts_pop(cast ptr<Type> NULL);
        }
        else if or or or or
          eq token_type T_DEREF
          eq token_type T_LOAD64
          eq token_type T_LOAD32
          eq token_type T_LOAD16
          eq token_type T_LOAD8 {
          ts_pop(cast ptr<Type> NULL);
          ts_push_primitive(TypeUnsigned64, cast ptr<Type> NULL);
        }
        else if eq token_type T_DEREF_WORD {
          let type : Type = 0;
          ts_pop(at type);
          let deflated_type : Type = 0;
          type_deflate(at type, at deflated_type);
          if neq type_value(@deflated_type) TypeNone {
            ts_push(at deflated_type, cast ptr<Type> NULL);
          }
          else {
            typecheck_error_at(+ ast Ast.token, "can not dereference this type\n", NULL);
          }
        }
        else if eq token_type T_LOGICAL_NOT {
          let value : Value = 0;
          { let _ = vs_pop(@value); }
          store64 + @value Value.num not load64 + @value Value.num;
          { let _ = vs_push(@value); }
        }
        else if eq token_type T_NOT {
          let value : Value = 0;
          { let _ = vs_pop(@value); }
          store64 + @value Value.num ~ load64 + @value Value.num;
          { let _ = vs_push(@value); }
        }
      }
      else {
        typecheck_error("no value was produced in the rhs of the unary expression\n");
      }
    }
    else if or eq ast_type AstLetStatement eq ast_type AstConstStatement {
      { let _ = typecheck_let_statement(block, fs, ast); }
    }
    else if eq ast_type AstBlockStatement {
      let local_block : Block = 0;
      block_init(@local_block, block);
      { let _ = typecheck_node_list(@local_block, fs, ast); }
      store64 + ast Ast.konst is_branch_konst_eval(ast);
    }
    else if eq ast_type AstFuncDefinition {
      if eq cast u64 block + c Compile.global {
        let params = cast ptr load64 + + ast Ast.node * sizeof ptr 0;
        let body = cast ptr load64 + + ast Ast.node * sizeof ptr 1;
        let rtype_node : ptr = NULL;
        if eq load64 + ast Ast.count 3 {
          store64 @rtype_node load64 + + ast Ast.node * sizeof ptr 2;
        }

        let explicit_rtype : Type = 0;
        type_init(at explicit_rtype, TypeNone, 0);

        let argc : u64 = load64 + params Ast.count;
        if or eq argc MAX_FUNC_ARGC < argc MAX_FUNC_ARGC { // argc <= MAX_FUNC_ARGC
          let symbol : ptr = NULL;
          let symbol_index : u64 = UINT64_MAX;
          if eq compile_declare_value(block, fs, + ast Ast.token, @symbol, @symbol_index) NoError {
            let local_block : Block = 0;
            block_init(@local_block, block);

            let type : Type = 0;
            type_init(at type, TypeFunc, symbol_index);
            let type_size : u64 = compile_type_size(TypeFunc);

            store64 + symbol Symbol.imm UINT64_MAX;
            store64 + symbol Symbol.size type_size;
            store64 + symbol Symbol.konst 0;
            store64 + symbol Symbol.sym_type SYM_FUNC;
            memcpy(+ symbol Symbol.type, at type, sizeof Type);
            store64 + + ast Ast.token Token.v symbol_index;
            memcpy(+ symbol Symbol.token, + ast Ast.token, sizeof Token);
            let func = cast ptr + + symbol Symbol.value Value.func;
            store64 + func Function.ir_address UINT64_MAX;
            store64 + func Function.label symbol_index;
            store64 + func Function.argc argc;
            store64 + func Function.locals_offset 0;
            type_init(cast ptr<Type> + func Function.rtype, TypeNone, 0);

            let new_type_id : u64 = type_push_new(at type, type_size); // TODO(lucas): handle error

            if neq rtype_node NULL {
              if eq type_contract_from_type_node(block, fs, rtype_node, TYPE_CONTRACT_CREATE, at explicit_rtype, 1) NoError {
                memcpy(+ func Function.rtype, at explicit_rtype, sizeof Type);
              }
              else {
                typecheck_error_at(+ rtype_node Ast.token, "unknown or invalid return type in function definition\n", NULL);
              }
            }

            let i : u64 = 0;
            let fail : u64 = 0;
            while and eq fail 0 < i argc {
              let arg_node = cast ptr load64 + + params Ast.node * sizeof ptr i;
              let arg : Token = 0;
              let arg_type_token : Token = 0;
              memcpy(@arg, + arg_node Ast.token, sizeof Token);
              memcpy(@arg_type_token, + load64 + + arg_node Ast.node * sizeof ptr 0 Ast.token, sizeof Token);

              let arg_symbol : ptr = NULL;
              let arg_symbol_index : u64 = UINT64_MAX;
              if eq compile_declare_value(@local_block, func, @arg, @arg_symbol, @arg_symbol_index) NoError {
                store64 + + func Function.args * sizeof u64 i arg_symbol_index;
                let arg_type : Type = 0;

                let arg_type_node : ptr = cast ptr load64 + + arg_node Ast.node * sizeof ptr 0;
                if eq type_contract_from_type_node(block, fs, arg_type_node, TYPE_CONTRACT_CREATE, at arg_type, 0) NoError {
                  let arg_type_id : u64 = type_lookup(at arg_type);
                  assert(neq arg_type_id UINT64_MAX, "invalid type\n");
                  let size : u64 = compile_type_size(arg_type_id);
                  if eq type_value(@arg_type) TypeStruct {
                    store64 @size compile_type_size(arg_type_id);
                    if > size MAX_STRUCT_SIZE {
                      let args : any = MAX_STRUCT_SIZE;
                      typecheck_error_at(@arg_type_token, "can not have a parameter of type struct with a greater size than %d\n", @args);
                      store64 @fail 1;
                    }
                  }
                  if eq fail 0 {
                    store64 + arg_symbol Symbol.imm UINT64_MAX;
                    store64 + arg_symbol Symbol.size size;
                    store64 + arg_symbol Symbol.konst 0;
                    store64 + arg_symbol Symbol.sym_type SYM_FUNC_ARG;
                    memcpy(+ arg_symbol Symbol.type, at arg_type, sizeof Type);
                    memcpy(+ arg_symbol Symbol.token, @arg, sizeof Token);
                    store64 + + arg_symbol Symbol.token Token.v i; // TODO(lucas): store argument index in symbol value field instead
                  }
                }
                else {
                  typecheck_error_at(@arg_type_token, "unknown or invalid type\n", NULL);
                }
              }
              else {
                compile_error_at(@arg, "duplicate argument name\n");
                store64 @fail 1;
              }
              store64 @i + 1 i;
            }

            let ts_count : u64 = load64 + c Compile.ts_count;
            let func_body_block : Block = 0;
            block_init(@func_body_block, @local_block); // to allow for shadowing of function arguments

            { let _ = typecheck_node_list(@func_body_block, fs, body); }
            let konst_body : u64 = is_branch_konst_eval(body);
            store64 + body Ast.konst konst_body;
            store64 + ast Ast.konst konst_body;
            store64 + + symbol Symbol.value Value.konst konst_body;

            let rtype : Type = 0;
            type_init(at rtype, TypeNone, 0);
            let ts_delta : u64 = - load64 + c Compile.ts_count ts_count;
            if > ts_delta 1 {
              typecheck_error_at(+ ast Ast.token, "too many values produced by function\n", NULL);
            }
            else {
              if neq ts_delta 0 {
                { let _ = vs_pop(NULL); }
                ts_pop(at rtype);
              }

              if rtype_node {
                if and neq types_are_equal(at explicit_rtype, at rtype) 1 neq type_value(@explicit_rtype) TypeAny {
                  // TODO(lucas): more detailed error message
                  compile_error_at(+ rtype_node Ast.token, "function returns a value that does not match the return type\n");
                }
              }
              // type inference for the return type
              else {
                memcpy(+ func Function.rtype, at rtype, sizeof Type);
              }

              if eq strncmp(cast cstr + symbol Symbol.name, "main", MAX_NAME_SIZE) 0 {
                store64 + symbol Symbol.ref_count + load64 + symbol Symbol.ref_count 1;
                store64 + c Compile.entry_point + load64 + c Compile.entry_point 1;
              }
            }
          }
          else {
            compile_error_at(+ ast Ast.token, "symbol already exists\n");
          }
        }
        else {
          let message = cast cstr tmp_it;
          sprintf(cast ptr message, "reached function parameter count limit of %d\n", @MAX_FUNC_ARGC);
          compile_error_at(+ ast Ast.token, message);
        }
      }
      else {
        compile_error_at(+ ast Ast.token, "functions are only permitted to be defined in the global block\n");
      }
    }
    else if eq ast_type AstFuncCall {
      let symbol : ptr = NULL;
      let symbol_index : u64 = UINT64_MAX;
      let token_buffer : Buffer = 0;
      buffer_init(at token_buffer, cast ptr load64 + + ast Ast.token Token.buffer, load64 + + ast Ast.token Token.length);
      if eq compile_lookup_value(block, fs, @token_buffer, @symbol, @symbol_index, NULL) NoError {
        store64 + symbol Symbol.ref_count + 1 load64 + symbol Symbol.ref_count;
        store64 + + ast Ast.token Token.v symbol_index;
        let arg_list = cast ptr load64 + + ast Ast.node * sizeof ptr 0;
        let func : ptr = + + symbol Symbol.value Value.func;
        let type : Type = 0;
        memcpy(at type, + symbol Symbol.type, sizeof Type);
        if or eq type_value(@type) TypeFunc eq type_value(@type) TypeSyscallFunc {
          let argc : u64 = load64 + func Function.argc;
          if eq argc load64 + arg_list Ast.count {
            store64 + + symbol Symbol.token Token.v symbol_index; // TODO(lucas): store this in the symbol value field, or someplace else
            let done : u64 = 0;
            let i : u64 = - argc 1;
            if > argc 0 {
              while eq done 0 {
                let node = cast ptr load64 + + arg_list Ast.node * sizeof ptr i;
                { let _ = typecheck(block, fs, node); }
                let arg_in_type : Type = 0;
                ts_top(at arg_in_type);

                if eq type_value(@type) TypeSyscallFunc {
                  // any type is allowed here
                  // we still want to type check the arguments of the call
                  // which is why this is here instead of outside the loop
                }
                else {
                  // Symbol* arg = &c->symbols[func->args[i]];
                  let arg_symbol_index : u64 = load64 + + func Function.args * sizeof u64 i;
                  let arg = cast ptr + + c Compile.symbols * sizeof Symbol arg_symbol_index;
                  let arg_type : Type = 0;
                  memcpy(at arg_type, + arg Symbol.type, sizeof Type);

                  if and
                      neq types_are_equal(at arg_type, at arg_in_type) 1
                      neq type_value(@arg_type) TypeAny {
                    {
                      // TODO(lucas): error message type strings
                      typecheck_error_at(+ node Ast.token, "type mismatch in function call, got `?`, but `?` was expected\n", NULL);
                    }
                    store64 + c Compile.status NoError; // to print additional error message
                    {
                      let args : any = + symbol Symbol.name;
                      typecheck_error_at(+ arg Symbol.token, "from function `%s`\n", @args);
                    }
                    store64 @done 1;
                  }
                }
                { let _ = vs_pop(NULL); }
                ts_pop(cast ptr<Type> NULL);
                if eq i 0 {
                  store64 @done 1;
                }
                else {
                  store64 @i - i 1;
                }
              }
            }

            let rtype : Type = 0;
            memcpy(at rtype, + func Function.rtype, sizeof Type);
            if neq type_value(@rtype) TypeNone {
              store64 + + symbol Symbol.value Value.konst 0;  // NOTE(lucas): temporary (why?)
              store64 + ast Ast.konst load64 + + symbol Symbol.value Value.konst;
              { let _ = vs_push(+ symbol Symbol.value); }
              ts_push(at rtype, cast ptr<Type> NULL);
            }
          }
          else {
            let message = cast cstr tmp_it;
            tmp_push_cstr("function `");
            tmp_push_cstr(cast cstr + symbol Symbol.name);
            tmp_push_cstr("` takes ");
            tmp_push_u64(load64 + func Function.argc);
            tmp_push_cstr(" argument(s), but ");
            tmp_push_u64(load64 + arg_list Ast.count);
            tmp_push_cstr(" was given\n");
            tmp_push_byte(cast u8 0);
            compile_error_at(+ ast Ast.token, message);
            store64 @tmp_it message;
          }
        }
        else {
          let type : Type = 0;
          memcpy(at type, + symbol Symbol.type, sizeof Type);
          // TODO(lucas): error message type strings
          typecheck_error_at(+ ast Ast.token, "function calls of type `?` is not permitted\n", NULL);
        }
      }
      else {
        let message = tmp_it;
        tmp_push_cstr("symbol `");
        tmp_push_str(cast cstr load64 + @token_buffer Buffer.data, load64 + @token_buffer Buffer.length);
        tmp_push_cstr("` not defined\n");
        tmp_push_byte(cast u8 0);
        compile_error_at(+ ast Ast.token, cast cstr message);
        store64 @tmp_it message;
      }
    }
    else if eq ast_type AstWhileStatement {
      let cond = cast ptr load64 + + ast Ast.node * sizeof ptr 0;
      let body = cast ptr load64 + + ast Ast.node * sizeof ptr 1;
      { let _ = typecheck(block, fs, cond); }
      let type : Type = 0;
      ts_pop(at type); // pop type of condition result
      { let _ = vs_pop(NULL); } // pop value of condition result
      if or or eq type_value(@type) TypeCString eq type_value(@type) TypePtr is_numerical(at type) {
        let local_block : Block = 0;
        block_init(@local_block, block);
        { let _ = typecheck(@local_block, fs, body); }
        store64 + ast Ast.konst is_branch_konst_eval(ast);
      }
      else {
        typecheck_error_at(+ cond Ast.token, "invalid type in while statement condition\n", NULL);
      }
    }
    else if eq ast_type AstIfStatement {
      let cond = cast ptr load64 + + ast Ast.node * sizeof ptr 0;
      let body = cast ptr load64 + + ast Ast.node * sizeof ptr 1;
      { let _ = typecheck(block, fs, cond); }
      let type : Type = 0;
      ts_pop(at type); // pop type of condition result
      { let _ = vs_pop(NULL); } // pop value of condition result
      if or or eq type_value(@type) TypeCString eq type_value(@type) TypePtr is_numerical(at type) {
        let local_block : Block = 0;
        block_init(@local_block, block);
        { let _ = typecheck(@local_block, fs, body); }
        if eq load64 + ast Ast.count 3 {
          let else_body = cast ptr load64 + + ast Ast.node * sizeof ptr 2;
          let local_block : Block = 0;
          block_init(@local_block, block);
        { let _ = typecheck(@local_block, fs, else_body); }
        }
        store64 + ast Ast.konst is_branch_konst_eval(ast);
      }
      else {
        typecheck_error_at(+ cond Ast.token, "invalid type in if statement condition\n", NULL);
      }
    }
    else if eq ast_type AstAssignment {
      let first = cast ptr load64 + + ast Ast.node * sizeof ptr 0;
      let second = cast ptr load64 + + ast Ast.node * sizeof ptr 1;
      { let _ = typecheck(block, fs, first); }
      let a : Type = 0;
      ts_pop(at a);
      { let _ = typecheck(block, fs, second); }
      if or eq type_value(@a) TypePtr eq type_value(@a) TypeAny {
        ts_pop(cast ptr<Type> NULL);
        { let _ = vs_pop(NULL); }
        { let _ = vs_pop(NULL); }
      }
      else {
        typecheck_error_at(+ first Ast.token, "type mismatch in assignment statement\n", NULL);
      }
    }
    else if eq ast_type AstSizeof {
      // t : ptr<Token>
      let t = cast ptr + ast Ast.token;
      let size : u64 = 0;
      let token_type = load64 + t Token.type;
      if or eq token_type T_UNSIGNED64 eq token_type T_NUMBER {
        store64 @size sizeof u64;
      }
      else if eq token_type T_UNSIGNED32 {
        store64 @size sizeof u32;
      }
      else if eq token_type T_UNSIGNED16 {
        store64 @size sizeof u16;
      }
      else if eq token_type T_UNSIGNED8 {
        store64 @size sizeof u8;
      }
      else if or or or
        eq token_type T_PTR
        eq token_type T_CSTRING
        eq token_type T_CSTR
        eq token_type T_ANY {
        store64 @size sizeof ptr;
      }
      else if eq token_type T_IDENTIFIER {
        let symbol = NULL;
        let buffer : Buffer = 0;
        buffer_init(at buffer, cast ptr load64 + t Token.buffer, load64 + t Token.length);
        if eq compile_lookup_value(block, fs, @buffer, @symbol, NULL, NULL) NoError {
          store64 @size load64 + symbol Symbol.size;
        }
        else {
          typecheck_error_at(cast ptr t, "symbol not defined\n", NULL);
        }
      }
      else {
        assert(0, "type not implemented yet\n");
      }
      let value : Value = 0;
      store64 + @value Value.num size;
      store64 + @value Value.konst 1;
      { let _ = vs_push(@value); }
      store64 + t Token.v size;
      store64 + ast Ast.konst 1;
      ts_push_primitive(TypeUnsigned64, cast ptr<Type> NULL);
    }
    else if eq ast_type AstEnum {
      let type_node = cast ptr load64 + + ast Ast.node * sizeof ptr 0;
      let enum_node = cast ptr load64 + + ast Ast.node * sizeof ptr 1;
      let value : Value = 0;
      store64 + @value Value.num 0;
      store64 + @value Value.konst 1;
      let i : u64 = 0;
      let count : u64 = load64 + enum_node Ast.count;

      let type : Type = 0;
      token_to_compile_type(block, fs, + type_node Ast.token, NULL, at type);
      if is_numerical(at type) {
        while < i count {
          let node = cast ptr load64 + + enum_node Ast.node * sizeof ptr i;
          let symbol : ptr = NULL;
          let symbol_index : u64 = UINT64_MAX;
          let imm : u64 = compile_push_value(+ @value Value.num, sizeof u64);

          if eq compile_declare_value(block, fs, + node Ast.token, @symbol, @symbol_index) NoError {
            store64 + symbol Symbol.imm imm;
            store64 + symbol Symbol.size compile_type_size(type_value(@type));
            store64 + symbol Symbol.konst 1;
            if eq cast u64 block + c Compile.global {
              store64 + symbol Symbol.sym_type SYM_GLOBAL_VAR;
            }
            else {
              store64 + symbol Symbol.sym_type SYM_LOCAL_VAR;
            }
            memcpy(+ symbol Symbol.type, at type, sizeof Type);
            memcpy(+ symbol Symbol.value, @value, sizeof Value);
          }
          else {
            compile_error_at(+ node Ast.token, "symbol already exists\n");
          }

          store64 + @value Value.num + 1 load64 + @value Value.num;
          store64 @i + 1 i;
        }
      }
      else {
        typecheck_error_at(+ type_node Ast.token, "expected numerical type in enumerator expression\n", NULL);
      }
    }
    else if eq ast_type AstStruct {
      let fields = cast ptr load64 + + ast Ast.node * sizeof ptr 0;
      let field_offset : u64 = 0;
      let i : u64 = 0;
      let count : u64 = load64 + fields Ast.count;
      let fail : u64 = 0;

      let type_info : Struct_type_info = 0;
      struct_type_info_init(at type_info);
      let struct_type_field : Struct_field = 0;

      while and eq fail 0 < i count {
        let field = cast ptr load64 + + fields Ast.node * sizeof ptr i;
        let field_type_node = cast ptr load64 + + field Ast.node * sizeof ptr 0; // type + array specifier
        let field_name = cast cstr load64 + + field Ast.token Token.buffer;
        let field_length = load64 + + field Ast.token Token.length;

        let it = tmp_it;
        tmp_push_str(load64 + + ast Ast.token Token.buffer, load64 + + ast Ast.token Token.length);
        tmp_push_cstr(".");
        tmp_push_str(load64 + + field Ast.token Token.buffer, load64 + + field Ast.token Token.length);

        store64 + + field Ast.token Token.buffer it;
        store64 + + field Ast.token Token.length - tmp_it it;

        let symbol : ptr = NULL;
        let symbol_index : u64 = UINT64_MAX;
        let imm : u64 = compile_push_value(@field_offset, sizeof field_offset);
        let value : Value = 0;
        store64 + @value Value.num field_offset;
        store64 + @value Value.konst 1;

        if eq compile_declare_value(block, fs, + field Ast.token, @symbol, @symbol_index) NoError {
          store64 + symbol Symbol.imm imm;
          store64 + symbol Symbol.size sizeof u64;
          store64 + symbol Symbol.konst 1;
          if eq cast u64 block + c Compile.global {
            store64 + symbol Symbol.sym_type SYM_GLOBAL_VAR;
          }
          else {
            store64 + symbol Symbol.sym_type SYM_LOCAL_VAR;
          }
          type_init(cast ptr<Type> + symbol Symbol.type, TypeUnsigned64, 0);
          memcpy(+ symbol Symbol.value, @value, sizeof Value);

          let field_size : u64 = 0;
          let field_type : Type = 0;

          if eq type_contract_from_type_node(block, fs, field_type_node, TYPE_CONTRACT_CREATE, at field_type, 0) NoError {
            let type_id : u64 = type_lookup(at field_type);
            store64 @field_size compile_type_size(type_id);
          }
          else {
            typecheck_error_at(+ field_type_node Ast.token, "unknown or invalid type in struct field\n", NULL);
          }

          let field_array_specifier = NULL;
          let field_count = load64 + field_type_node Ast.count;
          if > field_count 0 {
            store64 @field_array_specifier load64 + + field_type_node Ast.node * sizeof ptr 0;
          }

          let array_specifier_value : Value = 0;
          store64 + @array_specifier_value Value.num 1;

          if field_array_specifier {
            if neq load64 + field_array_specifier Ast.type AstNone {
              { let _ = typecheck_node_list(block, fs, field_array_specifier); }
              let array_specifier_type : Type = 0;
              ts_pop(at array_specifier_type);
              { let _ = vs_pop(@array_specifier_value); }
              if neq load64 + @array_specifier_value Value.konst 1 {
                compile_error_at(+ field_type_node Ast.token, "field array specifier must be a compile time constant\n");
                store64 @fail 1;
              }
              else if eq is_numerical(at array_specifier_type) 0 {
                compile_error_at(+ field_type_node Ast.token, "field array specifier must be a numerical\n");
                store64 @fail 1;
              }
              else {
                if eq load64 + @array_specifier_value Value.num 0 {
                  compile_error_at(+ field_type_node Ast.token, "field array specifier must be a numerical with a greater value than 0\n");
                  store64 @fail 1;
                }
                else {
                  store64 @field_size * field_size load64 + @array_specifier_value Value.num;
                }
              }
            }
          }
          // done constructing this struct field
          if eq fail 0 {
            { let _ = struct_field_init(at struct_type_field, cast ptr<u8> field_name, field_length, at field_type, load64 + @array_specifier_value Value.num, field_offset); }
            { let _ = struct_create_field(at type_info, at struct_type_field); }
          }

          // update field offset
          store64 @field_offset + field_offset field_size;
        }
        else {
          compile_error_at(+ field Ast.token, "symbol already exists\n");
          store64 @fail 1;
        }
        store64 @i + 1 i;
      }
      // struct symbol definition
      let symbol : ptr = NULL;
      let symbol_index : u64 = UINT64_MAX;
      let value : Value = 0;
      memset(@value, 0, sizeof Value);

      if eq compile_declare_value(block, fs, + ast Ast.token, @symbol, @symbol_index) NoError {
        store64 + symbol Symbol.imm UINT64_MAX;
        store64 + symbol Symbol.size field_offset;
        store64 + symbol Symbol.konst 0;
        if eq cast u64 block + c Compile.global {
          store64 + symbol Symbol.sym_type SYM_GLOBAL_VAR;
        }
        else {
          store64 + symbol Symbol.sym_type SYM_LOCAL_VAR;
        }
        let type : Type = 0;
        type_init(
          at type,
          TypeStruct,
          load64 + c Compile.struct_id
        );
        { let _ = struct_type_push(at type_info); }
        memcpy(+ symbol Symbol.type, at type, sizeof Type);
        memcpy(+ symbol Symbol.value, @value, sizeof Value);

        let new_type_id : u64 = type_push_new(at type, field_offset); // TODO(lucas): handle error
      }
      else {
        compile_error_at(+ ast Ast.token, "symbol already exists\n");
      }
    }
    else if eq ast_type AstCastExpression {
      let type_expr = cast ptr load64 + + ast Ast.node * sizeof ptr 0;
      let expr = cast ptr load64 + + ast Ast.node * sizeof ptr 1;
      { let _ = typecheck(block, fs, expr); }
      let expr_type : Type = 0;
      ts_pop(at expr_type);
      let cast_type : Type = 0;
      { let _ = type_contract_from_type_node(block, fs, type_expr, TYPE_CONTRACT_CREATE, at cast_type, 0); }
      if and neq type_value(@cast_type) TypeNone neq type_value(@cast_type) TypeFunc {
        ts_push(at cast_type, cast ptr<Type> NULL);
      }
      else {
        // TODO(lucas): error message type strings
        typecheck_error_at(+ type_expr Ast.token, "cannot cast from type `?` to `?`\n", NULL);
      }
    }
    else if eq ast_type AstStaticAssert {
      let expr = cast ptr load64 + + ast Ast.node * sizeof ptr 0;
      let node = cast ptr load64 + + ast Ast.node * sizeof ptr 1;
      { let _ = typecheck(block, fs, expr); }
      ts_pop(cast ptr<Type> NULL);
      let value : Value = 0;
      { let _ = vs_pop(@value); }
      if eq load64 + @value Value.konst 0 {
        typecheck_error("can not do static on an expression that is evaluated at runtime\n");
      }
      else if eq load64 + @value Value.num 0 {
        let node_token = cast ptr + node Ast.token;
        let message = cast cstr tmp_it;
        tmp_push_cstr("[static assertion failed]: ");
        tmp_push_str(load64 + node_token Token.buffer, load64 + node_token Token.length);
        tmp_push_cstr("\n");
        tmp_push_byte(cast u8 0);
        compile_error_at(+ expr Ast.token, message);
        store64 @tmp_it message;
      }
    }
    else {
      let message = cast cstr tmp_it;
      sprintf(cast ptr message, "unreachable AST node with id `%d`\n", @ast_type);
      assert(0, message);
    }
  }
  load64 + c Compile.status;
}

fn typecheck_program(ast : ptr) -> u64 {
  assert(cast u64 ast, "something went very wrong\n");
  store64 @_typecheck typecheck;
  store64 @_type_print type_print;
  store64 @_type_printline type_printline;

  let time_start : timespec = 0;
  let time_end : timespec = 0;
  { let _ = clock_gettime(CLOCK_MONOTONIC, @time_start); }

  let _ = typecheck(+ c Compile.global, NULL, cast ptr load64 + + ast Ast.node * sizeof ptr 0);
  { let _ = clock_gettime(CLOCK_MONOTONIC, @time_end); }

  if neq load64 + c Compile.vs_count 0 {
    typecheck_error("unhandled data on the value stack\n");
  }

  if and neq load64 + c Compile.ts_count 0 eq load64 + c Compile.status NoError {
    typecheck_error("unhandled data on the type stack\n");
  }

  if eq load64 + c Compile.status NoError {
    print_time_elapsed("type checking took", @time_start, @time_end);
    typecheck_print_unused();
  }

  typecheck_print_stack(STDOUT_FILENO);

  load64 + c Compile.status;
}
