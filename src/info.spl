// info.spl

fn symbol_info_print(fd: u64) -> none {
  dprintf(fd, "print_symbol_info:\n", null);
  let message = cast cstr tmp_it;
  let count: u64 = load64 + c Compile.symbol_count;
  let i: u64 = 0;
  while < i count {
    let symbol = + + c Compile.symbols * sizeof Symbol i;
    let name = cast cstr + symbol Symbol.name;
    let type: Type = 0;
    memcpy(at type, + symbol Symbol.type, sizeof Type);
    let num_i_digits: u64 = digit_count(i);
    let j: u64 = 0;

    if neq type_base(at type) TypeSyscallFunc {
      while < j - 3 num_i_digits {
        dprintf(fd, "0", null);
        store64 @j + 1 j;
      }
      dprintf(fd, "%d: ", @i);
      if eq type_base(at type) TypeFunc {
        let func_sig = func_signature_from_id(type_sub_id(at type));
        dprintf(fd, "%s", @name);
        func_signature_print(fd, func_sig);
      }
      else {
        let args: any = name;
        dprintf(fd, "%s : ", @args);
        type_print(fd, at type);
      }
      let args: any = (
        load64 + symbol Symbol.size,
        load64 + symbol Symbol.konst,
        load64 + + symbol Symbol.value Value.konst,
        load64 + symbol Symbol.ref_count,
        load64 + symbol Symbol.local_id
      );
      dprintf(fd, " (size = %d, konst = %d, value.konst = %d, ref_count = %d, local_id = %d)\n", @args);
    }
    store64 @i + 1 i;
  }
  store64 @tmp_it message;
}

fn symbol_info_print_html(fd: u64) -> none {
  html_tag(fd, "h1", "Symbol information", null);
  html_single_tag(fd, "table");
    html_single_tag(fd, "tr");
      html_tag(fd, "th", "Index", null);
      html_tag(fd, "th", "Name", null);
      html_tag(fd, "th", "Symbol type", null);
      html_tag(fd, "th", "Type", null);
      html_tag(fd, "th", "Size", null);
      html_tag(fd, "th", "Const", null);
      html_tag(fd, "th", "Reference count", null);
    html_single_end_tag(fd, "tr");

  let count: u64 = load64 + c Compile.symbol_count;
  let i: u64 = 0;
  while < i count {
    let symbol = + + c Compile.symbols * sizeof Symbol i;
    let name = cast cstr + symbol Symbol.name;
    let sym_type = load64 + symbol Symbol.sym_type;
    let sym_type_name = cast cstr load64 + @sym_type_str * sizeof cstr sym_type;
    let type: Type = 0;
    memcpy(at type, + symbol Symbol.type, sizeof Type);
    let size = * load64 + at type Type.size load64 + at type Type.count;
    let konst = load64 + symbol Symbol.konst;
    let ref_count = load64 + symbol Symbol.ref_count;
    if neq type_base(at type) TypeSyscallFunc {
      html_single_tag(fd, "tr");
        html_tag(fd, "td", "%d", @i);
        html_tag(fd, "td", "%s", @name);
        html_tag(fd, "td", "%s", @sym_type_name);
        html_single_tag(fd, "td");
        let buffer_size = DEFAULT_TYPE_BUFFER_SIZE;
        let type_str: u8[buffer_size] = 0;
        type_to_buffer(@type_str, buffer_size, at type);
        html_plain_text(fd, cast cstr at type_str);
        html_single_end_tag(fd, "td");
        html_tag(fd, "td", "%d", @size);
        html_tag(fd, "td", "%d", @konst);
        html_tag(fd, "td", "%d", @ref_count);
      html_single_end_tag(fd, "tr");
    }
    store64 at i + 1 i;
  }
  html_single_end_tag(fd, "table");
}
