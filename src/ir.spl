// ir.spl

// Ir_code
enum u64 (
  I_NOP,
  I_POP,
  I_MOVE, // <id, offset, x>
  I_MOVE_LOCAL, // <local_id, x, x>
  I_STORE64,
  I_STORE32,
  I_STORE16,
  I_STORE8,
  I_LOAD64,
  I_LOAD32,
  I_LOAD16,
  I_LOAD8,
  I_PUSH_ADDR_OF, // <type, id, x>
  I_PUSH_LOCAL_ADDR_OF, // <type, local_id, x>
  I_PUSH, // <type, id, x>
  I_PUSH_LOCAL, // <type, local_id, x>
  I_PUSH_IMM, // <type, imm, x>
  I_ADD,
  I_SUB,
  I_MUL,
  I_LSHIFT,
  I_RSHIFT,
  I_DIV,
  I_DIVMOD,
  I_LT,
  I_GT,
  I_AND,
  I_LOGICAL_NOT,
  I_OR,
  I_EQ,
  I_NEQ,
  I_RET, // <x, frame_size, x>
  I_NORET, // <x, frame_size, x>
  I_PRINT,
  I_LABEL,
  I_CALL, // <label, argc, rtype>
  I_ADDR_CALL, // <x, argc, rtype>
  I_JMP, // <label, positite_offset, negative_offset>
  I_JZ, // <label, offset, x>
  I_BEGIN_FUNC, // <x, argc, frame_size>
  I_LOOP_LABEL,

  I_SYSCALL0,
  I_SYSCALL1,
  I_SYSCALL2,
  I_SYSCALL3,
  I_SYSCALL4,
  I_SYSCALL5,
  I_SYSCALL6,

  MAX_IR_CODE
);

enum u64 (
  TypeNone,
  TypeAny,
  TypePtr,
  TypeUnsigned64,
  TypeUnsigned32,
  TypeUnsigned16,
  TypeUnsigned8,
  TypeCString,
  TypeFunc,
  TypeSyscallFunc,
  TypeStruct,

  MAX_PRIMITIVE_TYPE
);

const MAX_COMPILE_TYPE 255;

// symbol types
enum u64 (
  SYM_FUNC_ARG,
  SYM_FUNC,
  SYM_LOCAL_VAR,
  SYM_GLOBAL_VAR
);

const MAX_FUNC_ARGC 6; // TODO(lucas): temp

struct Function (
  ir_address            : u64,
  label                 : u64,
  argc                  : u64,
  locals_offset_counter : u64,
  rtype                 : u64,
  args                  : u64 : MAX_FUNC_ARGC
);

struct Value (
  func  : Function,
  num   : u64,
  konst : u64
);

const MAX_NAME_SIZE 64;

struct Symbol (
  name                : u8 : MAX_NAME_SIZE,
  imm                 : u64,
  size                : u64,
  num_elements_init   : u64,
  konst               : u64,
  local_id            : u64,
  sym_type            : u64,
  type                : u64,
  token               : Token,
  value               : Value,
  ref_count           : u64
);

const MAX_SYMBOL 4096;
const MAX_SYMBOL_PER_BLOCK 1024;
const MAX_STATIC_DATA * 128 1024;
const MAX_CSTRING 1024;
const MAX_SYSCALL_FUNCTION 7;

struct Block (
  symbols      : u64 : MAX_SYMBOL_PER_BLOCK, // index into compile state symbols
  symbol_count : u64,
  parent       : ptr
);

struct Op (
  i    : u64,
  dest : u64,
  src0 : u64,
  src1 : u64
);

const MAX_TYPE_STACK 256;
const MAX_INS * 128 1024;  // TODO(lucas): temp

struct Compile (
  ins              : Op : MAX_INS,
  ins_count        : u64,

  imm              : u8 : MAX_STATIC_DATA,
  imm_index        : u64,

  symbols          : Symbol : MAX_SYMBOL,
  symbol_count     : u64,

  cstrings         : u64 : MAX_CSTRING,
  cstring_count    : u64,

  global           : Block,

  label_count      : u64,  // labels that are used for branching

  status           : u64,
  entry_point      : u64,

  ts               : u64 : MAX_TYPE_STACK, // type stack
  ts_count         : u64, // this should be signed integer, but that is not implemented yet, so type stack overflow will be detected by using UINT64_MAX.

  vs               : Value : MAX_TYPE_STACK, // value stack. sometimes we need to grab values in the type checking phase. it also allows for some basic compile time evaluation of stuff.
  vs_count         : u64,

  type_count       : u64  // how many types are there, including primitive and user defined types?
);

let ir_code_str : cstr : MAX_IR_CODE "";
let compile_type_str : cstr : MAX_COMPILE_TYPE "";
let compile_type_size : u64 : MAX_COMPILE_TYPE 0;

fn ir_func_signature(block : ptr, fs : ptr, ast : ptr, ins_count : ptr) -> u64 NoError;
let _ir_compile ir_func_signature;

enum u64 (
  TARGET_LINUX_NASM_X86_64,
  MAX_COMPILE_TARGET
);

// c : Compile*
let c : ptr NULL;

// i : u64, op : Op*
fn OP(i : u64, op : ptr) -> none {
  store64 + op Op.i    i;
  store64 + op Op.dest NONE;
  store64 + op Op.src0 NONE;
  store64 + op Op.src1 NONE;
}

// i : u64, dest : u64, src0 : u64, src1 : u64, op : Op*
fn OP_init(i : u64, dest : u64, src0 : u64, src1 : u64, op : ptr) -> none {
  store64 + op Op.i    i;
  store64 + op Op.dest dest;
  store64 + op Op.src0 src0;
  store64 + op Op.src1 src1;
}

fn block_init(block : ptr, parent : ptr) -> none {
  store64 + block Block.symbol_count 0;
  store64 + block Block.parent parent;
}

fn compile_error(message : cstr) -> none {
  if eq load64 + c Compile.status NoError {
    dprintf(STDERR_FILENO, "[compile-error]: %s", @message);
    store64 + c Compile.status Error;
  }
}

// token : Token*
fn compile_error_at(token : ptr, message : cstr) -> none {
  if eq load64 + c Compile.status NoError {
    let args : any (
      load64 + token Token.filename,
      load64 + token Token.line,
      load64 + token Token.column,
      message
    );
    dprintf(STDERR_FILENO, "[compile-error]: %s:%d:%d: %s", @args);
    printline(STDERR_FILENO, cast cstr load64 + token Token.source, cast cstr + load64 + token Token.length load64 + token Token.buffer, load64 + token Token.length, 1, NUM_LINES_TO_PRINT);
    store64 + c Compile.status Error;
  }
}

fn ir_compile_warning(message : cstr) -> none {
  if eq load64 + @options Options.enable_warnings 1 {
    dprintf(STDERR_FILENO, "[ir-compile-warning]: %s", @message);
  }
}

fn ir_compile_warning_at(token : ptr, message : cstr) -> none {
  if eq load64 + @options Options.enable_warnings 1 {
    let args : any (
      load64 + token Token.filename,
      load64 + token Token.line,
      load64 + token Token.column,
      message
    );
    dprintf(STDERR_FILENO, "[ir-compile-warning]: %s:%d:%d: %s", @args);
    printline(STDERR_FILENO, cast cstr load64 + token Token.source, cast cstr + load64 + token Token.length load64 + token Token.buffer, load64 + token Token.length, 1, NUM_LINES_TO_PRINT);
  }
}

fn ir_print(fd : u64) -> none {
  puts(fd, "ir_print:\n");
  let i : u64 0;
  let count : u64 load64 + c Compile.ins_count;
  while < i count {
    // op : Op*
    let op cast ptr + + c Compile.ins * sizeof Op i;
    let message cast cstr tmp_it;

    let num_digits : u64 digit_count(i);
    const num_zeros : u64 4;
    let j : u64 0;
    while < j - num_zeros num_digits {
      tmp_push_cstr("0");
      store64 @j + 1 j;
    }
    let dest : u64 load64 + op Op.dest;
    let src0 : u64 load64 + op Op.src0;
    let src1 : u64 load64 + op Op.src1;
    tmp_push_u64(i);
    tmp_push_cstr(": ");
    tmp_push_cstr("<");
    tmp_push_cstr(cast cstr load64 + @ir_code_str * sizeof cstr load64 + op Op.i);
    tmp_push_cstr(", ");
    // NOTE(lucas): ugly hack to print UINT64_MAX
    if neq dest UINT64_MAX tmp_push_u64(dest); else tmp_push_cstr("-1");
    tmp_push_cstr(", ");
    if neq src0 UINT64_MAX tmp_push_u64(src0); else tmp_push_cstr("-1");
    tmp_push_cstr(", ");
    if neq src1 UINT64_MAX tmp_push_u64(src1); else tmp_push_cstr("-1");
    tmp_push_cstr(">\n");
    tmp_push_byte(cast u8 0);

    puts(fd, message);
    store64 @tmp_it message;
    store64 @i + 1 i;
  }
}

fn ir_push_ins(op : ptr, ins_count : ptr) -> u64 {
  if < load64 + c Compile.ins_count MAX_INS {
    if neq cast u64 ins_count NULL {
      store64 ins_count + 1 load64 ins_count;
    }
    memcpy(+ + c Compile.ins * sizeof Op load64 + c Compile.ins_count, op, sizeof Op);
    store64 + c Compile.ins_count + 1 load64 + c Compile.ins_count;
  }
  else {
    assert(0, "reached instruction capacity\n");
  }
  NoError;
}

fn ir_pop_ins(op : ptr, ins_count : ptr) -> u64 {
  assert(0, "ir_pop_ins(): not implemented yet\n");
  NoError;
}

fn ir_push_value(value : ptr, size : u64) -> u64 {
  let result : u64 UINT64_MAX;
  let address : u64 load64 + c Compile.imm_index;
  if < + address size MAX_STATIC_DATA {
    memcpy(+ + c Compile.imm address, value, size);
    store64 + c Compile.imm_index + load64 + c Compile.imm_index size;
    store64 @result address;
  }
  else {
    assert(0, "out of immediate data memory\n");
  }
  result;
}

// NOTE(lucas): discrepancy between implementations (spl and c) of the length parameter
fn ir_push_cstring(buffer : ptr, length : u64, index : ptr) -> u64 {
  let address : u64 ir_push_value(@length, sizeof length);
  let value_address : u64 ir_push_value(buffer, length);
  if and neq address UINT64_MAX neq value_address UINT64_MAX {
    if < load64 + c Compile.cstring_count MAX_CSTRING {
      let cstring_count : u64 load64 + c Compile.cstring_count;
      store64 index cstring_count;
      store64 + + c Compile.cstrings * sizeof u64 cstring_count address;
      store64 + c Compile.cstring_count + 1 cstring_count;
    }
    else {
      store64 @address UINT64_MAX;
      assert(0, "cstring capacity reached\n");
    }
  }
  address;
}

// fs : Function*, symbol : Symbol*, id : u64, ins_count : u64*
fn ir_push_symbol(fs : ptr, symbol : ptr, id : u64, ins_count : ptr) -> u64 {
  let sym_type : u64 load64 + symbol Symbol.sym_type;
  let op : Op 0;
  if eq sym_type SYM_FUNC {
    let func cast ptr + + symbol Symbol.value Value.func;
    OP_init(
      I_PUSH,
      load64 + symbol Symbol.type,
      load64 + func Function.label,
      NONE,
      @op
    );
  }
  else if eq sym_type SYM_LOCAL_VAR {
    if eq load64 + symbol Symbol.konst 1 {
      OP_init(
        I_PUSH,
        load64 + symbol Symbol.type,
        id,
        NONE,
        @op
      );
    }
    else {
      OP_init(
        I_PUSH_LOCAL,
        load64 + symbol Symbol.type,
        + load64 + symbol Symbol.local_id * sizeof u64 + 1 load64 + fs Function.argc,
        NONE,
        @op
      );
    }
  }
  else if eq sym_type SYM_GLOBAL_VAR {
    OP_init(
      I_PUSH,
      load64 + symbol Symbol.type,
      id,
      NONE,
      @op
    );
  }
  else if eq sym_type SYM_FUNC_ARG {
    let arg_id : u64 load64 + + symbol Symbol.token Token.v;
    assert(neq arg_id UINT64_MAX, "invalid argument id\n");
    OP_init(
      I_PUSH_LOCAL,
      load64 + symbol Symbol.type,
      + sizeof u64 * sizeof u64 arg_id,
      NONE,
      @op
    );
  }
  else {
    assert(0, "symbol type not implemented\n");
  }
  { let _ ir_push_ins(@op, ins_count); }
  load64 + c Compile.status;
}

// fs : Function*, symbol : Symbol*, id : u64, ins_count : u64*
fn ir_push_addr_of(fs : ptr, symbol : ptr, id : u64, ins_count : ptr) -> u64 {
  let sym_type : u64 load64 + symbol Symbol.sym_type;
  let op : Op 0;

  if eq sym_type SYM_FUNC {
    OP_init(
      I_PUSH_ADDR_OF,
      load64 + symbol Symbol.type,
      id,
      NONE,
      @op
    );
  }
  else if eq sym_type SYM_LOCAL_VAR {
    if eq load64 + symbol Symbol.konst 1 {
      OP_init(
        I_PUSH_ADDR_OF,
        load64 + symbol Symbol.type,
        id,
        NONE,
        @op
      );
    }
    else {
      OP_init(
        I_PUSH_LOCAL_ADDR_OF,
        load64 + symbol Symbol.type,
        + load64 + symbol Symbol.local_id * sizeof u64 + 1 load64 + fs Function.argc,
        NONE,
        @op
      );
    }
  }
  else if eq sym_type SYM_GLOBAL_VAR {
    OP_init(
      I_PUSH_ADDR_OF,
      load64 + symbol Symbol.type,
      id,
      NONE,
      @op
    );
  }
  else if eq sym_type SYM_FUNC_ARG {
    store64 @id load64 + + symbol Symbol.token Token.v;
    OP_init(
      I_PUSH_LOCAL_ADDR_OF,
      load64 + symbol Symbol.type,
      + sizeof u64 * sizeof u64 id,
      NONE,
      @op
    );
  }
  else {
    assert(0, "symbol type not implemented\n");
  }

  { let _ ir_push_ins(@op, ins_count); }
  load64 + c Compile.status;
}

fn ir_compile_stmts(block : ptr, fs : ptr, ast : ptr, ins_count : ptr) -> u64 {
  let i : u64 0;
  let count : u64 load64 + ast Ast.count;
  let done : u64 0;
  while and eq done 0 < i count {
    if neq _ir_compile(block, fs, cast ptr load64 + + ast Ast.node * sizeof ptr i, ins_count) NoError {
      store64 @done 1;
    }
    store64 @i + 1 i;
  }
  load64 + c Compile.status;
}

fn ir_compile_func_call_args(block : ptr, fs : ptr, ast : ptr, ins_count : ptr) -> u64 {
  let count : u64 load64 + ast Ast.count;
  if > count 0 {
    let i : u64 - count 1;
    let done : u64 0;
    while eq done 0 {
      if neq _ir_compile(block, fs, cast ptr load64 + + ast Ast.node * sizeof ptr i, ins_count) NoError {
        store64 @done 1;
      }
      if eq i 0 {
        store64 @done 1;
      }
      store64 @i - i 1;
    }
  }
  load64 + c Compile.status;
}

fn ir_compile_binop(block : ptr, fs : ptr, ast : ptr, ins_count : ptr) -> u64 {
  assert(eq load64 + ast Ast.count 2, "expected 2 branches in binary operator expression\n");

  let i : u64 0;
  let count : u64 load64 + ast Ast.count;
  let done : u64 0;
  while and eq done 0 < i count {
    let node cast ptr load64 + + ast Ast.node * sizeof ptr i;
    if neq _ir_compile(block, fs, node, ins_count) NoError {
      store64 @done 1;
    }
    store64 @i + 1 i;
  }
  load64 + c Compile.status;
}

fn ir_compile_uop(block : ptr, fs : ptr, ast : ptr, ins_count : ptr) -> u64 {
  assert(eq load64 + ast Ast.count 1, "expected 1 branch in unary operator expression\n");
  _ir_compile(block, fs, cast ptr load64 + + ast Ast.node * sizeof ptr 0, ins_count);
}

fn ir_compile_func(block : ptr, fs : ptr, ast : ptr, ins_count : ptr) -> u64 {
  let body cast ptr load64 + + ast Ast.node * sizeof ptr 1;
  let id : u64 load64 + + ast Ast.token Token.v;
  assert(neq id UINT64_MAX, "bad function id\n");

  let symbol cast ptr + + c Compile.symbols * sizeof Symbol id;
  let ref_count : u64 load64 + symbol Symbol.ref_count;

  if not and eq ref_count 0 eq load64 + @options Options.disable_dce 0 {
    let func cast ptr + + symbol Symbol.value Value.func;

    let op : Op 0;
    OP_init(
      I_LABEL,
      id,
      NONE,
      NONE,
      @op
    );
    { let _ ir_push_ins(@op, ins_count); }
    store64 + func Function.ir_address load64 + c Compile.ins_count;

    let begin_func_address : u64 load64 + c Compile.ins_count; // we don't know how many local variables there are in this function until the function body is compiled, therefore we store the index to the I_BEGIN_FUNC instruction so that we can change it later when we do.
    OP_init(
      I_BEGIN_FUNC,
      NONE,
      load64 + func Function.argc,
      0,
      @op
    );
    { let _ ir_push_ins(@op, ins_count); }

    let func_size : u64 0;
    { let _ ir_compile_stmts(block, func, body, @func_size); }
    // begin_func : Op*
    let begin_func : ptr + + c Compile.ins * sizeof Op begin_func_address;
    let frame_size : u64 + load64 + func Function.locals_offset_counter * sizeof u64 load64 + func Function.argc;
    store64 + begin_func Op.src1 frame_size;
    let ret_op : u64 I_RET;
    if eq load64 + func Function.rtype TypeNone {
      store64 @ret_op I_NORET;
    }
    OP_init(
      ret_op,
      NONE,
      frame_size,
      UINT64_MAX,
      @op
    );
    { let _ ir_push_ins(@op, ins_count); }
  }

  load64 + c Compile.status;
}

fn ir_compile(block : ptr, fs : ptr, ast : ptr, ins_count : ptr) -> u64 {
  let type : u64 load64 + ast Ast.type;

  if eq type AstValue {
    let token : ptr + ast Ast.token;
    let token_type : u64 load64 + token Token.type;
    if eq token_type T_NUMBER {
      let imm : u64 ir_push_value(+ token Token.v, sizeof u64);
      if neq imm UINT64_MAX {
        let op : Op 0;
        OP_init(
          I_PUSH_IMM,
          TypeUnsigned64,
          imm,
          NONE,
          @op
        );
        { let _ ir_push_ins(@op, ins_count); }
      }
      else {
        assert(0, "out of immediate data memory\n");
      }
    }
    else if eq token_type T_CSTRING {
      let index : u64 UINT64_MAX;
      let address : u64 ir_push_cstring(cast ptr load64 + + ast Ast.token Token.buffer, load64 + + ast Ast.token Token.length, @index);
      if neq address UINT64_MAX {
        let op : Op 0;
        OP_init(
          I_PUSH,
          TypeCString,
          index,
          NONE,
          @op
        );
        { let _ ir_push_ins(@op, ins_count); }
      }
    }
    else if eq token_type T_IDENTIFIER {
      let id : u64 load64 + + ast Ast.token Token.v;
      let symbol cast ptr + + c Compile.symbols * sizeof Symbol id;
      let ref_count : u64 load64 + symbol Symbol.ref_count;
      if not and and eq ref_count 0 eq load64 + @options Options.disable_dce 0 eq load64 + @options Options.dce_all 1 {
        { let _ ir_push_symbol(fs, symbol, id, ins_count); }
      }
    }
    else if eq token_type T_AT {
      let id : u64 load64 + + ast Ast.token Token.v;
      let symbol cast ptr + + c Compile.symbols * sizeof Symbol id;
      let ref_count : u64 load64 + symbol Symbol.ref_count;
      if not and and eq ref_count 0 eq load64 + @options Options.disable_dce 0 eq load64 + @options Options.dce_all 1 {
        { let _ ir_push_addr_of(fs, symbol, id, ins_count); }
      }
    }
    else {
      assert(0, "value type not implemented\n");
    }
  }
  else if or or or
      eq type AstExpression
      eq type AstExprList
      eq type AstStatement
      eq type AstStatementList {
    { let _ ir_compile_stmts(block, fs, ast, ins_count); }
  }
  else if eq type AstBinopExpression {
    if eq ir_compile_binop(block, fs, ast, ins_count) NoError {
      let type : u64 load64 + + ast Ast.token Token.type;
      let op : Op 0;
      if eq type T_ADD {
        OP(I_ADD, @op);
      }
      else if eq type T_SUB {
        OP(I_SUB, @op);
      }
      else if eq type T_MUL {
        OP(I_MUL, @op);
      }
      else if eq type T_DIV {
        OP(I_DIV, @op);
      }
      else if eq type T_DIVMOD {
        OP(I_DIVMOD, @op);
      }
      else if eq type T_LSHIFT {
        OP(I_LSHIFT, @op);
      }
      else if eq type T_RSHIFT {
        OP(I_RSHIFT, @op);
      }
      else if eq type T_LT {
        OP(I_LT, @op);
      }
      else if eq type T_GT {
        OP(I_GT, @op);
      }
      else if eq type T_AND {
        OP(I_AND, @op);
      }
      else if eq type T_OR {
        OP(I_OR, @op);
      }
      else if eq type T_EQ {
        OP(I_EQ, @op);
      }
      else if eq type T_NEQ {
        OP(I_NEQ, @op);
      }
      else {
        assert(0, "binary operator not implemented\n");
      }
      { let _ ir_push_ins(@op, ins_count); }
    }
  }
  else if eq type AstUopExpression {
    if eq ir_compile_uop(block, fs, ast, ins_count) NoError {
      let type : u64 load64 + + ast Ast.token Token.type;
      let op : Op 0;
      if eq type T_PRINT {
        OP(I_PRINT, @op);
      }
      else if eq type T_DEREF {
        OP(I_LOAD64, @op);
      }
      else if eq type T_LOAD64 {
        OP(I_LOAD64, @op);
      }
      else if eq type T_LOAD32 {
        OP(I_LOAD32, @op);
      }
      else if eq type T_LOAD16 {
        OP(I_LOAD16, @op);
      }
      else if eq type T_LOAD8 {
        OP(I_LOAD8, @op);
      }
      else if eq type T_LOGICAL_NOT {
        OP(I_LOGICAL_NOT, @op);
      }
      else {
        assert(0, "unary operator not implemented\n");
      }
      { let _ ir_push_ins(@op, ins_count); }
    }
  }
  else if eq type AstNone {
    ir_compile_warning_at(+ ast Ast.token, "unused AST branch type\n");
  }
  else if eq type AstConstStatement {
    // NOTE(lucas): value has already been defined in the type-checking phase
  }
  else if eq type AstLetStatement {
    let id : u64 load64 + + ast Ast.token Token.v;
    let symbol cast ptr + + c Compile.symbols * sizeof Symbol id;
    let ref_count : u64 load64 + symbol Symbol.ref_count;

    if not and and eq ref_count 0 eq load64 + @options Options.disable_dce 0 eq load64 + @options Options.dce_all 1 {
      let node cast ptr load64 + + ast Ast.node * sizeof ptr 0;
      let count : u64 ast_count(node);
      if eq count 1 {
        memcpy(+ symbol Symbol.token, + node Ast.token, sizeof Token);
      }

      if eq load64 + symbol Symbol.type TypeCString {
        // NOTE(lucas): we change the type from CString -> Any because symbol is pointing to a string
        store64 + symbol Symbol.type TypeAny;
      }
      // NOTE(lucas): completely ignore the rhs of the let statement if it is in the global scope
      // TODO(lucas): figure out how to deal with globals when it comes to their value assignment(s)
      if neq cast u64 fs NULL {
        let local_id : u64 load64 + fs Function.locals_offset_counter;
        let type_size : u64 load64 + @compile_type_size * sizeof u64 load64 + symbol Symbol.type;
        let num_elements : u64 / load64 + symbol Symbol.size type_size;
        const boundary_size : u64 sizeof u64;
        let total_size : u64 align(* num_elements type_size, boundary_size);
        store64 + fs Function.locals_offset_counter + load64 + fs Function.locals_offset_counter total_size;
        if neq load64 + symbol Symbol.type TypeStruct {
          if eq ir_compile_stmts(block, fs, ast, ins_count) NoError {
            let i : u64 0;
            let num_elements_init : u64 load64 + symbol Symbol.num_elements_init;
            while < i num_elements_init {
              let op : Op 0;
              OP_init(
                I_MOVE_LOCAL,
                load64 + symbol Symbol.type,
                + local_id * + 1 load64 + fs Function.argc sizeof u64,
                NONE,
                @op
              );
              { let _ ir_push_ins(@op, ins_count); }
              store64 @local_id + type_size local_id;
              store64 @i + 1 i;
            }
          }
        }
        store64 + symbol Symbol.local_id - load64 + fs Function.locals_offset_counter sizeof u64;
      }
    }
  }
  else if eq type AstFuncDefinition {
    assert(or eq load64 + ast Ast.count 2 eq load64 + ast Ast.count 3, "invalid number of nodes in AstFuncDefinition branch\n");
    let local_block : Block 0;
    block_init(@local_block, block);
    { let _ ir_compile_func(@local_block, fs, ast, ins_count); }
  }
  else if eq type AstParamList {
    assert(0, "something went very wrong\n");
  }
  else if eq type AstFuncCall {
    let id : u64 load64 + + ast Ast.token Token.v;
    let symbol cast ptr + + c Compile.symbols * sizeof Symbol id;
    let ref_count : u64 load64 + symbol Symbol.ref_count;
    if not and and eq ref_count 0 eq load64 + @options Options.disable_dce 0 eq load64 + @options Options.dce_all 1 {
      // func : Function*
      let func cast ptr + + symbol Symbol.value Value.func;
      let args cast ptr load64 + + ast Ast.node * sizeof ptr 0;
      if eq ir_compile_func_call_args(block, fs, args, ins_count) NoError { // compile function arguments in reverse order
        let type : u64 load64 + symbol Symbol.type;
        let op : Op 0;
        if or eq type TypeAny eq type TypeFunc {
          let sym_type : u64 load64 + symbol Symbol.sym_type;
          let rvalue : u64 NONE;
          if neq load64 + func Function.rtype TypeNone {
            store64 @rvalue 0;
          }
          if eq sym_type SYM_FUNC {
            OP_init(
              I_CALL,
              load64 + func Function.label,
              load64 + func Function.argc,
              rvalue,
              @op
            );
            { let _ ir_push_ins(@op, ins_count); }
          }
          else if eq sym_type SYM_LOCAL_VAR {
            assert(eq load64 + symbol Symbol.konst 0, "something went very wrong\n");
            OP_init(
              I_PUSH_LOCAL,
              load64 + symbol Symbol.type,
              + load64 + symbol Symbol.local_id * sizeof u64 + 1 load64 + fs Function.argc,
              NONE,
              @op
            );
            { let _ ir_push_ins(@op, ins_count); }
            OP_init(
              I_ADDR_CALL,
              NONE,
              load64 + func Function.argc,
              rvalue,
              @op
            );
            { let _ ir_push_ins(@op, ins_count); }
          }
          else if eq sym_type SYM_GLOBAL_VAR {
            OP_init(
              I_PUSH,
              load64 + symbol Symbol.type,
              id,
              NONE,
              @op
            );
            { let _ ir_push_ins(@op, ins_count); }
            OP(I_LOAD64, @op); // NOTE(lucas): dereference the variable and get access to the function pointer
            { let _ ir_push_ins(@op, ins_count); }
            OP_init(
              I_ADDR_CALL,
              NONE,
              load64 + func Function.argc,
              rvalue,
              @op
            );
            { let _ ir_push_ins(@op, ins_count); }
          }
          else if eq sym_type SYM_FUNC_ARG {
            let arg : u64 load64 + + symbol Symbol.token Token.v;
            OP_init(
              I_PUSH_LOCAL,
              load64 + symbol Symbol.type,
              + sizeof u64 * sizeof u64 arg,
              NONE,
              @op
            );
            { let _ ir_push_ins(@op, ins_count); }
            OP_init(
              I_ADDR_CALL,
              NONE,
              load64 + func Function.argc,
              rvalue,
              @op
            );
            { let _ ir_push_ins(@op, ins_count); }
          }
          else {
            assert(0, "function call of this symbol type is not implemented\n");
          }
        }
        else if eq type TypeSyscallFunc {
          let syscall_map : u64 (
            I_SYSCALL0,
            I_SYSCALL1,
            I_SYSCALL2,
            I_SYSCALL3,
            I_SYSCALL4,
            I_SYSCALL5,
            I_SYSCALL6
          );
          OP(load64 + @syscall_map * sizeof u64 - load64 + func Function.argc 1, @op);
          { let _ ir_push_ins(@op, ins_count); }
        }
        else {
          compile_error_at(+ ast Ast.token, "not a function and can not be called\n");
        }
      }
    }
  }
  else if eq type AstBlockStatement {
    { let _ ir_compile_stmts(block, fs, ast, ins_count); }
  }
  else if eq type AstMemoryStatement {
    // NOTE(lucas): this is handled in the type checking phase
  }
  else if eq type AstAssignment {
    if eq ir_compile_binop(block, fs, ast, ins_count) NoError {
      let type : u64 load64 + + ast Ast.token Token.type;
      let op : Op 0;
      if or
          eq type T_ASSIGN
          eq type T_STORE64 {
        OP(I_STORE64, @op);
      }
      else if eq type T_STORE32 {
        OP(I_STORE32, @op);
      }
      else if eq type T_STORE16 {
        OP(I_STORE16, @op);
      }
      else if eq type T_STORE8 {
        OP(I_STORE8, @op);
      }
      else {
        assert(0, "assignment operator not implemented\n");
      }
      { let _ ir_push_ins(@op, ins_count); }
    }
  }
  else if eq type AstWhileStatement {
    assert(eq load64 + ast Ast.count 2, "invalid while statement construction\n");
    let loop_label : u64 load64 + c Compile.label_count;
    store64 + c Compile.label_count + 1 load64 + c Compile.label_count;
    let cond_size : u64 0;
    let body_size : u64 0;
    let op : Op 0;
    OP_init(
      I_LOOP_LABEL,
      loop_label,
      NONE,
      NONE,
      @op
    );
    { let _ ir_push_ins(@op, @cond_size); }

    let cond cast ptr load64 + + ast Ast.node * sizeof ptr 0;
    let body cast ptr load64 + + ast Ast.node * sizeof ptr 1;

    if eq ir_compile_stmts(block, fs, cond, @cond_size) NoError {
      let body_start_address : u64 load64 + c Compile.ins_count;
      let loop_end_label : u64 load64 + c Compile.label_count;
      store64 + c Compile.label_count + 1 load64 + c Compile.label_count;
      OP_init(
        I_JZ, // conditional jump if zero
        loop_end_label,
        0,
        0,
        @op
      );
      { let _ ir_push_ins(@op, @body_size); }

      if eq ir_compile_stmts(block, fs, body, @body_size) NoError {
        OP_init(
          I_JMP,
          loop_label,
          NONE,
          + cond_size body_size,
          @op
        );
        { let _ ir_push_ins(@op, @body_size); }

        OP_init(
          I_LOOP_LABEL,
          loop_end_label,
          NONE,
          NONE,
          @op
        );
        { let _ ir_push_ins(@op, @body_size); }
        // jz : Op*
        let jz cast ptr + + c Compile.ins * sizeof Op body_start_address;
        store64 + jz Op.src0 body_size;
        if neq cast u64 ins_count NULL {
          store64 ins_count + load64 ins_count + cond_size body_size;
        }
      }
    }
  }
  else if eq type AstIfStatement {
    assert(or eq load64 + ast Ast.count 2 eq load64 + ast Ast.count 3, "invalid if statement construction\n");
    let cond_size : u64 0;
    let body_size : u64 0;
    let else_body_size : u64 0;
    let cond cast ptr load64 + + ast Ast.node * sizeof ptr 0;
    let body cast ptr load64 + + ast Ast.node * sizeof ptr 1;
    let op : Op 0;

    if eq ir_compile_stmts(block, fs, cond, @cond_size) NoError {
      let body_start_address : u64 load64 + c Compile.ins_count;
      let end_label : u64 load64 + c Compile.label_count;
      store64 + c Compile.label_count + 1 load64 + c Compile.label_count;
      OP_init(
        I_JZ,
        end_label,
        0,
        0,
        @op
      );
      { let _ ir_push_ins(@op, @body_size); }
      if eq ir_compile_stmts(block, fs, body, @body_size) NoError {
        if eq load64 + ast Ast.count 3 { // else body
          let else_body cast ptr load64 + + ast Ast.node * sizeof ptr 2;
          let else_label : u64 load64 + c Compile.label_count;
          store64 + c Compile.label_count + 1 load64 + c Compile.label_count;
          let else_start_address : u64 load64 + c Compile.ins_count;

          OP_init(
            I_JMP,
            else_label,
            NONE,
            NONE,
            @op
          );
          { let _ ir_push_ins(@op, @body_size); }

          OP_init(
            I_LOOP_LABEL,
            end_label,
            NONE,
            NONE,
            @op
          );
          { let _ ir_push_ins(@op, @else_body_size); }
          if eq ir_compile_stmts(block, fs, else_body, @else_body_size) NoError {
            OP_init(
              I_LOOP_LABEL,
              else_label,
              NONE,
              NONE,
              @op
            );
            { let _ ir_push_ins(@op, @else_body_size); }
            // jz : Op*
            let jz cast ptr + + c Compile.ins * sizeof Op body_start_address;
            // else_jmp : Op*
            let else_jmp cast ptr + + c Compile.ins * sizeof Op else_start_address;
            store64 + jz Op.src0 else_body_size;
            store64 + else_jmp Op.src0 else_body_size;
          }
        }
        else {
          OP_init(
            I_LOOP_LABEL,
            end_label,
            NONE,
            NONE,
            @op
          );
          { let _ ir_push_ins(@op, @body_size); }
          // jz : Op*
          let jz cast ptr + + c Compile.ins * sizeof Op body_start_address;
          store64 + jz Op.src0 body_size;
        }
      }
      if neq cast u64 ins_count NULL {
          store64 ins_count + load64 ins_count + + cond_size body_size else_body_size;
      }
    }
  }
  else if eq type AstSizeof {
    let imm : u64 ir_push_value(+ + ast Ast.token Token.v, sizeof u64);
    if neq imm UINT64_MAX {
      let op : Op 0;
      OP_init(
        I_PUSH_IMM,
        TypeUnsigned64,
        imm,
        NONE,
        @op
      );
      { let _ ir_push_ins(@op, ins_count); }
    }
  }
  else if or or or
      eq type AstEnum
      eq type AstStruct
      eq type AstType
      eq type AstStaticAssert {
    // NOTE(lucas): this is handled in the type checking phase
  }
  else if eq type AstCastExpression {
    { let _ ir_compile(block, fs, cast ptr load64 + + ast Ast.node * sizeof ptr 1, ins_count); }
  }
  else {
    compile_error_at(+ ast Ast.token, "invalid or unhandled AST branch type\n");
  }
  load64 + c Compile.status;
}

fn ir_start_compile(ast : ptr) -> u64 {
  let time_start : timespec 0;
  let time_end : timespec 0;
  { let _ clock_gettime(CLOCK_MONOTONIC, @time_start); }

  if neq load64 + c Compile.entry_point 1 {
    compile_error("missing entry point `main`\n");
  }

  store64 @_ir_compile ir_compile;

  let block cast ptr + c Compile.global;
  let i : u64 0;
  let count : u64 load64 + ast Ast.count;
  let done : u64 0;
  while and eq done 0 < i count {
    if neq ir_compile(block, NULL, cast ptr load64 + + ast Ast.node * sizeof ptr 0, NULL) NoError {
      store64 @done 1;
    }
    store64 @i + 1 i;
  }

  { let _ clock_gettime(CLOCK_MONOTONIC, @time_end); }

  let message cast cstr tmp_it;
  let args : any (
    - load64 + @time_end timespec.tv_sec load64 + @time_start timespec.tv_sec,
    / - load64 + @time_end timespec.tv_nsec load64 + @time_start timespec.tv_nsec TIME_NANOSECONDS_DENOM
  );
  sprintf(cast ptr message, "ir code generation took %d.%d seconds\n", @args);
  print_info(message);

  load64 + c Compile.status;
}
