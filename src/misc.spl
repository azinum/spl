// misc.spl

// TODO(lucas): index points to the end of the token, change this so that it points to the beginning of the token.
// TODO(lucas): check that source and index are not NULL
fn printline(fd : u64, source : cstr, index : cstr, token_length : u64, print_arrow : u64, num_lines_to_print : u64) -> none {
  assert(neq num_lines_to_print 0, "printline: value of num_lines_to_print must be greater than 0\n");

  store64 @index - index token_length;
  let offset : u64 + - cast u64 index source 1;
  let start_offset : u64 0;
  let cur_line_offset : u64 0;
  let end_offset : u64 0;
  let num_lines : u64 num_lines_to_print;

  let at : cstr index;
  // scan to the beginning of the line
  {
    let done : u64 0;
    while and eq done 0 < start_offset offset {
      store64 @start_offset + 1 start_offset;
      if eq num_lines_to_print num_lines {
        store64 @cur_line_offset + 1 cur_line_offset;
      }
      let ch : u64 load8 - at start_offset;
      if eq ch 10 { // `\n`
        store64 @num_lines_to_print - num_lines_to_print 1;
        if eq num_lines_to_print 0 {
          store64 @done 1;
        }
      }
    }
  }

  // scan to the end of the line
  {
    let done : u64 0;
    while eq done 0 {
      let ch : u64 load8 + at end_offset;
      if or eq ch 10 eq ch 0 { // `\n`, `\0`
        store64 @done 1;
      }
      else {
        store64 @end_offset + 1 end_offset;
      }
    }
  }

  const MAX_BUFFER_SIZE 512;
  let buffer : u8 : MAX_BUFFER_SIZE cast u8 0;
  let line_length : u64 - + end_offset start_offset 1;
  let args : any + - at start_offset 1;
  dnprintf(fd, line_length, "%s", @args);
  dprintf(fd, "\n", NULL);
  if print_arrow {
    let i : u64 0;
    let count : u64 - cur_line_offset 1;
    while < i count {
      dprintf(fd, "-", NULL);
      store64 @i + 1 i;
    }
    dprintf(fd, "^\n", NULL);
  }
  dprintf(fd, "\n", NULL);
}
