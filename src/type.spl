// type.spl

const MAX_NAME_SIZE = 64;

enum u64 (
  TypeNone,
  TypeAny,
  TypePtr,
  TypeUnsigned64,
  TypeUnsigned32,
  TypeUnsigned16,
  TypeUnsigned8,
  TypeCString,
  TypeFunc,
  TypeSyscallFunc,
  TypeStruct,

  MAX_PRIMITIVE_TYPE
);

struct Type (
  type : u32,
  id : u32,
  hash : u64,
  info : u64
);

const MAX_COMPILE_TYPE = 1024;

// symbol types
enum u64 (
  SYM_FUNC_ARG,
  SYM_FUNC,
  SYM_LOCAL_VAR,
  SYM_GLOBAL_VAR
);

// TODO(lucas): dynamic allocation
const MAX_NUM_STRUCT_FIELDS = 64;

struct Struct_field (
  name : u8 : MAX_NAME_SIZE,
  type : Type,
  count : u64,
  offset : u64
);

struct Struct_type_info (
  fields : Struct_field : MAX_NUM_STRUCT_FIELDS,
  count : u64
);

fn type_init(type : ptr<Type>, type_value : u64, id : u64) -> none {
  store32 + type Type.type type_value;
  store32 + type Type.id id;
}

fn type_value(type : ptr<Type>) -> u64 {
  load32 + type Type.type;
}

fn type_id(type : ptr<Type>) -> u64 {
  load32 + type Type.id;
}

fn types_are_equal(a : ptr<Type>, b : ptr<Type>) -> u64 {
  and
    eq load32 + a Type.type load32 + b Type.type
    eq load32 + a Type.id   load32 + b Type.id;
}
