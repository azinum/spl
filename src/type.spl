// type.spl

const MAX_NAME_SIZE = 64;

enum u64 (
  TypeNone,
  TypeAny,
  TypePtr,
  TypeUnsigned64,
  TypeUnsigned32,
  TypeUnsigned16,
  TypeUnsigned8,
  TypeCString,
  TypeFunc,
  TypeSyscallFunc,
  TypeStruct,

  MAX_PRIMITIVE_TYPE
);

struct Type (
  base : u64,     // base or container type
  sub_id : u64,   // sub type id
  info_id : u64,  // index to additional type info for structs, functions, and others
  hash : u64,     // hash of the type for quick equality checks
  count : u64,
  size : u64,
);

const MAX_COMPILE_TYPE = 1024;

// symbol types
enum u64 (
  SYM_FUNC_ARG,
  SYM_FUNC,
  SYM_LOCAL_VAR,
  SYM_GLOBAL_VAR
);

// TODO(lucas): dynamic allocation
const MAX_NUM_STRUCT_FIELDS = 64;

struct Struct_field (
  name : u8 : MAX_NAME_SIZE,
  type : Type,
  count : u64,
  offset : u64
);

struct Struct_type_info (
  fields : Struct_field : MAX_NUM_STRUCT_FIELDS,
  count : u64
);

fn type_init(type : ptr<Type>, base_type : u64, sub_id : u64) -> none {
  store64 + type Type.base base_type;
  store64 + type Type.sub_id sub_id;
  store64 + type Type.info_id UINT64_MAX;
  store64 + type Type.hash 0;
  // store64 + type Type.count 0;
  // store64 + type Type.size 0;
}

fn type_base(type : ptr<Type>) -> u64 {
  load64 + type Type.base;
}

fn type_sub_id(type : ptr<Type>) -> u64 {
  load64 + type Type.sub_id;
}

fn types_are_equal(a : ptr<Type>, b : ptr<Type>) -> u64 {
  and
    eq load64 + a Type.base     load64 + b Type.base
    eq load64 + a Type.sub_id   load64 + b Type.sub_id;
}
