// codegen_nasm_x86_64.spl

fn o(fd : u64, format : cstr, args : any) -> none {
  dprintf(fd, format, args);
}

fn vo_empty(fd : u64, format : cstr, args : any) -> none {}

fn compile_linux_nasm_x86_64(fd : u64) -> u64 {
  let vo = vo_empty;

  if load64 + @options Options.verbose_asm {
    store64 @vo o;
  }

  let func_call_regs_x86_64 : cstr = (
    "rdi",
    "rsi",
    "rdx",
    "rcx",
    "r8",
    "r9"
  );
  let entry = "_start";

  o(fd, "bits 64\n", NULL);
  o(fd, "section .text\n", NULL);
  o(fd, "global %s\n", @entry);
  o(fd,
"print:
 mov r9, -3689348814741910323
 sub rsp, 40
 mov BYTE [rsp+31], 10
 lea rcx, [rsp+30]
 .L2:
 mov rax, rdi
 lea r8, [rsp+32]
 mul r9
 mov rax, rdi
 sub r8, rcx
 shr rdx, 3
 lea rsi, [rdx+rdx*4]
 add rsi, rsi
 sub rax, rsi
 add eax, 48
 mov BYTE [rcx], al
 mov rax, rdi
 mov rdi, rdx
 mov rdx, rcx
 sub rcx, 1
 cmp rax, 9
 ja .L2
 lea rax, [rsp+32]
 mov edi, 1
 sub rdx, rax
 xor eax, eax
 lea rsi, [rsp+32+rdx]
 mov rdx, r8
 mov rax, 1
 syscall
 add rsp, 40
 ret
", NULL);

  let i : u64 = 0;
  let count : u64 = load64 + c Compile.ins_count;
  while < i count {
    // op : Op*
    let op = cast ptr + + c Compile.ins * sizeof Op i;
    let ins : u64 = load64 + op Op.i;
    if eq ins I_NOP {
      o(fd, "nop\n", NULL);
    }
    else if eq ins I_POP {
      vo(fd, "; I_POP\n", NULL);
      o(fd, "pop rax\n", NULL);
    }
    else if eq ins I_MOVE {
      vo(fd, "; I_MOVE\n", NULL);
      let dest : u64 = load64 + op Op.dest;
      let args : any = (load64 + op Op.src0, load64 + op Op.src1);
      if or or or or
          eq dest TypeAny
          eq dest TypePtr
          eq dest TypeCString
          eq dest TypeFunc
          eq dest TypeUnsigned64 {
        o(fd, "pop rax\n", NULL);
        o(fd, "mov [v%d+%d], rax\n", @args);
      }
      else if eq dest TypeUnsigned32 {
        o(fd, "pop rax\n", NULL);
        o(fd, "mov [v%d+%d], eax\n", @args);
      }
      else if eq dest TypeUnsigned16 {
        o(fd, "pop rax\n", NULL);
        o(fd, "mov [v%d+%d], ax\n", @args);
      }
      else if eq dest TypeUnsigned8 {
        o(fd, "pop rax\n", NULL);
        o(fd, "mov [v%d+%d], al\n", @args);
      }
      else {
        assert(0, "I_MOVE: type not implemented yet\n");
      }
    }
    else if eq ins I_MOVE_LOCAL {
      vo(fd, "; I_MOVE_LOCAL\n", NULL);
      let dest : u64 = load64 + op Op.dest;
      let args : any = (load64 + op Op.src0);
      if or or or or
          eq dest TypeAny
          eq dest TypePtr
          eq dest TypeCString
          eq dest TypeFunc
          eq dest TypeUnsigned64 {
        o(fd, "pop rax\n", NULL);
        o(fd, "mov [rbp-%d], rax\n", @args);
      }
      else if eq dest TypeUnsigned32 {
        o(fd, "pop rax\n", NULL);
        o(fd, "mov DWORD [rbp-%d], eax\n", @args);
      }
      else if eq dest TypeUnsigned16 {
        o(fd, "pop rax\n", NULL);
        o(fd, "mov WORD [rbp-%d], ax\n", @args);
      }
      else if eq dest TypeUnsigned8 {
        o(fd, "pop rax\n", NULL);
        o(fd, "mov BYTE [rbp-%d], al\n", @args);
      }
      else {
        assert(0, "I_MOVE_LOCAL: type not implemented yet\n");
      }
    }
    else if eq ins I_STORE64 {
      vo(fd, "; I_STORE64\n", NULL);
      o(fd, "pop rbx\n", NULL);
      o(fd, "pop rax\n", NULL);
      o(fd, "mov [rax], rbx\n", NULL);
    }
    else if eq ins I_STORE32 {
      vo(fd, "; I_STORE32\n", NULL);
      o(fd, "pop rbx\n", NULL);
      o(fd, "pop rax\n", NULL);
      o(fd, "mov [rax], ebx\n", NULL);
    }
    else if eq ins I_STORE16 {
      vo(fd, "; I_STORE16\n", NULL);
      o(fd, "pop rbx\n", NULL);
      o(fd, "pop rax\n", NULL);
      o(fd, "mov [rax], bx\n", NULL);
    }
    else if eq ins I_STORE8 {
      vo(fd, "; I_STORE8\n", NULL);
      o(fd, "pop rbx\n", NULL);
      o(fd, "pop rax\n", NULL);
      o(fd, "mov [rax], bl\n", NULL);
    }
    else if eq ins I_LOAD64 {
      vo(fd, "; I_LOAD64\n", NULL);
      o(fd, "pop rax\n", NULL);
      o(fd, "xor rbx, rbx\n", NULL);
      o(fd, "mov rbx, [rax]\n", NULL);
      o(fd, "push rbx\n", NULL);
    }
    else if eq ins I_LOAD32 {
      vo(fd, "; I_LOAD32\n", NULL);
      o(fd, "pop rax\n", NULL);
      o(fd, "xor rbx, rbx\n", NULL);
      o(fd, "mov ebx, [rax]\n", NULL);
      o(fd, "push rbx\n", NULL);
    }
    else if eq ins I_LOAD16 {
      vo(fd, "; I_LOAD16\n", NULL);
      o(fd, "pop rax\n", NULL);
      o(fd, "xor rbx, rbx\n", NULL);
      o(fd, "mov bx, [rax]\n", NULL);
      o(fd, "push rbx\n", NULL);
    }
    else if eq ins I_LOAD8 {
      vo(fd, "; I_LOAD8\n", NULL);
      o(fd, "pop rax\n", NULL);
      o(fd, "xor rbx, rbx\n", NULL);
      o(fd, "mov bl, [rax]\n", NULL);
      o(fd, "push rbx\n", NULL);
    }
    else if eq ins I_PUSH_ADDR_OF {
      vo(fd, "; I_PUSH_ADDR_OF\n", NULL);
      let args : any = (load64 + op Op.src0);
      o(fd, "mov rax, v%d\n", @args);
      o(fd, "push rax\n", NULL);
    }
    else if eq ins I_PUSH_LOCAL_ADDR_OF {
      vo(fd, "; I_PUSH_LOCAL_ADDR_OF\n", NULL);
      let args : any = (load64 + op Op.src0);
      o(fd, "lea rax, [rbp-%d]\n", @args);
      o(fd, "push rax\n", NULL);
    }
    else if eq ins I_PUSH {
      vo(fd, "; I_PUSH\n", NULL);
      let dest : u64 = load64 + op Op.dest;
      let args : any = (load64 + op Op.src0);
      if or or
          eq dest TypeAny
          eq dest TypePtr
          eq dest TypeUnsigned64 {
        o(fd, "mov rax, [v%d]\n", @args);
        o(fd, "push rax\n", NULL);
      }
      else if eq dest TypeUnsigned32 {
        o(fd, "xor rax, rax\n", NULL);
        o(fd, "mov eax, [v%d]\n", @args);
        o(fd, "push rax\n", NULL);
      }
      else if eq dest TypeUnsigned16 {
        o(fd, "xor rax, rax\n", NULL);
        o(fd, "mov ax, [v%d]\n", @args);
        o(fd, "push rax\n", NULL);
      }
      else if eq dest TypeUnsigned8 {
        o(fd, "xor rax, rax\n", NULL);
        o(fd, "mov al, [v%d]\n", @args);
        o(fd, "push rax\n", NULL);
      }
      else if eq dest TypeCString {
        o(fd, "mov rax, str%d\n", @args);
        o(fd, "push rax\n", NULL);
      }
      else if eq dest TypeFunc {
        o(fd, "mov rax, v%d\n", @args);
        o(fd, "push rax\n", NULL);
      }
      else if eq dest TypeStruct {
        let size : u64 = load64 + op Op.src1;
        if eq size 8 {
          o(fd, "mov rax, [v%d]\n", @args);
          o(fd, "push rax\n", NULL);
        }
        else if eq size 4 {
          o(fd, "xor rax, rax\n", NULL);
          o(fd, "mov eax, [v%d]\n", @args);
          o(fd, "push rax\n", NULL);
        }
        else if eq size 2 {
          o(fd, "xor rax, rax\n", NULL);
          o(fd, "mov ax, [v%d]\n", @args);
          o(fd, "push rax\n", NULL);
        }
        else if eq size 1 {
          o(fd, "xor rax, rax\n", NULL);
          o(fd, "mov al, [v%d]\n", @args);
          o(fd, "push rax\n", NULL);
        }
        else {
          assert(0, "I_PUSH: bad struct size\n");
        }
      }
      else {
        assert(0, "I_PUSH: type not implemented\n");
      }
    }
    else if eq ins I_PUSH_LOCAL {
      vo(fd, "; I_PUSH_LOCAL\n", NULL);
      let dest : u64 = load64 + op Op.dest;
      let args : any = (load64 + op Op.src0);
      if or or or or
          eq dest TypeAny
          eq dest TypePtr
          eq dest TypeCString
          eq dest TypeFunc
          eq dest TypeUnsigned64 {
        o(fd, "push QWORD [rbp-%d]\n", @args);
      }
      else if eq dest TypeUnsigned32 {
        o(fd, "mov eax, [rbp-%d]\n", @args);
        o(fd, "push rax\n", NULL);
      }
      else if eq dest TypeUnsigned16 {
        o(fd, "mov ax, [rbp-%d]\n", @args);
        o(fd, "push rax\n", NULL);
      }
      else if eq dest TypeUnsigned8 {
        o(fd, "mov al, [rbp-%d]\n", @args);
        o(fd, "push rax\n", NULL);
      }
      else if eq dest TypeStruct {
        let size : u64 = load64 + op Op.src1;
        if eq size 8 {
          o(fd, "push QWORD [rbp-%d]\n", @args);
        }
        else if eq size 4 {
          o(fd, "mov eax, [rbp-%d]\n", @args);
          o(fd, "push rax\n", NULL);
        }
        else if eq size 2 {
          o(fd, "mov ax, [rbp-%d]\n", @args);
          o(fd, "push rax\n", NULL);
        }
        else if eq size 1 {
          o(fd, "mov al, [rbp-%d]\n", @args);
          o(fd, "push rax\n", NULL);
        }
        else {
          assert(0, "I_PUSH_LOCAL: bad struct size\n");
        }
      }
      else {
        assert(0, "I_PUSH_LOCAL: type not implemented\n");
      }
    }
    else if eq ins I_PUSH_IMM {
      vo(fd, "; I_PUSH_IMM\n", NULL);
      let dest : u64 = load64 + op Op.dest;
      if eq dest TypeUnsigned64 {
        let value : u64 = load64 + + c Compile.imm load64 + op Op.src0;
        o(fd, "mov rax, %d\n", @value);
        o(fd, "push rax\n", NULL);
      }
      else {
        assert(0, "I_PUSH_IMM: type not implemented\n");
      }
    }
    else if eq ins I_ADD {
      vo(fd, "; I_ADD\n", NULL);
      o(fd,
"pop rax
 pop rbx
 add rbx, rax
 push rbx\n"
      , NULL);
    }
    else if eq ins I_SUB {
      vo(fd, "; I_SUB\n", NULL);
      o(fd,
"pop rax
 pop rbx
 sub rbx, rax
 push rbx\n"
      , NULL);
    }
    else if eq ins I_MUL {
      vo(fd, "; I_MUL\n", NULL);
      o(fd,
"pop rax
 pop rbx
 mul rbx
 push rax\n"
      , NULL);
    }
    else if eq ins I_DIV {
      vo(fd, "; I_DIV\n", NULL);
      o(fd,
"xor rdx, rdx
 pop r8
 pop rax
 div r8
 push rax\n"
      , NULL);
    }
    else if eq ins I_LSHIFT {
      vo(fd, "; I_LSHIFT\n", NULL);
      o(fd,
"pop rcx
 pop rax
 shl rax, cl
 push rax\n"
      , NULL);
    }
    else if eq ins I_RSHIFT {
      vo(fd, "; I_RSHIFT\n", NULL);
      o(fd,
"pop rcx
 pop rax
 shr rax, cl
 push rax\n"
      , NULL);
    }
    else if eq ins I_DIVMOD {
      vo(fd, "; I_DIVMOD\n", NULL);
      o(fd,
"xor rdx, rdx
 pop rbx
 pop rax
 div rbx
 push rdx\n"
      , NULL);
    }
    else if eq ins I_LT {
      vo(fd, "; I_LT\n", NULL);
      o(fd,
"mov rcx, 0
 mov rdx, 1
 pop rax
 pop rbx
 cmp rbx, rax
 cmovl rcx, rdx
 push rcx\n"
      , NULL);
    }
    else if eq ins I_GT {
      vo(fd, "; I_GT\n", NULL);
      o(fd,
"mov rcx, 0
 mov rdx, 1
 pop rax
 pop rbx
 cmp rbx, rax
 cmovg rcx, rdx
 push rcx\n"
      , NULL);
    }
    else if eq ins I_AND {
      vo(fd, "; I_AND\n", NULL);
      o(fd,
"pop rax
 pop rbx
 and rbx, rax
 push rbx\n"
      , NULL);
    }
    else if eq ins I_LOGICAL_NOT {
      vo(fd, "; I_LOGICAL_NOT\n", NULL);
      o(fd,
"pop rax
 cmp rax, 0
 sete al
 movzx rax, al
 push rax\n"
      , NULL);
    }
    else if eq ins I_NOT {
      vo(fd, "; I_NOT\n", NULL);
      o(fd,
"pop rax
 not rax
 push rax\n"
      , NULL);
    }
    else if eq ins I_OR {
      vo(fd, "; I_OR\n", NULL);
      o(fd,
"pop rax
 pop rbx
 or rbx, rax
 push rbx\n"
      , NULL);
    }
    else if eq ins I_EQ {
      vo(fd, "; I_EQ\n", NULL);
      o(fd,
"mov rcx, 0
 mov rdx, 1
 pop rax
 pop rbx
 cmp rbx, rax
 cmove rcx, rdx
 push rcx\n"
      , NULL);
    }
    else if eq ins I_NEQ {
      vo(fd, "; I_NEQ\n", NULL);
      o(fd,
"mov rcx, 0
 mov rdx, 1
 pop rax
 pop rbx
 cmp rbx, rax
 cmovne rcx, rdx
 push rcx\n"
      , NULL);
    }
    else if eq ins I_RET {
      vo(fd, "; I_RET\n", NULL);
      let frame_size : u64 = load64 + op Op.src0;
      o(fd, "pop rax\n", NULL);
      o(fd, "pop rbp\n", NULL);
      if frame_size {
        o(fd, "add rsp, %d\n", @frame_size);
      }
      o(fd, "ret\n", NULL);
    }
    else if eq ins I_NORET {
      vo(fd, "; I_NORET\n", NULL);
      let frame_size : u64 = load64 + op Op.src0;
      o(fd, "pop rbp\n", NULL);
      if frame_size {
        o(fd, "add rsp, %d\n", @frame_size);
      }
      o(fd, "ret\n", NULL);
    }
    else if eq ins I_PRINT {
      vo(fd, "; I_PRINT\n", NULL);
      o(fd, "pop rdi\n", NULL);
      o(fd, "call print\n", NULL);
    }
    else if eq ins I_LABEL {
      vo(fd, "; I_LABEL\n", NULL);
      let dest : u64 = load64 + op Op.dest;
      // symbol : Symbol*
      let symbol : ptr = + + c Compile.symbols * sizeof Symbol dest;
      let name : ptr = + symbol Symbol.name;
      if eq strcmp(cast cstr + symbol Symbol.name, "main") 0 {
        o(fd, "%s:\n", @name);
      }
      else {
        vo(fd, "; `%s`\n", @name);
        o(fd, "v%d:\n", @dest);
      }
    }
    else if eq ins I_CALL {
      vo(fd, "; I_CALL\n", NULL);
      let dest : u64 = load64 + op Op.dest;
      assert(neq dest UINT64_MAX, "I_CALL: invalid argument argument\n");
      let i : u64 = 0;
      let argc : u64 = load64 + op Op.src0;
      while < i argc {
        let reg_name = cast cstr load64 + @func_call_regs_x86_64 * sizeof cstr i;
        o(fd, "pop %s\n", @reg_name);
        store64 @i + 1 i;
      }
      o(fd, "push rbp\n", NULL);
      o(fd, "call v%d\n", @dest);
      o(fd, "pop rbp\n", NULL);
      if neq load64 + op Op.src1 NONE {
        o(fd, "push rax\n", NULL);
      }
    }
    else if eq ins I_ADDR_CALL {
      vo(fd, "; I_ADDR_CALL\n", NULL);
      let i : u64 = 0;
      let argc : u64 = load64 + op Op.src0;
      o(fd, "pop rax\n", NULL);
      while < i argc {
        let reg_name = cast cstr load64 + @func_call_regs_x86_64 * sizeof cstr i;
        o(fd, "pop %s\n", @reg_name);
        store64 @i + 1 i;
      }
      o(fd, "push rbp\n", NULL);
      o(fd, "call rax\n", NULL);
      o(fd, "pop rbp\n", NULL);
      if neq load64 + op Op.src1 NONE {
        o(fd, "push rax\n", NULL);
      }
    }
    else if eq ins I_JMP {
      vo(fd, "; I_JMP\n", NULL);
      let dest : u64 = load64 + op Op.dest;
      o(fd, "jmp L%d\n", @dest);
    }
    else if eq ins I_JZ {
      vo(fd, "; I_JZ\n", NULL);
      let dest : u64 = load64 + op Op.dest;
      o(fd, "pop rax\n", NULL);
      o(fd, "test rax, rax\n", NULL);
      o(fd, "jz L%d\n", @dest);
    }
    else if eq ins I_BEGIN_FUNC {
      vo(fd, "; I_BEGIN_FUNC\n", NULL);
      o(fd, "push rbp\n", NULL);
      o(fd, "mov rbp, rsp\n", NULL);
      let argc : u64 = load64 + op Op.src0;
      let frame_size : u64 = load64 + op Op.src1;
      let i : u64 = 0;
      if frame_size {
        o(fd, "sub rsp, %d\n", @frame_size);
      }
      while < i argc {
        let arg_index : u64 = * sizeof u64 + 1 i; // + 1 because we have pushed rbp onto stack
        let reg_name = cast cstr load64 + @func_call_regs_x86_64 * sizeof cstr i;
        let args : any = (arg_index, reg_name);
        o(fd, "mov [rbp-%d], %s\n", @args);
        store64 @i + 1 i;
      }
    }
    else if eq ins I_LOOP_LABEL {
      vo(fd, "; I_LOOP_LABEL\n", NULL);
      let dest : u64 = load64 + op Op.dest;
      o(fd, "L%d:\n", @dest);
    }
    else if eq ins I_SYSCALL0 {
      vo(fd, "; I_SYSCALL0\n", NULL);
      o(fd,
"pop rax
 syscall
 push rax\n"
      , NULL);
    }
    else if eq ins I_SYSCALL1 {
      vo(fd, "; I_SYSCALL1\n", NULL);
      o(fd,
"pop rax
 pop rdi
 syscall
 push rax\n"
      , NULL);
    }
    else if eq ins I_SYSCALL2 {
      vo(fd, "; I_SYSCALL2\n", NULL);
      o(fd,
"pop rax
 pop rdi
 pop rsi
 syscall
 push rax\n"
      , NULL);
    }
    else if eq ins I_SYSCALL3 {
      vo(fd, "; I_SYSCALL3\n", NULL);
      o(fd,
"pop rax
 pop rdi
 pop rsi
 pop rdx
 syscall
 push rax\n"
      , NULL);
    }
    else if eq ins I_SYSCALL4 {
      vo(fd, "; I_SYSCALL4\n", NULL);
      o(fd,
"pop rax
 pop rdi
 pop rsi
 pop rdx
 pop r10
 syscall
 push rax\n"
      , NULL);
    }
    else if eq ins I_SYSCALL5 {
      vo(fd, "; I_SYSCALL5\n", NULL);
      o(fd,
"pop rax
 pop rdi
 pop rsi
 pop rdx
 pop r10
 pop r8
 syscall
 push rax\n"
      , NULL);
    }
    else if eq ins I_SYSCALL6 {
      vo(fd, "; I_SYSCALL6\n", NULL);
      o(fd,
"pop rax
 pop rdi
 pop rsi
 pop rdx
 pop r10
 pop r8
 pop r9
 syscall
 push rax\n"
      , NULL);
    }
    else {
      assert(0, "instruction not implemented\n");
    }
    store64 @i + 1 i;
  }

  o(fd, "\n%s:\n", @entry);
  o(fd,
"mov rdi, [rsp]
 mov rax, rsp
 add rax, 8
 mov rsi, rax
 push rbp
 call main
 pop rbp
 mov rax, 60 ; exit syscall
 mov rdi, 0 ; return code
 syscall
 ret\n"
  , NULL);

  o(fd, "section .data\n", NULL);
  // constants
  {
    let i : u64 = 0;
    let cstring_count : u64 = load64 + c Compile.cstring_count;
    while < i cstring_count {
      let buffer = cast ptr + + c Compile.imm load64 + + c Compile.cstrings * sizeof u64 i;
      let length : u64 = load64 buffer;
      store64 @buffer + sizeof length buffer;
      o(fd, "str%d: db ", @i);
      let str_index : u64 = 0;
      while < str_index length {
        let ch : u64 = load8 + buffer str_index;
        o(fd, "%d, ", @ch);
        if eq ch 10 { // `\n`
          store64 @str_index + 1 str_index;
        }
        store64 @str_index + 1 str_index;
      }
      o(fd, "0\n", NULL);
      store64 @i + 1 i;
    }
  }
  {
    let i : u64 = 0;
    let count : u64 = load64 + c Compile.symbol_count;
    while < i count {
      // symbol : Symbol*
      let symbol = cast ptr + + c Compile.symbols * sizeof Symbol i;
      let ref_count : u64 = load64 + symbol Symbol.ref_count;
      if not and and eq ref_count 0 eq load64 + @options Options.disable_dce 0 eq load64 + @options Options.dce_all 1 {
        let sym_type : u64 = load64 + symbol Symbol.sym_type;
        if and eq load64 + symbol Symbol.konst 1 or eq sym_type SYM_LOCAL_VAR eq sym_type SYM_GLOBAL_VAR {
          // type : Type
          let type : u64 = load64 + symbol Symbol.type;
          let size : u64 = compile_type_size(type_value(@type));
          let count : u64 = / load64 + symbol Symbol.size size;
          // imm + (count * size) - size
          let name = cast ptr + symbol Symbol.name;
          if eq type_value(@type) TypePtr {
            let imm : u64 = - + load64 + symbol Symbol.imm * size count size;
            o(fd, "v%d: dq", @i);
            let v : u64 = 0;
            while < v count {
              let value : u64 = load64 + + c Compile.imm imm;
              o(fd, " %d,", @value);
              store64 @imm - imm size;
              store64 @v + 1 v;
            }
            vo(fd, " ; `%s`", @name);
            o(fd, "\n", NULL);
          }
          else if eq type_value(@type) TypeUnsigned64 {
            let imm : u64 = - + load64 + symbol Symbol.imm * size count size;
            o(fd, "v%d: dq", @i);
            let v : u64 = 0;
            while < v count {
              let value : u64 = load64 + + c Compile.imm imm;
              o(fd, " %d,", @value);
              store64 @imm - imm size;
              store64 @v + 1 v;
            }
            vo(fd, " ; `%s`", @name);
            o(fd, "\n", NULL);
          }
          else if eq type_value(@type) TypeUnsigned32 {
            store64 @size sizeof u64;
            let imm : u64 = - + load64 + symbol Symbol.imm * size count size;
            o(fd, "v%d: dd", @i);
            let v : u64 = 0;
            while < v count {
              let value : u64 = load32 + + c Compile.imm imm;
              o(fd, " %d,", @value);
              store64 @imm - imm size;
              store64 @v + 1 v;
            }
            vo(fd, " ; `%s`", @name);
            o(fd, "\n", NULL);
          }
          else if eq type_value(@type) TypeUnsigned16 {
            store64 @size sizeof u64;
            let imm : u64 = - + load64 + symbol Symbol.imm * size count size;
            o(fd, "v%d: dw", @i);
            let v : u64 = 0;
            while < v count {
              let value : u64 = load16 + + c Compile.imm imm;
              o(fd, " %d,", @value);
              store64 @imm - imm size;
              store64 @v + 1 v;
            }
            vo(fd, " ; `%s`", @name);
            o(fd, "\n", NULL);
          }
          else if eq type_value(@type) TypeUnsigned8 {
            store64 @size sizeof u64;
            let imm : u64 = - + load64 + symbol Symbol.imm * size count size;
            o(fd, "v%d: db", @i);
            let v : u64 = 0;
            while < v count {
              let value : u64 = load8 + + c Compile.imm imm;
              o(fd, " %d,", @value);
              store64 @imm - imm size;
              store64 @v + 1 v;
            }
            vo(fd, " ; `%s`", @name);
            o(fd, "\n", NULL);
          }
          else {
            assert(0, "type not implemented\n");
          }
        }
      }
      store64 @i + 1 i;
    }
  }
  // symbols
  o(fd, "section .bss\n", NULL);
  {
    let i : u64 = 0;
    let count : u64 = load64 + c Compile.symbol_count;
    while < i count {
      // symbol : Symbol*
      let symbol = cast ptr + + c Compile.symbols * sizeof Symbol i;
      let ref_count : u64 = load64 + symbol Symbol.ref_count;
      if not and and eq ref_count 0 eq load64 + @options Options.disable_dce 0 eq load64 + @options Options.dce_all 1 {
        let sym_type : u64 = load64 + symbol Symbol.sym_type;
        if and eq load64 + symbol Symbol.konst 0 or eq sym_type SYM_LOCAL_VAR eq sym_type SYM_GLOBAL_VAR {
          // type : Type
          let type : u64 = load64 + symbol Symbol.type;
          let size : u64 = load64 + symbol Symbol.size;
          let name = cast cstr + symbol Symbol.name;
          if eq 0 or eq type_value(@type) TypeNone eq type_value(@type) TypeSyscallFunc {
            {
              let args : any = (
                i,
                size
              );
              o(fd, "v%d: resb %d", @args);
            }
            {
              let args : any = (
                name
              );
              // TODO(lucas): print type
              vo(fd, " ; `%s`", @args);
            }
            o(fd, "\n", NULL);
          }
        }
      }
      store64 @i + 1 i;
    }
  }
  load64 + c Compile.status;
}
