// compile.spl

fn symbol_init(symbol : ptr) -> none {
  memset(symbol, 0, sizeof Symbol);
  store64 + symbol Symbol.imm UINT64_MAX;
  store64 + symbol Symbol.size 0;
  store64 + symbol Symbol.num_elements_init 0;
  store64 + symbol Symbol.konst 0;
  store64 + symbol Symbol.sym_type SYM_LOCAL_VAR;
  store64 + symbol Symbol.type TypeNone;
  store64 + symbol Symbol.ref_count 0;
}

fn symbol_print(symbol : ptr) -> none {
  assert(0, "symbol_print(): not implemented yet\n");
}

// block : Block*, fs : Function*, name : Buffer*, symbol : Symbol**, symbol_index : u64*, levels_descend : u64*
fn compile_lookup_value(block : ptr, fs : ptr, name : ptr, symbol : ptr, symbol_index : ptr, levels_descend : ptr) -> u64 {
  let result Error;
  if and < load64 + name Buffer.length MAX_NAME_SIZE neq cast u64 block NULL {
    let copy : u8 : MAX_NAME_SIZE cast u8 0;
    memset(@copy, 0, MAX_NAME_SIZE);
    strncpy(cast cstr @copy, cast cstr load64 + name Buffer.data, load64 + name Buffer.length);
    let i 0;
    let count load64 + block Block.symbol_count;
    let found 0;
    let done 0;
    while and eq done 0 < i count {
      let index : u64 load64 + + block Block.symbols * sizeof u64 i;
      let sym + + c Compile.symbols * sizeof Symbol index;
      if eq 0 strncmp(cast cstr + sym Symbol.name, cast cstr @copy, MAX_NAME_SIZE) {
        if neq cast u64 symbol NULL {
          store64 symbol sym;
        }
        if neq cast u64 symbol_index NULL {
          store64 symbol_index index;
        }
        store64 @result NoError;
        store64 @done 1;
        store64 @found 1;
      }
      store64 @i + 1 i;
    }
    if eq found 0 {
      if neq cast u64 levels_descend NULL {
        store64 levels_descend + 1 load64 levels_descend;
      }
      store64 @result compile_lookup_value(cast ptr load64 + block Block.parent, fs, name, symbol, symbol_index, levels_descend);
    }
  }
  result;
}

// block : Block*, fs : Function*, token : Token*, symbol : Symbol**, symbol_index : u64*
fn compile_declare_value(block : ptr, fs : ptr, token : ptr, symbol : ptr, symbol_index : ptr) -> u64 {
  let result Error;
  if < load64 + token Token.length MAX_NAME_SIZE {
    if < load64 + c Compile.symbol_count MAX_SYMBOL {
      if < load64 + block Block.symbol_count MAX_SYMBOL_PER_BLOCK {
        let levels 0; // how many levels did we descend before we found a symbol?
        let token_buffer : Buffer 0;
        store64 + @token_buffer Buffer.data   load64 + token Token.buffer;
        store64 + @token_buffer Buffer.length load64 + token Token.length;

        // we are only allowed to create a new symbol if none was found in the current block
        let lookup_result compile_lookup_value(block, fs, @token_buffer, symbol, NULL, @levels);
        if and eq lookup_result NoError eq levels 0 {
          let message cast cstr tmp_it;
          tmp_push_cstr("symbol `");
          tmp_push_str(load64 + token Token.buffer, load64 + token Token.length);
          tmp_push_cstr("` already exists\n");
          tmp_push_byte(cast u8 0);
          compile_error(message);
          store64 @tmp_it message;
        }
        else {
          let index load64 + c Compile.symbol_count;
          if neq cast u64 symbol_index NULL {
            store64 symbol_index index;
          }
          let block_index_address * load64 + block Block.symbol_count sizeof u64;
          // block->symbols[block->symbol_count] store64 index;
          store64 + + block Block.symbols block_index_address index;
          // *symbol store64 &c->symbols[index];
          store64 symbol + + c Compile.symbols * sizeof Symbol index;

          store64 + c Compile.symbol_count + 1 load64 + c Compile.symbol_count;
          store64 + block Block.symbol_count + 1 load64 + block Block.symbol_count;

          let s cast ptr load64 symbol;
          symbol_init(s);
          memcpy(+ s Symbol.token, token, sizeof Token);
          memcpy(+ s Symbol.name, load64 + token Token.buffer, load64 + token Token.length);
          store64 @result NoError;
        }
      }
      else {
        assert(0, "symbol capacity in block reached\n");
      }
    }
    else {
      assert(0, "symbol capacity reached\n");
    }
  }
  else {
    assert(0, "value name too long\n");
  }
  result;
}

fn compile_create_syscall(name : cstr, argc : u64) -> u64 {
  let result NoError;
  let block + c Compile.global;
  let token : Token 0;
  store64 + @token Token.buffer name;
  store64 + @token Token.length strnlen(name, MAX_NAME_SIZE);
  store64 + @token Token.type T_IDENTIFIER;
  store64 + @token Token.filename "internal";
  store64 + @token Token.source "";
  store64 + @token Token.line 0;
  store64 + @token Token.column 0;

  let symbol : ptr NULL;
  let symbol_index UINT64_MAX;
  if eq compile_declare_value(block, NULL, @token, @symbol, @symbol_index) NoError {
    store64 + symbol Symbol.size load64 + @compile_type_size * sizeof u64 TypeSyscallFunc;
    store64 + symbol Symbol.sym_type SYM_FUNC;
    store64 + symbol Symbol.type TypeSyscallFunc;
    store64 + + symbol Symbol.token Token.v symbol_index;
    store64 + symbol Symbol.ref_count 1;
    let func + + symbol Symbol.value Value.func;
    store64 + func Function.ir_address UINT64_MAX;
    store64 + func Function.label UINT64_MAX;
    store64 + func Function.argc + 1 argc;
    store64 + func Function.locals_offset_counter 0;
    store64 + func Function.rtype TypeUnsigned64;
  }
  else {
    compile_error("symbol already exists\n");
    store64 @result Error;
  }
  result;
}

// name : cstr, value : Value*, type : u64
fn compile_create_value(name : cstr, value : ptr, type : u64) -> u64 {
  let result NoError;
  let block + c Compile.global;
  let token : Token 0;
  store64 + @token Token.buffer name;
  store64 + @token Token.length strnlen(name, MAX_NAME_SIZE);
  store64 + @token Token.type T_IDENTIFIER;
  store64 + @token Token.filename "internal";
  store64 + @token Token.source "";
  store64 + @token Token.line 0;
  store64 + @token Token.column 0;

  let imm : u64 ir_push_value(+ value Value.num, sizeof u64);
  if neq imm UINT64_MAX {
    let symbol : ptr NULL;
    let symbol_index UINT64_MAX;
    if eq compile_declare_value(block, NULL, @token, @symbol, @symbol_index) NoError {
      store64 + symbol Symbol.imm imm;
      store64 + symbol Symbol.size load64 + @compile_type_size * sizeof u64 type;
      store64 + symbol Symbol.konst 1;
      store64 + symbol Symbol.sym_type SYM_GLOBAL_VAR;
      store64 + symbol Symbol.type type;
      store64 + + symbol Symbol.token Token.v symbol_index;
      memcpy(+ symbol Symbol.value, value, sizeof Value);
      store64 + symbol Symbol.ref_count 1;
    }
    else {
      compile_error("symbol already exists\n");
      store64 @result Error;
    }
  }
  else {
    compile_error("out of immediate data memory\n");
    store64 @result Error;
  }

  result;
}


fn compile_print_symbol_info(fd : u64) -> none {
  dprintf(fd, "compile_print_symbol_info:\n", NULL);
  let message cast cstr tmp_it;
  let count : u64 load64 + c Compile.symbol_count;
  let i : u64 0;
  while < i count {
    let symbol + + c Compile.symbols * sizeof Symbol i;
    let name cast cstr + symbol Symbol.name;
    let type load64 + symbol Symbol.type;
    let num_i_digits : u64 digit_count(i);
    let j : u64 0;

    if neq type TypeSyscallFunc {
      while < j - 3 num_i_digits {
        dprintf(fd, "0", NULL);
        store64 @j + 1 j;
      }
      dprintf(fd, "%d: ", @i);
      if eq type TypeFunc {
        let func cast ptr + + symbol Symbol.value Value.func;
        dprintf(fd, "%s(", @name);

        // iterate args
        let arg_index : u64 0;
        let arg_count : u64 load64 + func Function.argc;
        while < arg_index arg_count {
          // Symbol* arg = &c->symbols[func->args[arg_index]];
          let arg cast ptr + + c Compile.symbols * sizeof Symbol load64 + + func Function.args * sizeof u64 arg_index;
          let num_elements : u64 / (load64 + arg Symbol.size) (load64 + @compile_type_size * sizeof u64 load64 + arg Symbol.type);
          dprintf(fd, "%s", + @compile_type_str * sizeof cstr load64 + arg Symbol.type);

          if > num_elements 1 {
            dprintf(fd, " : %d", @num_elements);
          }

          if neq arg_index - arg_count 1 {
            dprintf(fd, ", ", NULL);
          }
          store64 @arg_index + 1 arg_index;
        }
        dprintf(fd, ") -> %s", + @compile_type_str * sizeof cstr load64 + func Function.rtype);
      }
      else {
        let count : u64 / load64 + symbol Symbol.size load64 + @compile_type_size * sizeof u64 type;
        let type_name cast cstr load64 + @compile_type_str * sizeof cstr type;
        let args : any (name, type_name);
        dprintf(fd, "%s : %s", @args);
        if > count 1 {
          dprintf(fd, " : %d", @count);
        }
      }
      let args : any (
        load64 + symbol Symbol.konst,
        load64 + symbol Symbol.ref_count
      );
      dprintf(fd, " (konst = %d, ref_count = %d)\n", @args);
      // let args : any (
      //   load64 + + symbol Symbol.token Token.filename,
      //   load64 + + symbol Symbol.token Token.line,
      //   load64 + + symbol Symbol.token Token.column
      // );
      // dprintf(fd, " - %s:%d:%d\n", @args);
    }
    store64 @i + 1 i;
  }
  store64 @tmp_it message;
}

// fd : u64, block : Block*
fn compile_print_block(fd : u64, block : ptr) -> none {
  let count load64 + block Block.symbol_count;
  let i 0;
  puts(fd, "compile_print_block:\n");
  while < i count {
    let index : u64 load64 + + block Block.symbols * sizeof u64 i;
    print index;
    store64 @i + 1 i;
  }
}

fn o(fd : u64, format : cstr, args : any) -> none {
  dprintf(fd, format, args);
}

fn vo_empty(fd : u64, format : cstr, args : any) -> none {}

fn compile_linux_nasm_x86_64(fd : u64) -> u64 {
  let vo vo_empty;

  if load64 + @options Options.verbose_asm {
    store64 @vo o;
  }

  let func_call_regs_x86_64 : cstr (
    "rdi",
    "rsi",
    "rdx",
    "rcx",
    "r8",
    "r9"
  );
  let entry "_start";

  o(fd, "bits 64\n", NULL);
  o(fd, "section .text\n", NULL);
  o(fd, "global %s\n", @entry);
  o(fd,
"print:
 mov r9, -3689348814741910323
 sub rsp, 40
 mov BYTE [rsp+31], 10
 lea rcx, [rsp+30]
 .L2:
 mov rax, rdi
 lea r8, [rsp+32]
 mul r9
 mov rax, rdi
 sub r8, rcx
 shr rdx, 3
 lea rsi, [rdx+rdx*4]
 add rsi, rsi
 sub rax, rsi
 add eax, 48
 mov BYTE [rcx], al
 mov rax, rdi
 mov rdi, rdx
 mov rdx, rcx
 sub rcx, 1
 cmp rax, 9
 ja .L2
 lea rax, [rsp+32]
 mov edi, 1
 sub rdx, rax
 xor eax, eax
 lea rsi, [rsp+32+rdx]
 mov rdx, r8
 mov rax, 1
 syscall
 add rsp, 40
 ret
", NULL);

  let i : u64 0;
  let count : u64 load64 + c Compile.ins_count;
  while < i count {
    // op : Op*
    let op cast ptr + + c Compile.ins * sizeof Op i;
    let ins : u64 load64 + op Op.i;
    if eq ins I_NOP {
      o(fd, "nop\n", NULL);
    }
    else if eq ins I_POP {
      vo(fd, "; I_POP\n", NULL);
      o(fd, "pop rax\n", NULL);
    }
    else if eq ins I_MOVE {
      vo(fd, "; I_MOVE\n", NULL);
      let dest : u64 load64 + op Op.dest;
      let args : any (load64 + op Op.src0, load64 + op Op.src1);
      if or or or or
          eq dest TypeAny
          eq dest TypePtr
          eq dest TypeCString
          eq dest TypeFunc
          eq dest TypeUnsigned64 {
        o(fd, "pop rax\n", NULL);
        o(fd, "mov [v%d+%d], rax\n", @args);
      }
      else if eq dest TypeUnsigned32 {
        o(fd, "pop rax\n", NULL);
        o(fd, "mov [v%d+%d], eax\n", @args);
      }
      else if eq dest TypeUnsigned16 {
        o(fd, "pop rax\n", NULL);
        o(fd, "mov [v%d+%d], ax\n", @args);
      }
      else if eq dest TypeUnsigned8 {
        o(fd, "pop rax\n", NULL);
        o(fd, "mov [v%d+%d], al\n", @args);
      }
      else {
        assert(0, "I_MOVE: type not implemented yet\n");
      }
    }
    else if eq ins I_MOVE_LOCAL {
      vo(fd, "; I_MOVE_LOCAL\n", NULL);
      let dest : u64 load64 + op Op.dest;
      let args : any (load64 + op Op.src0);
      if or or or or
          eq dest TypeAny
          eq dest TypePtr
          eq dest TypeCString
          eq dest TypeFunc
          eq dest TypeUnsigned64 {
        o(fd, "pop rax\n", NULL);
        o(fd, "mov [rbp-%d], rax\n", @args);
      }
      else if eq dest TypeUnsigned32 {
        o(fd, "pop rax\n", NULL);
        o(fd, "mov DWORD [rbp-%d], eax\n", @args);
      }
      else if eq dest TypeUnsigned16 {
        o(fd, "pop rax\n", NULL);
        o(fd, "mov WORD [rbp-%d], ax\n", @args);
      }
      else if eq dest TypeUnsigned8 {
        o(fd, "pop rax\n", NULL);
        o(fd, "mov BYTE [rbp-%d], al\n", @args);
      }
      else {
        assert(0, "I_MOVE_LOCAL: type not implemented yet\n");
      }
    }
    else if eq ins I_STORE64 {
      vo(fd, "; I_STORE64\n", NULL);
      o(fd, "pop rbx\n", NULL);
      o(fd, "pop rax\n", NULL);
      o(fd, "mov [rax], rbx\n", NULL);
    }
    else if eq ins I_STORE32 {
      vo(fd, "; I_STORE32\n", NULL);
      o(fd, "pop rbx\n", NULL);
      o(fd, "pop rax\n", NULL);
      o(fd, "mov [rax], ebx\n", NULL);
    }
    else if eq ins I_STORE16 {
      vo(fd, "; I_STORE16\n", NULL);
      o(fd, "pop rbx\n", NULL);
      o(fd, "pop rax\n", NULL);
      o(fd, "mov [rax], bx\n", NULL);
    }
    else if eq ins I_STORE8 {
      vo(fd, "; I_STORE8\n", NULL);
      o(fd, "pop rbx\n", NULL);
      o(fd, "pop rax\n", NULL);
      o(fd, "mov [rax], bl\n", NULL);
    }
    else if eq ins I_LOAD64 {
      vo(fd, "; I_LOAD64\n", NULL);
      o(fd, "pop rax\n", NULL);
      o(fd, "xor rbx, rbx\n", NULL);
      o(fd, "mov rbx, [rax]\n", NULL);
      o(fd, "push rbx\n", NULL);
    }
    else if eq ins I_LOAD32 {
      vo(fd, "; I_LOAD32\n", NULL);
      o(fd, "pop rax\n", NULL);
      o(fd, "xor rbx, rbx\n", NULL);
      o(fd, "mov ebx, [rax]\n", NULL);
      o(fd, "push rbx\n", NULL);
    }
    else if eq ins I_LOAD16 {
      vo(fd, "; I_LOAD16\n", NULL);
      o(fd, "pop rax\n", NULL);
      o(fd, "xor rbx, rbx\n", NULL);
      o(fd, "mov bx, [rax]\n", NULL);
      o(fd, "push rbx\n", NULL);
    }
    else if eq ins I_LOAD8 {
      vo(fd, "; I_LOAD8\n", NULL);
      o(fd, "pop rax\n", NULL);
      o(fd, "xor rbx, rbx\n", NULL);
      o(fd, "mov bl, [rax]\n", NULL);
      o(fd, "push rbx\n", NULL);
    }
    else if eq ins I_PUSH_ADDR_OF {
      vo(fd, "; I_PUSH_ADDR_OF\n", NULL);
      let args : any (load64 + op Op.src0);
      o(fd, "mov rax, v%d\n", @args);
      o(fd, "push rax\n", NULL);
    }
    else if eq ins I_PUSH_LOCAL_ADDR_OF {
      vo(fd, "; I_PUSH_LOCAL_ADDR_OF\n", NULL);
      let args : any (load64 + op Op.src0);
      o(fd, "lea rax, [rbp-%d]\n", @args);
      o(fd, "push rax\n", NULL);
    }
    else if eq ins I_PUSH {
      vo(fd, "; I_PUSH\n", NULL);
      let dest : u64 load64 + op Op.dest;
      let args : any (load64 + op Op.src0);
      if or or
          eq dest TypeAny
          eq dest TypePtr
          eq dest TypeUnsigned64 {
        o(fd, "mov rax, [v%d]\n", @args);
        o(fd, "push rax\n", NULL);
      }
      else if eq dest TypeUnsigned32 {
        o(fd, "xor rax, rax\n", NULL);
        o(fd, "mov eax, [v%d]\n", @args);
        o(fd, "push rax\n", NULL);
      }
      else if eq dest TypeUnsigned16 {
        o(fd, "xor rax, rax\n", NULL);
        o(fd, "mov ax, [v%d]\n", @args);
        o(fd, "push rax\n", NULL);
      }
      else if eq dest TypeUnsigned8 {
        o(fd, "xor rax, rax\n", NULL);
        o(fd, "mov al, [v%d]\n", @args);
        o(fd, "push rax\n", NULL);
      }
      else if eq dest TypeCString {
        o(fd, "mov rax, str%d\n", @args);
        o(fd, "push rax\n", NULL);
      }
      else if eq dest TypeFunc {
        o(fd, "mov rax, v%d\n", @args);
        o(fd, "push rax\n", NULL);
      }
      else {
        assert(0, "I_PUSH: type not implemented\n");
      }
    }
    else if eq ins I_PUSH_LOCAL {
      vo(fd, "; I_PUSH_LOCAL\n", NULL);
      let dest : u64 load64 + op Op.dest;
      let args : any (load64 + op Op.src0);
      if or or or or
          eq dest TypeAny
          eq dest TypePtr
          eq dest TypeCString
          eq dest TypeFunc
          eq dest TypeUnsigned64 {
        o(fd, "push QWORD [rbp-%d]\n", @args);
      }
      else if eq dest TypeUnsigned32 {
        o(fd, "mov eax, [rbp-%d]\n", @args);
        o(fd, "push rax\n", NULL);
      }
      else if eq dest TypeUnsigned16 {
        o(fd, "mov ax, [rbp-%d]\n", @args);
        o(fd, "push rax\n", NULL);
      }
      else if eq dest TypeUnsigned8 {
        o(fd, "mov al, [rbp-%d]\n", @args);
        o(fd, "push rax\n", NULL);
      }
      else {
        assert(0, "I_PUSH_LOCAL: type not implemented\n");
      }
    }
    else if eq ins I_PUSH_IMM {
      vo(fd, "; I_PUSH_IMM\n", NULL);
      let dest : u64 load64 + op Op.dest;
      if eq dest TypeUnsigned64 {
        let value : u64 load64 + + c Compile.imm load64 + op Op.src0;
        o(fd, "mov rax, %d\n", @value);
        o(fd, "push rax\n", NULL);
      }
      else {
        assert(0, "I_PUSH_IMM: type not implemented\n");
      }
    }
    else if eq ins I_ADD {
      vo(fd, "; I_ADD\n", NULL);
      o(fd,
"pop rax
 pop rbx
 add rbx, rax
 push rbx\n"
      , NULL);
    }
    else if eq ins I_SUB {
      vo(fd, "; I_SUB\n", NULL);
      o(fd,
"pop rax
 pop rbx
 sub rbx, rax
 push rbx\n"
      , NULL);
    }
    else if eq ins I_MUL {
      vo(fd, "; I_MUL\n", NULL);
      o(fd,
"pop rax
 pop rbx
 mul rbx
 push rax\n"
      , NULL);
    }
    else if eq ins I_DIV {
      vo(fd, "; I_DIV\n", NULL);
      o(fd,
"xor rdx, rdx
 pop r8
 pop rax
 div r8
 push rax\n"
      , NULL);
    }
    else if eq ins I_LSHIFT {
      vo(fd, "; I_LSHIFT\n", NULL);
      o(fd,
"pop rcx
 pop rax
 shl rax, cl
 push rax\n"
      , NULL);
    }
    else if eq ins I_RSHIFT {
      vo(fd, "; I_RSHIFT\n", NULL);
      o(fd,
"pop rcx
 pop rax
 shr rax, cl
 push rax\n"
      , NULL);
    }
    else if eq ins I_DIVMOD {
      vo(fd, "; I_DIVMOD\n", NULL);
      o(fd,
"xor rdx, rdx
 pop rbx
 pop rax
 div rbx
 push rdx\n"
      , NULL);
    }
    else if eq ins I_LT {
      vo(fd, "; I_LT\n", NULL);
      o(fd,
"mov rcx, 0
 mov rdx, 1
 pop rax
 pop rbx
 cmp rbx, rax
 cmovl rcx, rdx
 push rcx\n"
      , NULL);
    }
    else if eq ins I_GT {
      vo(fd, "; I_GT\n", NULL);
      o(fd,
"mov rcx, 0
 mov rdx, 1
 pop rax
 pop rbx
 cmp rbx, rax
 cmovg rcx, rdx
 push rcx\n"
      , NULL);
    }
    else if eq ins I_AND {
      vo(fd, "; I_AND\n", NULL);
      o(fd,
"pop rax
 pop rbx
 and rbx, rax
 push rbx\n"
      , NULL);
    }
    else if eq ins I_LOGICAL_NOT {
      vo(fd, "; I_LOGICAL_NOT\n", NULL);
      o(fd,
"pop rax
 cmp rax, 0
 sete al
 movzx rax, al
 push rax\n"
      , NULL);
    }
    else if eq ins I_OR {
      vo(fd, "; I_OR\n", NULL);
      o(fd,
"pop rax
 pop rbx
 or rbx, rax
 push rbx\n"
      , NULL);
    }
    else if eq ins I_EQ {
      vo(fd, "; I_EQ\n", NULL);
      o(fd,
"mov rcx, 0
 mov rdx, 1
 pop rax
 pop rbx
 cmp rbx, rax
 cmove rcx, rdx
 push rcx\n"
      , NULL);
    }
    else if eq ins I_NEQ {
      vo(fd, "; I_NEQ\n", NULL);
      o(fd,
"mov rcx, 0
 mov rdx, 1
 pop rax
 pop rbx
 cmp rbx, rax
 cmovne rcx, rdx
 push rcx\n"
      , NULL);
    }
    else if eq ins I_RET {
      vo(fd, "; I_RET\n", NULL);
      let frame_size : u64 load64 + op Op.src0;
      o(fd, "pop rax\n", NULL);
      o(fd, "pop rbp\n", NULL);
      o(fd, "add rsp, %d\n", @frame_size);
      o(fd, "ret\n", NULL);
    }
    else if eq ins I_NORET {
      vo(fd, "; I_NORET\n", NULL);
      let frame_size : u64 load64 + op Op.src0;
      o(fd, "pop rbp\n", NULL);
      o(fd, "add rsp, %d\n", @frame_size);
      o(fd, "ret\n", NULL);
    }
    else if eq ins I_PRINT {
      vo(fd, "; I_PRINT\n", NULL);
      o(fd, "pop rdi\n", NULL);
      o(fd, "call print\n", NULL);
    }
    else if eq ins I_LABEL {
      vo(fd, "; I_LABEL\n", NULL);
      let dest : u64 load64 + op Op.dest;
      // symbol : Symbol*
      let symbol : ptr + + c Compile.symbols * sizeof Symbol dest;
      let name : ptr + symbol Symbol.name;
      if eq strcmp(cast cstr + symbol Symbol.name, "main") 0 {
        o(fd, "%s:\n", @name);
      }
      else {
        vo(fd, "; `%s`\n", @name);
        o(fd, "v%d:\n", @dest);
      }
    }
    else if eq ins I_CALL {
      vo(fd, "; I_CALL\n", NULL);
      let dest : u64 load64 + op Op.dest;
      assert(neq dest UINT64_MAX, "I_CALL: invalid argument argument\n");
      let i : u64 0;
      let argc : u64 load64 + op Op.src0;
      while < i argc {
        let reg_name cast cstr load64 + @func_call_regs_x86_64 * sizeof cstr i;
        o(fd, "pop %s\n", @reg_name);
        store64 @i + 1 i;
      }
      o(fd, "push rbp\n", NULL);
      o(fd, "call v%d\n", @dest);
      o(fd, "pop rbp\n", NULL);
      if neq load64 + op Op.src1 NONE {
        o(fd, "push rax\n", NULL);
      }
    }
    else if eq ins I_ADDR_CALL {
      vo(fd, "; I_ADDR_CALL\n", NULL);
      let i : u64 0;
      let argc : u64 load64 + op Op.src0;
      o(fd, "pop rax\n", NULL);
      while < i argc {
        let reg_name cast cstr load64 + @func_call_regs_x86_64 * sizeof cstr i;
        o(fd, "pop %s\n", @reg_name);
        store64 @i + 1 i;
      }
      o(fd, "push rbp\n", NULL);
      o(fd, "call rax\n", NULL);
      o(fd, "pop rbp\n", NULL);
      if neq load64 + op Op.src1 NONE {
        o(fd, "push rax\n", NULL);
      }
    }
    else if eq ins I_JMP {
      vo(fd, "; I_JMP\n", NULL);
      let dest : u64 load64 + op Op.dest;
      o(fd, "jmp L%d\n", @dest);
    }
    else if eq ins I_JZ {
      vo(fd, "; I_JZ\n", NULL);
      let dest : u64 load64 + op Op.dest;
      o(fd, "pop rax\n", NULL);
      o(fd, "test rax, rax\n", NULL);
      o(fd, "jz L%d\n", @dest);
    }
    else if eq ins I_BEGIN_FUNC {
      vo(fd, "; I_BEGIN_FUNC\n", NULL);
      o(fd, "push rbp\n", NULL);
      o(fd, "mov rbp, rsp\n", NULL);
      let argc : u64 load64 + op Op.src0;
      let frame_size : u64 load64 + op Op.src1;
      let i : u64 0;
      o(fd, "sub rsp, %d\n", @frame_size);
      while < i argc {
        let arg_index : u64 * sizeof u64 + 1 i; // + 1 because we have pushed rbp onto stack
        let reg_name cast cstr load64 + @func_call_regs_x86_64 * sizeof cstr i;
        let args : any (arg_index, reg_name);
        o(fd, "mov [rbp-%d], %s\n", @args);
        store64 @i + 1 i;
      }
    }
    else if eq ins I_LOOP_LABEL {
      vo(fd, "; I_LOOP_LABEL\n", NULL);
      let dest : u64 load64 + op Op.dest;
      o(fd, "L%d:\n", @dest);
    }
    else if eq ins I_SYSCALL0 {
      vo(fd, "; I_SYSCALL0\n", NULL);
      o(fd,
"pop rax
 syscall
 push rax\n"
      , NULL);
    }
    else if eq ins I_SYSCALL1 {
      vo(fd, "; I_SYSCALL1\n", NULL);
      o(fd,
"pop rax
 pop rdi
 syscall
 push rax\n"
      , NULL);
    }
    else if eq ins I_SYSCALL2 {
      vo(fd, "; I_SYSCALL2\n", NULL);
      o(fd,
"pop rax
 pop rdi
 pop rsi
 syscall
 push rax\n"
      , NULL);
    }
    else if eq ins I_SYSCALL3 {
      vo(fd, "; I_SYSCALL3\n", NULL);
      o(fd,
"pop rax
 pop rdi
 pop rsi
 pop rdx
 syscall
 push rax\n"
      , NULL);
    }
    else if eq ins I_SYSCALL4 {
      vo(fd, "; I_SYSCALL4\n", NULL);
      o(fd,
"pop rax
 pop rdi
 pop rsi
 pop rdx
 pop r10
 syscall
 push rax\n"
      , NULL);
    }
    else if eq ins I_SYSCALL5 {
      vo(fd, "; I_SYSCALL5\n", NULL);
      o(fd,
"pop rax
 pop rdi
 pop rsi
 pop rdx
 pop r10
 pop r8
 syscall
 push rax\n"
      , NULL);
    }
    else if eq ins I_SYSCALL6 {
      vo(fd, "; I_SYSCALL6\n", NULL);
      o(fd,
"pop rax
 pop rdi
 pop rsi
 pop rdx
 pop r10
 pop r8
 pop r9
 syscall
 push rax\n"
      , NULL);
    }
    else {
      assert(0, "instruction not implemented\n");
    }
    store64 @i + 1 i;
  }

  o(fd, "\n%s:\n", @entry);
  o(fd,
"mov rdi, [rsp]
 mov rax, rsp
 add rax, 8
 mov rsi, rax
 push rbp
 call main
 pop rbp
 mov rax, 60 ; exit syscall
 mov rdi, 0 ; return code
 syscall
 ret\n"
  , NULL);

  o(fd, "section .data\n", NULL);
  // constants
  {
    let i : u64 0;
    let cstring_count : u64 load64 + c Compile.cstring_count;
    while < i cstring_count {
      let buffer cast ptr + + c Compile.imm load64 + + c Compile.cstrings * sizeof u64 i;
      let length : u64 load64 buffer;
      store64 @buffer + sizeof length buffer;
      o(fd, "str%d: db ", @i);
      let str_index : u64 0;
      while < str_index length {
        let ch : u64 load8 + buffer str_index;
        o(fd, "%d, ", @ch);
        if eq ch 10 { // `\n`
          store64 @str_index + 1 str_index;
        }
        store64 @str_index + 1 str_index;
      }
      o(fd, "0\n", NULL);
      store64 @i + 1 i;
    }
  }
  {
    let i : u64 0;
    let count : u64 load64 + c Compile.symbol_count;
    while < i count {
      // symbol : Symbol*
      let symbol cast ptr + + c Compile.symbols * sizeof Symbol i;
      let ref_count : u64 load64 + symbol Symbol.ref_count;
      if not and and eq ref_count 0 eq load64 + @options Options.disable_dce 0 eq load64 + @options Options.dce_all 1 {
        let sym_type : u64 load64 + symbol Symbol.sym_type;
        if and eq load64 + symbol Symbol.konst 1 or eq sym_type SYM_LOCAL_VAR eq sym_type SYM_GLOBAL_VAR {
          let type : u64 load64 + symbol Symbol.type;
          let size : u64 load64 + @compile_type_size * sizeof u64 type;
          let count : u64 / load64 + symbol Symbol.size size;
          // imm + (count * size) - size
          let name cast ptr + symbol Symbol.name;
          if eq type TypeUnsigned64 {
            let imm : u64 - + load64 + symbol Symbol.imm * size count size;
            o(fd, "v%d: dq", @i);
            let v : u64 0;
            while < v count {
              let value : u64 load64 + + c Compile.imm imm;
              o(fd, " %d,", @value);
              store64 @imm - imm size;
              store64 @v + 1 v;
            }
            vo(fd, " ; `%s`", @name);
            o(fd, "\n", NULL);
          }
          else if eq type TypeUnsigned32 {
            store64 @size sizeof u64;
            let imm : u64 - + load64 + symbol Symbol.imm * size count size;
            o(fd, "v%d: dd", @i);
            let v : u64 0;
            while < v count {
              let value : u64 load32 + + c Compile.imm imm;
              o(fd, " %d,", @value);
              store64 @imm - imm size;
              store64 @v + 1 v;
            }
            vo(fd, " ; `%s`", @name);
            o(fd, "\n", NULL);
          }
          else if eq type TypeUnsigned16 {
            store64 @size sizeof u64;
            let imm : u64 - + load64 + symbol Symbol.imm * size count size;
            o(fd, "v%d: dw", @i);
            let v : u64 0;
            while < v count {
              let value : u64 load16 + + c Compile.imm imm;
              o(fd, " %d,", @value);
              store64 @imm - imm size;
              store64 @v + 1 v;
            }
            vo(fd, " ; `%s`", @name);
            o(fd, "\n", NULL);
          }
          else if eq type TypeUnsigned8 {
            store64 @size sizeof u64;
            let imm : u64 - + load64 + symbol Symbol.imm * size count size;
            o(fd, "v%d: db", @i);
            let v : u64 0;
            while < v count {
              let value : u64 load8 + + c Compile.imm imm;
              o(fd, " %d,", @value);
              store64 @imm - imm size;
              store64 @v + 1 v;
            }
            vo(fd, " ; `%s`", @name);
            o(fd, "\n", NULL);
          }
          else {
            assert(0, "type not implemented\n");
          }
        }
      }
      store64 @i + 1 i;
    }
  }
  // symbols
  o(fd, "section .bss\n", NULL);
  {
    let i : u64 0;
    let count : u64 load64 + c Compile.symbol_count;
    while < i count {
      // symbol : Symbol*
      let symbol cast ptr + + c Compile.symbols * sizeof Symbol i;
      let ref_count : u64 load64 + symbol Symbol.ref_count;
      if not and and eq ref_count 0 eq load64 + @options Options.disable_dce 0 eq load64 + @options Options.dce_all 1 {
        let sym_type : u64 load64 + symbol Symbol.sym_type;
        if and eq load64 + symbol Symbol.konst 0 or eq sym_type SYM_LOCAL_VAR eq sym_type SYM_GLOBAL_VAR {
          let type : u64 load64 + symbol Symbol.type;
          let size : u64 load64 + symbol Symbol.size;
          let name cast cstr + symbol Symbol.name;
          let type_name cast cstr load64 + @compile_type_str * sizeof cstr type;
          if eq 0 or eq type TypeNone eq type TypeSyscallFunc {
            {
              let args : any (
                i,
                size
              );
              o(fd, "v%d: resb %d", @args);
            }
            {
              let args : any (
                name,
                type_name
              );
              vo(fd, " ; `%s` : %s", @args);
            }
            o(fd, "\n", NULL);
          }
        }
      }
      store64 @i + 1 i;
    }
  }
  load64 + c Compile.status;
}

fn compile(target : u64, fd : u64) -> u64 {
  let result NoError;
  let time_start : timespec 0;
  let time_end : timespec 0;
  { let _ clock_gettime(CLOCK_MONOTONIC, @time_start); }

  if eq target TARGET_LINUX_NASM_X86_64 {
    store64 @result compile_linux_nasm_x86_64(fd);
  }
  else {
    assert(0, "invalid compile target\n");
  }

  { let _ clock_gettime(CLOCK_MONOTONIC, @time_end); }

  if eq load64 + c Compile.status NoError {
    let message cast cstr tmp_it;
    let args : any (
      - load64 + @time_end timespec.tv_sec load64 + @time_start timespec.tv_sec,
      / - load64 + @time_end timespec.tv_nsec load64 + @time_start timespec.tv_nsec TIME_NANOSECONDS_DENOM
    );
    sprintf(cast ptr message, "code generation took %d.%d seconds\n", @args);
    print_info(message);
  }

  result;
}

fn compile_print_final -> none {
  let args : any (
    load64 + c Compile.warning_count,
    load64 + c Compile.error_count
  );
  if eq load64 + c Compile.status Error {
    printf("compilation fail:\n", NULL);
    printf("  warning(s): %d\n  error(s): %d\n", @args);
  }
  if load64 + @options Options.verbose {
    if eq load64 + c Compile.status NoError {
      printf("compilation success:\n", NULL);
    }
    printf("  warning(s): %d\n  error(s): %d\n", @args);
  }
}

fn compile_state_init -> u64 {
  store64 @c memory_alloc(sizeof Compile);
  store64 + c Compile.ins_count 0;
  store64 + c Compile.imm_index 0;
  store64 + c Compile.symbol_count 0;
  store64 + c Compile.cstring_count 0;
  block_init(+ c Compile.global, NULL);
  store64 + c Compile.label_count 0;
  store64 + c Compile.status NoError;
  store64 + c Compile.entry_point 0;
  store64 + c Compile.ts_count 0;
  store64 + c Compile.vs_count 0;
  store64 + c Compile.type_count MAX_PRIMITIVE_TYPE;
  store64 + c Compile.warning_count 0;
  store64 + c Compile.error_count 0;

  store64 + @ir_code_str * I_NOP                sizeof cstr "I_NOP";
  store64 + @ir_code_str * I_POP                sizeof cstr "I_POP";
  store64 + @ir_code_str * I_MOVE               sizeof cstr "I_MOVE";
  store64 + @ir_code_str * I_MOVE_LOCAL         sizeof cstr "I_MOVE_LOCAL";
  store64 + @ir_code_str * I_STORE64            sizeof cstr "I_STORE64";
  store64 + @ir_code_str * I_STORE32            sizeof cstr "I_STORE32";
  store64 + @ir_code_str * I_STORE16            sizeof cstr "I_STORE16";
  store64 + @ir_code_str * I_STORE8             sizeof cstr "I_STORE8";
  store64 + @ir_code_str * I_LOAD64             sizeof cstr "I_LOAD64";
  store64 + @ir_code_str * I_LOAD32             sizeof cstr "I_LOAD32";
  store64 + @ir_code_str * I_LOAD16             sizeof cstr "I_LOAD16";
  store64 + @ir_code_str * I_LOAD8              sizeof cstr "I_LOAD8";
  store64 + @ir_code_str * I_PUSH_ADDR_OF       sizeof cstr "I_PUSH_ADDR_OF";
  store64 + @ir_code_str * I_PUSH_LOCAL_ADDR_OF sizeof cstr "I_PUSH_LOCAL_ADDR_OF";
  store64 + @ir_code_str * I_PUSH               sizeof cstr "I_PUSH";
  store64 + @ir_code_str * I_PUSH_LOCAL         sizeof cstr "I_PUSH_LOCAL";
  store64 + @ir_code_str * I_PUSH_IMM           sizeof cstr "I_PUSH_IMM";
  store64 + @ir_code_str * I_ADD                sizeof cstr "I_ADD";
  store64 + @ir_code_str * I_SUB                sizeof cstr "I_SUB";
  store64 + @ir_code_str * I_MUL                sizeof cstr "I_MUL";
  store64 + @ir_code_str * I_LSHIFT             sizeof cstr "I_LSHIFT";
  store64 + @ir_code_str * I_RSHIFT             sizeof cstr "I_RSHIFT";
  store64 + @ir_code_str * I_DIV                sizeof cstr "I_DIV";
  store64 + @ir_code_str * I_DIVMOD             sizeof cstr "I_DIVMOD";
  store64 + @ir_code_str * I_LT                 sizeof cstr "I_LT";
  store64 + @ir_code_str * I_GT                 sizeof cstr "I_GT";
  store64 + @ir_code_str * I_AND                sizeof cstr "I_AND";
  store64 + @ir_code_str * I_LOGICAL_NOT        sizeof cstr "I_LOGICAL_NOT";
  store64 + @ir_code_str * I_OR                 sizeof cstr "I_OR";
  store64 + @ir_code_str * I_EQ                 sizeof cstr "I_EQ";
  store64 + @ir_code_str * I_NEQ                sizeof cstr "I_NEQ";
  store64 + @ir_code_str * I_RET                sizeof cstr "I_RET";
  store64 + @ir_code_str * I_NORET              sizeof cstr "I_NORET";
  store64 + @ir_code_str * I_PRINT              sizeof cstr "I_PRINT";
  store64 + @ir_code_str * I_LABEL              sizeof cstr "I_LABEL";
  store64 + @ir_code_str * I_CALL               sizeof cstr "I_CALL";
  store64 + @ir_code_str * I_ADDR_CALL          sizeof cstr "I_ADDR_CALL";
  store64 + @ir_code_str * I_JMP                sizeof cstr "I_JMP";
  store64 + @ir_code_str * I_JZ                 sizeof cstr "I_JZ";
  store64 + @ir_code_str * I_BEGIN_FUNC         sizeof cstr "I_BEGIN_FUNC";
  store64 + @ir_code_str * I_LOOP_LABEL         sizeof cstr "I_LOOP_LABEL";
  store64 + @ir_code_str * I_SYSCALL0           sizeof cstr "I_SYSCALL0";
  store64 + @ir_code_str * I_SYSCALL1           sizeof cstr "I_SYSCALL1";
  store64 + @ir_code_str * I_SYSCALL2           sizeof cstr "I_SYSCALL2";
  store64 + @ir_code_str * I_SYSCALL3           sizeof cstr "I_SYSCALL3";
  store64 + @ir_code_str * I_SYSCALL4           sizeof cstr "I_SYSCALL4";
  store64 + @ir_code_str * I_SYSCALL5           sizeof cstr "I_SYSCALL5";
  store64 + @ir_code_str * I_SYSCALL6           sizeof cstr "I_SYSCALL6";

  store64 + @compile_type_str * TypeNone           sizeof cstr "none";
  store64 + @compile_type_str * TypeAny            sizeof cstr "any";
  store64 + @compile_type_str * TypePtr            sizeof cstr "ptr";
  store64 + @compile_type_str * TypeUnsigned64     sizeof cstr "u64";
  store64 + @compile_type_str * TypeUnsigned32     sizeof cstr "u32";
  store64 + @compile_type_str * TypeUnsigned16     sizeof cstr "u16";
  store64 + @compile_type_str * TypeUnsigned8      sizeof cstr "u8";
  store64 + @compile_type_str * TypeCString        sizeof cstr "cstr";
  store64 + @compile_type_str * TypeFunc           sizeof cstr "func";
  store64 + @compile_type_str * TypeSyscallFunc    sizeof cstr "syscallfunc";
  store64 + @compile_type_str * TypeStruct         sizeof cstr "struct";
  store64 + @compile_type_str * MAX_PRIMITIVE_TYPE sizeof cstr "";

  store64 + @compile_type_size * TypeNone           sizeof u64 0;
  store64 + @compile_type_size * TypeAny            sizeof u64 sizeof ptr;
  store64 + @compile_type_size * TypePtr            sizeof u64 sizeof ptr;
  store64 + @compile_type_size * TypeUnsigned64     sizeof u64 sizeof u64;
  store64 + @compile_type_size * TypeUnsigned32     sizeof u64 sizeof u32;
  store64 + @compile_type_size * TypeUnsigned16     sizeof u64 sizeof u16;
  store64 + @compile_type_size * TypeUnsigned8      sizeof u64 sizeof u8;
  store64 + @compile_type_size * TypeCString        sizeof u64 sizeof ptr;
  store64 + @compile_type_size * TypeFunc           sizeof u64 sizeof ptr;
  store64 + @compile_type_size * TypeSyscallFunc    sizeof u64 sizeof ptr;
  store64 + @compile_type_size * TypeStruct         sizeof u64 1;
  store64 + @compile_type_size * MAX_PRIMITIVE_TYPE sizeof u64 0;

  { let _ compile_create_syscall("syscall0", 0); }
  { let _ compile_create_syscall("syscall1", 1); }
  { let _ compile_create_syscall("syscall2", 2); }
  { let _ compile_create_syscall("syscall3", 3); }
  { let _ compile_create_syscall("syscall4", 4); }
  { let _ compile_create_syscall("syscall5", 5); }
  { let _ compile_create_syscall("syscall6", 6); }


  {
    let value : Value 0;
    store64 + @value Value.num load64 + @p Parser.source_hash;
    store64 + @value Value.konst 1;

    let _ compile_create_value("VERSION_ID", @value, TypeUnsigned64);
  }

  NoError;
}

fn compile_state_free -> none {
  memory_free(c, sizeof Compile);
}
